(self.webpackChunktodo_frontend = self.webpackChunktodo_frontend || []).push([[179], { 255: t => { function e(t) { return Promise.resolve().then(() => { var e = new Error("Cannot find module '" + t + "'"); throw e.code = "MODULE_NOT_FOUND", e }) } e.keys = () => [], e.resolve = e, e.id = 255, t.exports = e }, 657: (t, e, n) => { "use strict"; function i(t) { return "function" == typeof t } let s = !1; const r = { Promise: void 0, set useDeprecatedSynchronousErrorHandling(t) { if (t) { const t = new Error; console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + t.stack) } else s && console.log("RxJS: Back to a better error behavior. Thank you. <3"); s = t }, get useDeprecatedSynchronousErrorHandling() { return s } }; function o(t) { setTimeout(() => { throw t }, 0) } const a = { closed: !0, next(t) { }, error(t) { if (r.useDeprecatedSynchronousErrorHandling) throw t; o(t) }, complete() { } }, l = (() => Array.isArray || (t => t && "number" == typeof t.length))(); function c(t) { return null !== t && "object" == typeof t } const h = (() => { function t(t) { return Error.call(this), this.message = t ? `${t.length} errors occurred during unsubscription:\n${t.map((t, e) => `${e + 1}) ${t.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = t, this } return t.prototype = Object.create(Error.prototype), t })(); let u = (() => { class t { constructor(t) { this.closed = !1, this._parentOrParents = null, this._subscriptions = null, t && (this._ctorUnsubscribe = !0, this._unsubscribe = t) } unsubscribe() { let e; if (this.closed) return; let { _parentOrParents: n, _ctorUnsubscribe: s, _unsubscribe: r, _subscriptions: o } = this; if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, n instanceof t) n.remove(this); else if (null !== n) for (let t = 0; t < n.length; ++t)n[t].remove(this); if (i(r)) { s && (this._unsubscribe = void 0); try { r.call(this) } catch (a) { e = a instanceof h ? d(a.errors) : [a] } } if (l(o)) { let t = -1, n = o.length; for (; ++t < n;) { const n = o[t]; if (c(n)) try { n.unsubscribe() } catch (a) { e = e || [], a instanceof h ? e = e.concat(d(a.errors)) : e.push(a) } } } if (e) throw new h(e) } add(e) { let n = e; if (!e) return t.EMPTY; switch (typeof e) { case "function": n = new t(e); case "object": if (n === this || n.closed || "function" != typeof n.unsubscribe) return n; if (this.closed) return n.unsubscribe(), n; if (!(n instanceof t)) { const e = n; n = new t, n._subscriptions = [e] } break; default: throw new Error("unrecognized teardown " + e + " added to Subscription.") }let { _parentOrParents: i } = n; if (null === i) n._parentOrParents = this; else if (i instanceof t) { if (i === this) return n; n._parentOrParents = [i, this] } else { if (-1 !== i.indexOf(this)) return n; i.push(this) } const s = this._subscriptions; return null === s ? this._subscriptions = [n] : s.push(n), n } remove(t) { const e = this._subscriptions; if (e) { const n = e.indexOf(t); -1 !== n && e.splice(n, 1) } } } return t.EMPTY = function (t) { return t.closed = !0, t }(new t), t })(); function d(t) { return t.reduce((t, e) => t.concat(e instanceof h ? e.errors : e), []) } const p = (() => "function" == typeof Symbol ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random())(); class f extends u { constructor(t, e, n) { switch (super(), this.syncErrorValue = null, this.syncErrorThrown = !1, this.syncErrorThrowable = !1, this.isStopped = !1, arguments.length) { case 0: this.destination = a; break; case 1: if (!t) { this.destination = a; break } if ("object" == typeof t) { t instanceof f ? (this.syncErrorThrowable = t.syncErrorThrowable, this.destination = t, t.add(this)) : (this.syncErrorThrowable = !0, this.destination = new m(this, t)); break } default: this.syncErrorThrowable = !0, this.destination = new m(this, t, e, n) } } [p]() { return this } static create(t, e, n) { const i = new f(t, e, n); return i.syncErrorThrowable = !1, i } next(t) { this.isStopped || this._next(t) } error(t) { this.isStopped || (this.isStopped = !0, this._error(t)) } complete() { this.isStopped || (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe()) } _next(t) { this.destination.next(t) } _error(t) { this.destination.error(t), this.unsubscribe() } _complete() { this.destination.complete(), this.unsubscribe() } _unsubscribeAndRecycle() { const { _parentOrParents: t } = this; return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parentOrParents = t, this } } class m extends f { constructor(t, e, n, s) { let r; super(), this._parentSubscriber = t; let o = this; i(e) ? r = e : e && (r = e.next, n = e.error, s = e.complete, e !== a && (o = Object.create(e), i(o.unsubscribe) && this.add(o.unsubscribe.bind(o)), o.unsubscribe = this.unsubscribe.bind(this))), this._context = o, this._next = r, this._error = n, this._complete = s } next(t) { if (!this.isStopped && this._next) { const { _parentSubscriber: e } = this; r.useDeprecatedSynchronousErrorHandling && e.syncErrorThrowable ? this.__tryOrSetError(e, this._next, t) && this.unsubscribe() : this.__tryOrUnsub(this._next, t) } } error(t) { if (!this.isStopped) { const { _parentSubscriber: e } = this, { useDeprecatedSynchronousErrorHandling: n } = r; if (this._error) n && e.syncErrorThrowable ? (this.__tryOrSetError(e, this._error, t), this.unsubscribe()) : (this.__tryOrUnsub(this._error, t), this.unsubscribe()); else if (e.syncErrorThrowable) n ? (e.syncErrorValue = t, e.syncErrorThrown = !0) : o(t), this.unsubscribe(); else { if (this.unsubscribe(), n) throw t; o(t) } } } complete() { if (!this.isStopped) { const { _parentSubscriber: t } = this; if (this._complete) { const e = () => this._complete.call(this._context); r.useDeprecatedSynchronousErrorHandling && t.syncErrorThrowable ? (this.__tryOrSetError(t, e), this.unsubscribe()) : (this.__tryOrUnsub(e), this.unsubscribe()) } else this.unsubscribe() } } __tryOrUnsub(t, e) { try { t.call(this._context, e) } catch (n) { if (this.unsubscribe(), r.useDeprecatedSynchronousErrorHandling) throw n; o(n) } } __tryOrSetError(t, e, n) { if (!r.useDeprecatedSynchronousErrorHandling) throw new Error("bad call"); try { e.call(this._context, n) } catch (i) { return r.useDeprecatedSynchronousErrorHandling ? (t.syncErrorValue = i, t.syncErrorThrown = !0, !0) : (o(i), !0) } return !1 } _unsubscribe() { const { _parentSubscriber: t } = this; this._context = null, this._parentSubscriber = null, t.unsubscribe() } } const g = (() => "function" == typeof Symbol && Symbol.observable || "@@observable")(); function _(t) { return t } let y = (() => { class t { constructor(t) { this._isScalar = !1, t && (this._subscribe = t) } lift(e) { const n = new t; return n.source = this, n.operator = e, n } subscribe(t, e, n) { const { operator: i } = this, s = function (t, e, n) { if (t) { if (t instanceof f) return t; if (t[p]) return t[p]() } return t || e || n ? new f(t, e, n) : new f(a) }(t, e, n); if (s.add(i ? i.call(s, this.source) : this.source || r.useDeprecatedSynchronousErrorHandling && !s.syncErrorThrowable ? this._subscribe(s) : this._trySubscribe(s)), r.useDeprecatedSynchronousErrorHandling && s.syncErrorThrowable && (s.syncErrorThrowable = !1, s.syncErrorThrown)) throw s.syncErrorValue; return s } _trySubscribe(t) { try { return this._subscribe(t) } catch (e) { r.useDeprecatedSynchronousErrorHandling && (t.syncErrorThrown = !0, t.syncErrorValue = e), function (t) { for (; t;) { const { closed: e, destination: n, isStopped: i } = t; if (e || i) return !1; t = n && n instanceof f ? n : null } return !0 }(t) ? t.error(e) : console.warn(e) } } forEach(t, e) { return new (e = b(e))((e, n) => { let i; i = this.subscribe(e => { try { t(e) } catch (s) { n(s), i && i.unsubscribe() } }, n, e) }) } _subscribe(t) { const { source: e } = this; return e && e.subscribe(t) } [g]() { return this } pipe(...t) { return 0 === t.length ? this : (0 === (e = t).length ? _ : 1 === e.length ? e[0] : function (t) { return e.reduce((t, e) => e(t), t) })(this); var e } toPromise(t) { return new (t = b(t))((t, e) => { let n; this.subscribe(t => n = t, t => e(t), () => t(n)) }) } } return t.create = e => new t(e), t })(); function b(t) { if (t || (t = r.Promise || Promise), !t) throw new Error("no Promise impl found"); return t } const v = (() => { function t() { return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this } return t.prototype = Object.create(Error.prototype), t })(); class w extends u { constructor(t, e) { super(), this.subject = t, this.subscriber = e, this.closed = !1 } unsubscribe() { if (this.closed) return; this.closed = !0; const t = this.subject, e = t.observers; if (this.subject = null, !e || 0 === e.length || t.isStopped || t.closed) return; const n = e.indexOf(this.subscriber); -1 !== n && e.splice(n, 1) } } class C extends f { constructor(t) { super(t), this.destination = t } } let k = (() => { class t extends y { constructor() { super(), this.observers = [], this.closed = !1, this.isStopped = !1, this.hasError = !1, this.thrownError = null } [p]() { return new C(this) } lift(t) { const e = new x(this, this); return e.operator = t, e } next(t) { if (this.closed) throw new v; if (!this.isStopped) { const { observers: e } = this, n = e.length, i = e.slice(); for (let s = 0; s < n; s++)i[s].next(t) } } error(t) { if (this.closed) throw new v; this.hasError = !0, this.thrownError = t, this.isStopped = !0; const { observers: e } = this, n = e.length, i = e.slice(); for (let s = 0; s < n; s++)i[s].error(t); this.observers.length = 0 } complete() { if (this.closed) throw new v; this.isStopped = !0; const { observers: t } = this, e = t.length, n = t.slice(); for (let i = 0; i < e; i++)n[i].complete(); this.observers.length = 0 } unsubscribe() { this.isStopped = !0, this.closed = !0, this.observers = null } _trySubscribe(t) { if (this.closed) throw new v; return super._trySubscribe(t) } _subscribe(t) { if (this.closed) throw new v; return this.hasError ? (t.error(this.thrownError), u.EMPTY) : this.isStopped ? (t.complete(), u.EMPTY) : (this.observers.push(t), new w(this, t)) } asObservable() { const t = new y; return t.source = this, t } } return t.create = (t, e) => new x(t, e), t })(); class x extends k { constructor(t, e) { super(), this.destination = t, this.source = e } next(t) { const { destination: e } = this; e && e.next && e.next(t) } error(t) { const { destination: e } = this; e && e.error && this.destination.error(t) } complete() { const { destination: t } = this; t && t.complete && this.destination.complete() } _subscribe(t) { const { source: e } = this; return e ? this.source.subscribe(t) : u.EMPTY } } function S(t) { return t && "function" == typeof t.schedule } function E(t, e) { return function (n) { if ("function" != typeof t) throw new TypeError("argument is not a function. Are you looking for `mapTo()`?"); return n.lift(new T(t, e)) } } class T { constructor(t, e) { this.project = t, this.thisArg = e } call(t, e) { return e.subscribe(new R(t, this.project, this.thisArg)) } } class R extends f { constructor(t, e, n) { super(t), this.project = e, this.count = 0, this.thisArg = n || this } _next(t) { let e; try { e = this.project.call(this.thisArg, t, this.count++) } catch (n) { return void this.destination.error(n) } this.destination.next(e) } } const A = t => e => { for (let n = 0, i = t.length; n < i && !e.closed; n++)e.next(t[n]); e.complete() }; function O() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" } const I = O(), D = t => t && "number" == typeof t.length && "function" != typeof t; function P(t) { return !!t && "function" != typeof t.subscribe && "function" == typeof t.then } const M = t => { if (t && "function" == typeof t[g]) return n = t, t => { const e = n[g](); if ("function" != typeof e.subscribe) throw new TypeError("Provided object does not correctly implement Symbol.observable"); return e.subscribe(t) }; if (D(t)) return A(t); if (P(t)) return (t => e => (t.then(t => { e.closed || (e.next(t), e.complete()) }, t => e.error(t)).then(null, o), e))(t); if (t && "function" == typeof t[I]) return e = t, t => { const n = e[I](); for (; ;) { let e; try { e = n.next() } catch (i) { return t.error(i), t } if (e.done) { t.complete(); break } if (t.next(e.value), t.closed) break } return "function" == typeof n.return && t.add(() => { n.return && n.return() }), t }; { const e = c(t) ? "an invalid object" : `'${t}'`; throw new TypeError(`You provided ${e} where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`) } var e, n }; function N(t, e) { return new y(n => { const i = new u; let s = 0; return i.add(e.schedule(function () { s !== t.length ? (n.next(t[s++]), n.closed || i.add(this.schedule())) : n.complete() })), i }) } function F(t, e) { return e ? function (t, e) { if (null != t) { if (function (t) { return t && "function" == typeof t[g] }(t)) return function (t, e) { return new y(n => { const i = new u; return i.add(e.schedule(() => { const s = t[g](); i.add(s.subscribe({ next(t) { i.add(e.schedule(() => n.next(t))) }, error(t) { i.add(e.schedule(() => n.error(t))) }, complete() { i.add(e.schedule(() => n.complete())) } })) })), i }) }(t, e); if (P(t)) return function (t, e) { return new y(n => { const i = new u; return i.add(e.schedule(() => t.then(t => { i.add(e.schedule(() => { n.next(t), i.add(e.schedule(() => n.complete())) })) }, t => { i.add(e.schedule(() => n.error(t))) }))), i }) }(t, e); if (D(t)) return N(t, e); if (function (t) { return t && "function" == typeof t[I] }(t) || "string" == typeof t) return function (t, e) { if (!t) throw new Error("Iterable cannot be null"); return new y(n => { const i = new u; let s; return i.add(() => { s && "function" == typeof s.return && s.return() }), i.add(e.schedule(() => { s = t[I](), i.add(e.schedule(function () { if (n.closed) return; let t, e; try { const n = s.next(); t = n.value, e = n.done } catch (i) { return void n.error(i) } e ? n.complete() : (n.next(t), this.schedule()) })) })), i }) }(t, e) } throw new TypeError((null !== t && typeof t || t) + " is not observable") }(t, e) : t instanceof y ? t : new y(M(t)) } class L extends f { constructor(t) { super(), this.parent = t } _next(t) { this.parent.notifyNext(t) } _error(t) { this.parent.notifyError(t), this.unsubscribe() } _complete() { this.parent.notifyComplete(), this.unsubscribe() } } class V extends f { notifyNext(t) { this.destination.next(t) } notifyError(t) { this.destination.error(t) } notifyComplete() { this.destination.complete() } } function j(t, e) { if (e.closed) return; if (t instanceof y) return t.subscribe(e); let n; try { n = M(t)(e) } catch (i) { e.error(i) } return n } function B(t, e, n = Number.POSITIVE_INFINITY) { return "function" == typeof e ? i => i.pipe(B((n, i) => F(t(n, i)).pipe(E((t, s) => e(n, t, i, s))), n)) : ("number" == typeof e && (n = e), e => e.lift(new H(t, n))) } class H { constructor(t, e = Number.POSITIVE_INFINITY) { this.project = t, this.concurrent = e } call(t, e) { return e.subscribe(new U(t, this.project, this.concurrent)) } } class U extends V { constructor(t, e, n = Number.POSITIVE_INFINITY) { super(t), this.project = e, this.concurrent = n, this.hasCompleted = !1, this.buffer = [], this.active = 0, this.index = 0 } _next(t) { this.active < this.concurrent ? this._tryNext(t) : this.buffer.push(t) } _tryNext(t) { let e; const n = this.index++; try { e = this.project(t, n) } catch (i) { return void this.destination.error(i) } this.active++, this._innerSub(e) } _innerSub(t) { const e = new L(this), n = this.destination; n.add(e); const i = j(t, e); i !== e && n.add(i) } _complete() { this.hasCompleted = !0, 0 === this.active && 0 === this.buffer.length && this.destination.complete(), this.unsubscribe() } notifyNext(t) { this.destination.next(t) } notifyComplete() { const t = this.buffer; this.active--, t.length > 0 ? this._next(t.shift()) : 0 === this.active && this.hasCompleted && this.destination.complete() } } function z(t = Number.POSITIVE_INFINITY) { return B(_, t) } function $(t, e) { return e ? N(t, e) : new y(A(t)) } function q(...t) { let e = Number.POSITIVE_INFINITY, n = null, i = t[t.length - 1]; return S(i) ? (n = t.pop(), t.length > 1 && "number" == typeof t[t.length - 1] && (e = t.pop())) : "number" == typeof i && (e = t.pop()), null === n && 1 === t.length && t[0] instanceof y ? t[0] : z(e)($(t, n)) } function W() { return function (t) { return t.lift(new K(t)) } } class K { constructor(t) { this.connectable = t } call(t, e) { const { connectable: n } = this; n._refCount++; const i = new Y(t, n), s = e.subscribe(i); return i.closed || (i.connection = n.connect()), s } } class Y extends f { constructor(t, e) { super(t), this.connectable = e } _unsubscribe() { const { connectable: t } = this; if (!t) return void (this.connection = null); this.connectable = null; const e = t._refCount; if (e <= 0) return void (this.connection = null); if (t._refCount = e - 1, e > 1) return void (this.connection = null); const { connection: n } = this, i = t._connection; this.connection = null, !i || n && i !== n || i.unsubscribe() } } class Z extends y { constructor(t, e) { super(), this.source = t, this.subjectFactory = e, this._refCount = 0, this._isComplete = !1 } _subscribe(t) { return this.getSubject().subscribe(t) } getSubject() { const t = this._subject; return t && !t.isStopped || (this._subject = this.subjectFactory()), this._subject } connect() { let t = this._connection; return t || (this._isComplete = !1, t = this._connection = new u, t.add(this.source.subscribe(new Q(this.getSubject(), this))), t.closed && (this._connection = null, t = u.EMPTY)), t } refCount() { return W()(this) } } const G = (() => { const t = Z.prototype; return { operator: { value: null }, _refCount: { value: 0, writable: !0 }, _subject: { value: null, writable: !0 }, _connection: { value: null, writable: !0 }, _subscribe: { value: t._subscribe }, _isComplete: { value: t._isComplete, writable: !0 }, getSubject: { value: t.getSubject }, connect: { value: t.connect }, refCount: { value: t.refCount } } })(); class Q extends C { constructor(t, e) { super(t), this.connectable = e } _error(t) { this._unsubscribe(), super._error(t) } _complete() { this.connectable._isComplete = !0, this._unsubscribe(), super._complete() } _unsubscribe() { const t = this.connectable; if (t) { this.connectable = null; const e = t._connection; t._refCount = 0, t._subject = null, t._connection = null, e && e.unsubscribe() } } } function X() { return new k } function J() { return t => { return W()((e = X, function (t) { let n; n = "function" == typeof e ? e : function () { return e }; const i = Object.create(t, G); return i.source = t, i.subjectFactory = n, i })(t)); var e } } function tt(t) { for (let e in t) if (t[e] === tt) return e; throw Error("Could not find renamed property on target object.") } function et(t, e) { for (const n in e) e.hasOwnProperty(n) && !t.hasOwnProperty(n) && (t[n] = e[n]) } function nt(t) { if ("string" == typeof t) return t; if (Array.isArray(t)) return "[" + t.map(nt).join(", ") + "]"; if (null == t) return "" + t; if (t.overriddenName) return `${t.overriddenName}`; if (t.name) return `${t.name}`; const e = t.toString(); if (null == e) return "" + e; const n = e.indexOf("\n"); return -1 === n ? e : e.substring(0, n) } function it(t, e) { return null == t || "" === t ? null === e ? "" : e : null == e || "" === e ? t : t + " " + e } const st = tt({ __forward_ref__: tt }); function rt(t) { return t.__forward_ref__ = rt, t.toString = function () { return nt(this()) }, t } function ot(t) { return at(t) ? t() : t } function at(t) { return "function" == typeof t && t.hasOwnProperty(st) && t.__forward_ref__ === rt } class lt extends Error { constructor(t, e) { super(function (t, e) { return `${t ? `NG0${t}: ` : ""}${e}` }(t, e)), this.code = t } } function ct(t) { return "string" == typeof t ? t : null == t ? "" : String(t) } function ht(t) { return "function" == typeof t ? t.name || t.toString() : "object" == typeof t && null != t && "function" == typeof t.type ? t.type.name || t.type.toString() : ct(t) } function ut(t, e) { const n = e ? ` in ${e}` : ""; throw new lt("201", `No provider for ${ht(t)} found${n}`) } function dt(t) { return { token: t.token, providedIn: t.providedIn || null, factory: t.factory, value: void 0 } } function pt(t) { return { providers: t.providers || [], imports: t.imports || [] } } function ft(t) { return mt(t, _t) || mt(t, bt) } function mt(t, e) { return t.hasOwnProperty(e) ? t[e] : null } function gt(t) { return t && (t.hasOwnProperty(yt) || t.hasOwnProperty(vt)) ? t[yt] : null } const _t = tt({ "\u0275prov": tt }), yt = tt({ "\u0275inj": tt }), bt = tt({ ngInjectableDef: tt }), vt = tt({ ngInjectorDef: tt }); var wt = function (t) { return t[t.Default = 0] = "Default", t[t.Host = 1] = "Host", t[t.Self = 2] = "Self", t[t.SkipSelf = 4] = "SkipSelf", t[t.Optional = 8] = "Optional", t }({}); let Ct; function kt(t) { const e = Ct; return Ct = t, e } function xt(t, e, n) { const i = ft(t); return i && "root" == i.providedIn ? void 0 === i.value ? i.value = i.factory() : i.value : n & wt.Optional ? null : void 0 !== e ? e : void ut(nt(t), "Injector") } function St(t) { return { toString: t }.toString() } var Et = function (t) { return t[t.OnPush = 0] = "OnPush", t[t.Default = 1] = "Default", t }({}), Tt = function (t) { return t[t.Emulated = 0] = "Emulated", t[t.None = 2] = "None", t[t.ShadowDom = 3] = "ShadowDom", t }({}); const Rt = "undefined" != typeof globalThis && globalThis, At = "undefined" != typeof window && window, Ot = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self, It = "undefined" != typeof global && global, Dt = Rt || It || At || Ot, Pt = {}, Mt = [], Nt = tt({ "\u0275cmp": tt }), Ft = tt({ "\u0275dir": tt }), Lt = tt({ "\u0275pipe": tt }), Vt = tt({ "\u0275mod": tt }), jt = tt({ "\u0275loc": tt }), Bt = tt({ "\u0275fac": tt }), Ht = tt({ __NG_ELEMENT_ID__: tt }); let Ut = 0; function zt(t) { return St(() => { const e = {}, n = { type: t.type, providersResolver: null, decls: t.decls, vars: t.vars, factory: null, template: t.template || null, consts: t.consts || null, ngContentSelectors: t.ngContentSelectors, hostBindings: t.hostBindings || null, hostVars: t.hostVars || 0, hostAttrs: t.hostAttrs || null, contentQueries: t.contentQueries || null, declaredInputs: e, inputs: null, outputs: null, exportAs: t.exportAs || null, onPush: t.changeDetection === Et.OnPush, directiveDefs: null, pipeDefs: null, selectors: t.selectors || Mt, viewQuery: t.viewQuery || null, features: t.features || null, data: t.data || {}, encapsulation: t.encapsulation || Tt.Emulated, id: "c", styles: t.styles || Mt, _: null, setInput: null, schemas: t.schemas || null, tView: null }, i = t.directives, s = t.features, r = t.pipes; return n.id += Ut++, n.inputs = Yt(t.inputs, e), n.outputs = Yt(t.outputs), s && s.forEach(t => t(n)), n.directiveDefs = i ? () => ("function" == typeof i ? i() : i).map($t) : null, n.pipeDefs = r ? () => ("function" == typeof r ? r() : r).map(qt) : null, n }) } function $t(t) { return Gt(t) || function (t) { return t[Ft] || null }(t) } function qt(t) { return function (t) { return t[Lt] || null }(t) } const Wt = {}; function Kt(t) { const e = { type: t.type, bootstrap: t.bootstrap || Mt, declarations: t.declarations || Mt, imports: t.imports || Mt, exports: t.exports || Mt, transitiveCompileScopes: null, schemas: t.schemas || null, id: t.id || null }; return null != t.id && St(() => { Wt[t.id] = t.type }), e } function Yt(t, e) { if (null == t) return Pt; const n = {}; for (const i in t) if (t.hasOwnProperty(i)) { let s = t[i], r = s; Array.isArray(s) && (r = s[1], s = s[0]), n[s] = i, e && (e[s] = r) } return n } const Zt = zt; function Gt(t) { return t[Nt] || null } function Qt(t, e) { const n = t[Vt] || null; if (!n && !0 === e) throw new Error(`Type ${nt(t)} does not have '\u0275mod' property.`); return n } const Xt = 20, Jt = 10; function te(t) { return Array.isArray(t) && "object" == typeof t[1] } function ee(t) { return Array.isArray(t) && !0 === t[1] } function ne(t) { return 0 != (8 & t.flags) } function ie(t) { return 2 == (2 & t.flags) } function se(t) { return 1 == (1 & t.flags) } function re(t) { return null !== t.template } function oe(t, e) { return t.hasOwnProperty(Bt) ? t[Bt] : null } class ae { constructor(t, e, n) { this.previousValue = t, this.currentValue = e, this.firstChange = n } isFirstChange() { return this.firstChange } } function le() { return ce } function ce(t) { return t.type.prototype.ngOnChanges && (t.setInput = ue), he } function he() { const t = de(this), e = null == t ? void 0 : t.current; if (e) { const n = t.previous; if (n === Pt) t.previous = e; else for (let t in e) n[t] = e[t]; t.current = null, this.ngOnChanges(e) } } function ue(t, e, n, i) { const s = de(t) || function (t, e) { return t.__ngSimpleChanges__ = e }(t, { previous: Pt, current: null }), r = s.current || (s.current = {}), o = s.previous, a = this.declaredInputs[n], l = o[a]; r[a] = new ae(l && l.currentValue, e, o === Pt), t[i] = e } function de(t) { return t.__ngSimpleChanges__ || null } le.ngInherit = !0; const pe = "http://www.w3.org/2000/svg"; let fe; function me(t) { return !!t.listen } const ge = { createRenderer: (t, e) => void 0 !== fe ? fe : "undefined" != typeof document ? document : void 0 }; function _e(t) { for (; Array.isArray(t);)t = t[0]; return t } function ye(t, e) { return _e(e[t]) } function be(t, e) { return _e(e[t.index]) } function ve(t, e) { return t.data[e] } function we(t, e) { const n = e[t]; return te(n) ? n : n[0] } function Ce(t) { return 4 == (4 & t[2]) } function ke(t) { return 128 == (128 & t[2]) } function xe(t, e) { return null == e ? null : t[e] } function Se(t) { t[18] = 0 } function Ee(t, e) { t[5] += e; let n = t, i = t[3]; for (; null !== i && (1 === e && 1 === n[5] || -1 === e && 0 === n[5]);)i[5] += e, n = i, i = i[3] } const Te = { lFrame: Ge(null), bindingsEnabled: !0, isInCheckNoChangesMode: !1 }; function Re() { return Te.bindingsEnabled } function Ae() { return Te.lFrame.lView } function Oe() { return Te.lFrame.tView } function Ie(t) { return Te.lFrame.contextLView = t, t[8] } function De() { let t = Pe(); for (; null !== t && 64 === t.type;)t = t.parent; return t } function Pe() { return Te.lFrame.currentTNode } function Me(t, e) { const n = Te.lFrame; n.currentTNode = t, n.isParent = e } function Ne() { return Te.lFrame.isParent } function Fe() { Te.lFrame.isParent = !1 } function Le() { return Te.isInCheckNoChangesMode } function Ve(t) { Te.isInCheckNoChangesMode = t } function je() { return Te.lFrame.bindingIndex++ } function Be(t) { const e = Te.lFrame, n = e.bindingIndex; return e.bindingIndex = e.bindingIndex + t, n } function He(t, e) { const n = Te.lFrame; n.bindingIndex = n.bindingRootIndex = t, Ue(e) } function Ue(t) { Te.lFrame.currentDirectiveIndex = t } function ze(t) { const e = Te.lFrame.currentDirectiveIndex; return -1 === e ? null : t[e] } function $e() { return Te.lFrame.currentQueryIndex } function qe(t) { Te.lFrame.currentQueryIndex = t } function We(t) { const e = t[1]; return 2 === e.type ? e.declTNode : 1 === e.type ? t[6] : null } function Ke(t, e, n) { if (n & wt.SkipSelf) { let i = e, s = t; for (; i = i.parent, !(null !== i || n & wt.Host || (i = We(s), null === i) || (s = s[15], 10 & i.type));); if (null === i) return !1; e = i, t = s } const i = Te.lFrame = Ze(); return i.currentTNode = e, i.lView = t, !0 } function Ye(t) { const e = Ze(), n = t[1]; Te.lFrame = e, e.currentTNode = n.firstChild, e.lView = t, e.tView = n, e.contextLView = t, e.bindingIndex = n.bindingStartIndex, e.inI18n = !1 } function Ze() { const t = Te.lFrame, e = null === t ? null : t.child; return null === e ? Ge(t) : e } function Ge(t) { const e = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: t, child: null, inI18n: !1 }; return null !== t && (t.child = e), e } function Qe() { const t = Te.lFrame; return Te.lFrame = t.parent, t.currentTNode = null, t.lView = null, t } const Xe = Qe; function Je() { const t = Qe(); t.isParent = !0, t.tView = null, t.selectedIndex = -1, t.contextLView = null, t.elementDepthCount = 0, t.currentDirectiveIndex = -1, t.currentNamespace = null, t.bindingRootIndex = -1, t.bindingIndex = -1, t.currentQueryIndex = 0 } function tn() { return Te.lFrame.selectedIndex } function en(t) { Te.lFrame.selectedIndex = t } function nn() { const t = Te.lFrame; return ve(t.tView, t.selectedIndex) } function sn(t, e) { for (let n = e.directiveStart, i = e.directiveEnd; n < i; n++) { const e = t.data[n].type.prototype, { ngAfterContentInit: i, ngAfterContentChecked: s, ngAfterViewInit: r, ngAfterViewChecked: o, ngOnDestroy: a } = e; i && (t.contentHooks || (t.contentHooks = [])).push(-n, i), s && ((t.contentHooks || (t.contentHooks = [])).push(n, s), (t.contentCheckHooks || (t.contentCheckHooks = [])).push(n, s)), r && (t.viewHooks || (t.viewHooks = [])).push(-n, r), o && ((t.viewHooks || (t.viewHooks = [])).push(n, o), (t.viewCheckHooks || (t.viewCheckHooks = [])).push(n, o)), null != a && (t.destroyHooks || (t.destroyHooks = [])).push(n, a) } } function rn(t, e, n) { ln(t, e, 3, n) } function on(t, e, n, i) { (3 & t[2]) === n && ln(t, e, n, i) } function an(t, e) { let n = t[2]; (3 & n) === e && (n &= 2047, n += 1, t[2] = n) } function ln(t, e, n, i) { const s = null != i ? i : -1, r = e.length - 1; let o = 0; for (let a = void 0 !== i ? 65535 & t[18] : 0; a < r; a++)if ("number" == typeof e[a + 1]) { if (o = e[a], null != i && o >= i) break } else e[a] < 0 && (t[18] += 65536), (o < s || -1 == s) && (cn(t, n, e, a), t[18] = (4294901760 & t[18]) + a + 2), a++ } function cn(t, e, n, i) { const s = n[i] < 0, r = n[i + 1], o = t[s ? -n[i] : n[i]]; if (s) { if (t[2] >> 11 < t[18] >> 16 && (3 & t[2]) === e) { t[2] += 2048; try { r.call(o) } finally { } } } else try { r.call(o) } finally { } } const hn = -1; class un { constructor(t, e, n) { this.factory = t, this.resolving = !1, this.canSeeViewProviders = e, this.injectImpl = n } } function dn(t, e, n) { const i = me(t); let s = 0; for (; s < n.length;) { const r = n[s]; if ("number" == typeof r) { if (0 !== r) break; s++; const o = n[s++], a = n[s++], l = n[s++]; i ? t.setAttribute(e, a, l, o) : e.setAttributeNS(o, a, l) } else { const o = r, a = n[++s]; fn(o) ? i && t.setProperty(e, o, a) : i ? t.setAttribute(e, o, a) : e.setAttribute(o, a), s++ } } return s } function pn(t) { return 3 === t || 4 === t || 6 === t } function fn(t) { return 64 === t.charCodeAt(0) } function mn(t, e) { if (null === e || 0 === e.length); else if (null === t || 0 === t.length) t = e.slice(); else { let n = -1; for (let i = 0; i < e.length; i++) { const s = e[i]; "number" == typeof s ? n = s : 0 === n || gn(t, n, s, null, -1 === n || 2 === n ? e[++i] : null) } } return t } function gn(t, e, n, i, s) { let r = 0, o = t.length; if (-1 === e) o = -1; else for (; r < t.length;) { const n = t[r++]; if ("number" == typeof n) { if (n === e) { o = -1; break } if (n > e) { o = r - 1; break } } } for (; r < t.length;) { const e = t[r]; if ("number" == typeof e) break; if (e === n) { if (null === i) return void (null !== s && (t[r + 1] = s)); if (i === t[r + 1]) return void (t[r + 2] = s) } r++, null !== i && r++, null !== s && r++ } -1 !== o && (t.splice(o, 0, e), r = o + 1), t.splice(r++, 0, n), null !== i && t.splice(r++, 0, i), null !== s && t.splice(r++, 0, s) } function _n(t) { return t !== hn } function yn(t) { return 32767 & t } function bn(t, e) { let n = t >> 16, i = e; for (; n > 0;)i = i[15], n--; return i } let vn = !0; function wn(t) { const e = vn; return vn = t, e } let Cn = 0; function kn(t, e) { const n = Sn(t, e); if (-1 !== n) return n; const i = e[1]; i.firstCreatePass && (t.injectorIndex = e.length, xn(i.data, t), xn(e, null), xn(i.blueprint, null)); const s = En(t, e), r = t.injectorIndex; if (_n(s)) { const t = yn(s), n = bn(s, e), i = n[1].data; for (let s = 0; s < 8; s++)e[r + s] = n[t + s] | i[t + s] } return e[r + 8] = s, r } function xn(t, e) { t.push(0, 0, 0, 0, 0, 0, 0, 0, e) } function Sn(t, e) { return -1 === t.injectorIndex || t.parent && t.parent.injectorIndex === t.injectorIndex || null === e[t.injectorIndex + 8] ? -1 : t.injectorIndex } function En(t, e) { if (t.parent && -1 !== t.parent.injectorIndex) return t.parent.injectorIndex; let n = 0, i = null, s = e; for (; null !== s;) { const t = s[1], e = t.type; if (i = 2 === e ? t.declTNode : 1 === e ? s[6] : null, null === i) return hn; if (n++, s = s[15], -1 !== i.injectorIndex) return i.injectorIndex | n << 16 } return hn } function Tn(t, e, n) { !function (t, e, n) { let i; "string" == typeof n ? i = n.charCodeAt(0) || 0 : n.hasOwnProperty(Ht) && (i = n[Ht]), null == i && (i = n[Ht] = Cn++); const s = 255 & i; e.data[t + (s >> 5)] |= 1 << s }(t, e, n) } function Rn(t, e, n) { if (n & wt.Optional) return t; ut(e, "NodeInjector") } function An(t, e, n, i) { if (n & wt.Optional && void 0 === i && (i = null), 0 == (n & (wt.Self | wt.Host))) { const s = t[9], r = kt(void 0); try { return s ? s.get(e, i, n & wt.Optional) : xt(e, i, n & wt.Optional) } finally { kt(r) } } return Rn(i, e, n) } function On(t, e, n, i = wt.Default, s) { if (null !== t) { const r = function (t) { if ("string" == typeof t) return t.charCodeAt(0) || 0; const e = t.hasOwnProperty(Ht) ? t[Ht] : void 0; return "number" == typeof e ? e >= 0 ? 255 & e : Dn : e }(n); if ("function" == typeof r) { if (!Ke(e, t, i)) return i & wt.Host ? Rn(s, n, i) : An(e, n, i, s); try { const t = r(i); if (null != t || i & wt.Optional) return t; ut(n) } finally { Xe() } } else if ("number" == typeof r) { let s = null, o = Sn(t, e), a = hn, l = i & wt.Host ? e[16][6] : null; for ((-1 === o || i & wt.SkipSelf) && (a = -1 === o ? En(t, e) : e[o + 8], a !== hn && Ln(i, !1) ? (s = e[1], o = yn(a), e = bn(a, e)) : o = -1); -1 !== o;) { const t = e[1]; if (Fn(r, o, t.data)) { const t = Pn(o, e, n, s, i, l); if (t !== In) return t } a = e[o + 8], a !== hn && Ln(i, e[1].data[o + 8] === l) && Fn(r, o, e) ? (s = t, o = yn(a), e = bn(a, e)) : o = -1 } } } return An(e, n, i, s) } const In = {}; function Dn() { return new Vn(De(), Ae()) } function Pn(t, e, n, i, s, r) { const o = e[1], a = o.data[t + 8], l = Mn(a, o, n, null == i ? ie(a) && vn : i != o && 0 != (3 & a.type), s & wt.Host && r === a); return null !== l ? Nn(e, o, l, a) : In } function Mn(t, e, n, i, s) { const r = t.providerIndexes, o = e.data, a = 1048575 & r, l = t.directiveStart, c = r >> 20, h = s ? a + c : t.directiveEnd; for (let u = i ? a : a + c; u < h; u++) { const t = o[u]; if (u < l && n === t || u >= l && t.type === n) return u } if (s) { const t = o[l]; if (t && re(t) && t.type === n) return l } return null } function Nn(t, e, n, i) { let s = t[n]; const r = e.data; if (s instanceof un) { const o = s; o.resolving && function (t, e) { throw new lt("200", `Circular dependency in DI detected for ${t}`) }(ht(r[n])); const a = wn(o.canSeeViewProviders); o.resolving = !0; const l = o.injectImpl ? kt(o.injectImpl) : null; Ke(t, i, wt.Default); try { s = t[n] = o.factory(void 0, r, t, i), e.firstCreatePass && n >= i.directiveStart && function (t, e, n) { const { ngOnChanges: i, ngOnInit: s, ngDoCheck: r } = e.type.prototype; if (i) { const i = ce(e); (n.preOrderHooks || (n.preOrderHooks = [])).push(t, i), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(t, i) } s && (n.preOrderHooks || (n.preOrderHooks = [])).push(0 - t, s), r && ((n.preOrderHooks || (n.preOrderHooks = [])).push(t, r), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(t, r)) }(n, r[n], e) } finally { null !== l && kt(l), wn(a), o.resolving = !1, Xe() } } return s } function Fn(t, e, n) { return !!(n[e + (t >> 5)] & 1 << t) } function Ln(t, e) { return !(t & wt.Self || t & wt.Host && e) } class Vn { constructor(t, e) { this._tNode = t, this._lView = e } get(t, e) { return On(this._tNode, this._lView, t, void 0, e) } } function jn(t) { return St(() => { const e = t.prototype.constructor, n = e[Bt] || Bn(e), i = Object.prototype; let s = Object.getPrototypeOf(t.prototype).constructor; for (; s && s !== i;) { const t = s[Bt] || Bn(s); if (t && t !== n) return t; s = Object.getPrototypeOf(s) } return t => new t }) } function Bn(t) { return at(t) ? () => { const e = Bn(ot(t)); return e && e() } : oe(t) } function Hn(t) { return function (t, e) { if ("class" === e) return t.classes; if ("style" === e) return t.styles; const n = t.attrs; if (n) { const t = n.length; let i = 0; for (; i < t;) { const s = n[i]; if (pn(s)) break; if (0 === s) i += 2; else if ("number" == typeof s) for (i++; i < t && "string" == typeof n[i];)i++; else { if (s === e) return n[i + 1]; i += 2 } } } return null }(De(), t) } const Un = "__parameters__"; function zn(t, e, n) { return St(() => { const i = function (t) { return function (...e) { if (t) { const n = t(...e); for (const t in n) this[t] = n[t] } } }(e); function s(...t) { if (this instanceof s) return i.apply(this, t), this; const e = new s(...t); return n.annotation = e, n; function n(t, n, i) { const s = t.hasOwnProperty(Un) ? t[Un] : Object.defineProperty(t, Un, { value: [] })[Un]; for (; s.length <= i;)s.push(null); return (s[i] = s[i] || []).push(e), t } } return n && (s.prototype = Object.create(n.prototype)), s.prototype.ngMetadataName = t, s.annotationCls = s, s }) } class $n { constructor(t, e) { this._desc = t, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof e ? this.__NG_ELEMENT_ID__ = e : void 0 !== e && (this.\u0275prov = dt({ token: this, providedIn: e.providedIn || "root", factory: e.factory })) } toString() { return `InjectionToken ${this._desc}` } } const qn = new $n("AnalyzeForEntryComponents"), Wn = Function; function Kn(t, e) { void 0 === e && (e = t); for (let n = 0; n < t.length; n++) { let i = t[n]; Array.isArray(i) ? (e === t && (e = t.slice(0, n)), Kn(i, e)) : e !== t && e.push(i) } return e } function Yn(t, e) { t.forEach(t => Array.isArray(t) ? Yn(t, e) : e(t)) } function Zn(t, e, n) { e >= t.length ? t.push(n) : t.splice(e, 0, n) } function Gn(t, e) { return e >= t.length - 1 ? t.pop() : t.splice(e, 1)[0] } function Qn(t, e) { const n = []; for (let i = 0; i < t; i++)n.push(e); return n } function Xn(t, e, n) { let i = ti(t, e); return i >= 0 ? t[1 | i] = n : (i = ~i, function (t, e, n, i) { let s = t.length; if (s == e) t.push(n, i); else if (1 === s) t.push(i, t[0]), t[0] = n; else { for (s--, t.push(t[s - 1], t[s]); s > e;)t[s] = t[s - 2], s--; t[e] = n, t[e + 1] = i } }(t, i, e, n)), i } function Jn(t, e) { const n = ti(t, e); if (n >= 0) return t[1 | n] } function ti(t, e) { return function (t, e, n) { let i = 0, s = t.length >> 1; for (; s !== i;) { const n = i + (s - i >> 1), r = t[n << 1]; if (e === r) return n << 1; r > e ? s = n : i = n + 1 } return ~(s << 1) }(t, e) } const ei = {}, ni = /\n/gm, ii = "__source", si = tt({ provide: String, useValue: tt }); let ri; function oi(t) { const e = ri; return ri = t, e } function ai(t, e = wt.Default) { if (void 0 === ri) throw new Error("inject() must be called from an injection context"); return null === ri ? xt(t, void 0, e) : ri.get(t, e & wt.Optional ? null : void 0, e) } function li(t, e = wt.Default) { return (Ct || ai)(ot(t), e) } const ci = li; function hi(t) { const e = []; for (let n = 0; n < t.length; n++) { const i = ot(t[n]); if (Array.isArray(i)) { if (0 === i.length) throw new Error("Arguments array must have arguments."); let t, n = wt.Default; for (let e = 0; e < i.length; e++) { const s = i[e], r = s.__NG_DI_FLAG__; "number" == typeof r ? -1 === r ? t = s.token : n |= r : t = s } e.push(li(t, n)) } else e.push(li(i)) } return e } function ui(t, e) { return t.__NG_DI_FLAG__ = e, t.prototype.__NG_DI_FLAG__ = e, t } const di = ui(zn("Inject", t => ({ token: t })), -1), pi = ui(zn("Optional"), 8), fi = ui(zn("SkipSelf"), 4); let mi; function gi(t) { var e; return (null === (e = function () { if (void 0 === mi && (mi = null, Dt.trustedTypes)) try { mi = Dt.trustedTypes.createPolicy("angular", { createHTML: t => t, createScript: t => t, createScriptURL: t => t }) } catch (e) { } return mi }()) || void 0 === e ? void 0 : e.createHTML(t)) || t } class _i { constructor(t) { this.changingThisBreaksApplicationSecurity = t } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)` } } class yi extends _i { getTypeName() { return "HTML" } } class bi extends _i { getTypeName() { return "Style" } } class vi extends _i { getTypeName() { return "Script" } } class wi extends _i { getTypeName() { return "URL" } } class Ci extends _i { getTypeName() { return "ResourceURL" } } function ki(t) { return t instanceof _i ? t.changingThisBreaksApplicationSecurity : t } function xi(t, e) { const n = Si(t); if (null != n && n !== e) { if ("ResourceURL" === n && "URL" === e) return !0; throw new Error(`Required a safe ${e}, got a ${n} (see https://g.co/ng/security#xss)`) } return n === e } function Si(t) { return t instanceof _i && t.getTypeName() || null } class Ei { constructor(t) { this.inertDocumentHelper = t } getInertBodyElement(t) { t = "<body><remove></remove>" + t; try { const e = (new window.DOMParser).parseFromString(gi(t), "text/html").body; return null === e ? this.inertDocumentHelper.getInertBodyElement(t) : (e.removeChild(e.firstChild), e) } catch (e) { return null } } } class Ti { constructor(t) { if (this.defaultDoc = t, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"), null == this.inertDocument.body) { const t = this.inertDocument.createElement("html"); this.inertDocument.appendChild(t); const e = this.inertDocument.createElement("body"); t.appendChild(e) } } getInertBodyElement(t) { const e = this.inertDocument.createElement("template"); if ("content" in e) return e.innerHTML = gi(t), e; const n = this.inertDocument.createElement("body"); return n.innerHTML = gi(t), this.defaultDoc.documentMode && this.stripCustomNsAttrs(n), n } stripCustomNsAttrs(t) { const e = t.attributes; for (let i = e.length - 1; 0 < i; i--) { const n = e.item(i).name; "xmlns:ns1" !== n && 0 !== n.indexOf("ns1:") || t.removeAttribute(n) } let n = t.firstChild; for (; n;)n.nodeType === Node.ELEMENT_NODE && this.stripCustomNsAttrs(n), n = n.nextSibling } } const Ri = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi, Ai = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i; function Oi(t) { return (t = String(t)).match(Ri) || t.match(Ai) ? t : "unsafe:" + t } function Ii(t) { const e = {}; for (const n of t.split(",")) e[n] = !0; return e } function Di(...t) { const e = {}; for (const n of t) for (const t in n) n.hasOwnProperty(t) && (e[t] = !0); return e } const Pi = Ii("area,br,col,hr,img,wbr"), Mi = Ii("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), Ni = Ii("rp,rt"), Fi = Di(Ni, Mi), Li = Di(Pi, Di(Mi, Ii("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), Di(Ni, Ii("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), Fi), Vi = Ii("background,cite,href,itemtype,longdesc,poster,src,xlink:href"), ji = Ii("srcset"), Bi = Di(Vi, ji, Ii("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"), Ii("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")), Hi = Ii("script,style,template"); class Ui { constructor() { this.sanitizedSomething = !1, this.buf = [] } sanitizeChildren(t) { let e = t.firstChild, n = !0; for (; e;)if (e.nodeType === Node.ELEMENT_NODE ? n = this.startElement(e) : e.nodeType === Node.TEXT_NODE ? this.chars(e.nodeValue) : this.sanitizedSomething = !0, n && e.firstChild) e = e.firstChild; else for (; e;) { e.nodeType === Node.ELEMENT_NODE && this.endElement(e); let t = this.checkClobberedElement(e, e.nextSibling); if (t) { e = t; break } e = this.checkClobberedElement(e, e.parentNode) } return this.buf.join("") } startElement(t) { const e = t.nodeName.toLowerCase(); if (!Li.hasOwnProperty(e)) return this.sanitizedSomething = !0, !Hi.hasOwnProperty(e); this.buf.push("<"), this.buf.push(e); const n = t.attributes; for (let s = 0; s < n.length; s++) { const t = n.item(s), e = t.name, r = e.toLowerCase(); if (!Bi.hasOwnProperty(r)) { this.sanitizedSomething = !0; continue } let o = t.value; Vi[r] && (o = Oi(o)), ji[r] && (i = o, o = (i = String(i)).split(",").map(t => Oi(t.trim())).join(", ")), this.buf.push(" ", e, '="', qi(o), '"') } var i; return this.buf.push(">"), !0 } endElement(t) { const e = t.nodeName.toLowerCase(); Li.hasOwnProperty(e) && !Pi.hasOwnProperty(e) && (this.buf.push("</"), this.buf.push(e), this.buf.push(">")) } chars(t) { this.buf.push(qi(t)) } checkClobberedElement(t, e) { if (e && (t.compareDocumentPosition(e) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error(`Failed to sanitize html because the element is clobbered: ${t.outerHTML}`); return e } } const zi = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, $i = /([^\#-~ |!])/g; function qi(t) { return t.replace(/&/g, "&amp;").replace(zi, function (t) { return "&#" + (1024 * (t.charCodeAt(0) - 55296) + (t.charCodeAt(1) - 56320) + 65536) + ";" }).replace($i, function (t) { return "&#" + t.charCodeAt(0) + ";" }).replace(/</g, "&lt;").replace(/>/g, "&gt;") } let Wi; function Ki(t) { return "content" in t && function (t) { return t.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === t.nodeName }(t) ? t.content : null } var Yi = function (t) { return t[t.NONE = 0] = "NONE", t[t.HTML = 1] = "HTML", t[t.STYLE = 2] = "STYLE", t[t.SCRIPT = 3] = "SCRIPT", t[t.URL = 4] = "URL", t[t.RESOURCE_URL = 5] = "RESOURCE_URL", t }({}); function Zi(t) { const e = function () { const t = Ae(); return t && t[12] }(); return e ? e.sanitize(Yi.URL, t) || "" : xi(t, "URL") ? ki(t) : Oi(ct(t)) } function Gi(t, e) { t.__ngContext__ = e } function Qi(t) { const e = function (t) { return t.__ngContext__ || null }(t); return e ? Array.isArray(e) ? e : e.lView : null } function Xi(t) { return t.ngDebugContext } function Ji(t) { return t.ngOriginalError } function ts(t, ...e) { t.error(...e) } class es { constructor() { this._console = console } handleError(t) { const e = this._findOriginalError(t), n = this._findContext(t), i = function (t) { return t.ngErrorLogger || ts }(t); i(this._console, "ERROR", t), e && i(this._console, "ORIGINAL ERROR", e), n && i(this._console, "ERROR CONTEXT", n) } _findContext(t) { return t ? Xi(t) ? Xi(t) : this._findContext(Ji(t)) : null } _findOriginalError(t) { let e = Ji(t); for (; e && Ji(e);)e = Ji(e); return e } } const ns = (() => ("undefined" != typeof requestAnimationFrame && requestAnimationFrame || setTimeout).bind(Dt))(); function is(t) { return t instanceof Function ? t() : t } var ss = function (t) { return t[t.Important = 1] = "Important", t[t.DashCase = 2] = "DashCase", t }({}); function rs(t, e) { return (void 0)(t, e) } function os(t) { const e = t[3]; return ee(e) ? e[3] : e } function as(t) { return cs(t[13]) } function ls(t) { return cs(t[4]) } function cs(t) { for (; null !== t && !ee(t);)t = t[4]; return t } function hs(t, e, n, i, s) { if (null != i) { let r, o = !1; ee(i) ? r = i : te(i) && (o = !0, i = i[0]); const a = _e(i); 0 === t && null !== n ? null == s ? ys(e, n, a) : _s(e, n, a, s || null, !0) : 1 === t && null !== n ? _s(e, n, a, s || null, !0) : 2 === t ? function (t, e, n) { const i = vs(t, e); i && function (t, e, n, i) { me(t) ? t.removeChild(e, n, i) : e.removeChild(n) }(t, i, e, n) }(e, a, o) : 3 === t && e.destroyNode(a), null != r && function (t, e, n, i, s) { const r = n[7]; r !== _e(n) && hs(e, t, i, r, s); for (let o = Jt; o < n.length; o++) { const s = n[o]; Rs(s[1], s, t, e, i, r) } }(e, t, r, n, s) } } function us(t, e, n) { return me(t) ? t.createElement(e, n) : null === n ? t.createElement(e) : t.createElementNS(n, e) } function ds(t, e) { const n = t[9], i = n.indexOf(e), s = e[3]; 1024 & e[2] && (e[2] &= -1025, Ee(s, -1)), n.splice(i, 1) } function ps(t, e) { if (t.length <= Jt) return; const n = Jt + e, i = t[n]; if (i) { const r = i[17]; null !== r && r !== t && ds(r, i), e > 0 && (t[n - 1][4] = i[4]); const o = Gn(t, Jt + e); Rs(i[1], s = i, s[11], 2, null, null), s[0] = null, s[6] = null; const a = o[19]; null !== a && a.detachView(o[1]), i[3] = null, i[4] = null, i[2] &= -129 } var s; return i } function fs(t, e) { if (!(256 & e[2])) { const n = e[11]; me(n) && n.destroyNode && Rs(t, e, n, 3, null, null), function (t) { let e = t[13]; if (!e) return ms(t[1], t); for (; e;) { let n = null; if (te(e)) n = e[13]; else { const t = e[10]; t && (n = t) } if (!n) { for (; e && !e[4] && e !== t;)te(e) && ms(e[1], e), e = e[3]; null === e && (e = t), te(e) && ms(e[1], e), n = e && e[4] } e = n } }(e) } } function ms(t, e) { if (!(256 & e[2])) { e[2] &= -129, e[2] |= 256, function (t, e) { let n; if (null != t && null != (n = t.destroyHooks)) for (let i = 0; i < n.length; i += 2) { const t = e[n[i]]; if (!(t instanceof un)) { const e = n[i + 1]; if (Array.isArray(e)) for (let n = 0; n < e.length; n += 2) { const i = t[e[n]], s = e[n + 1]; try { s.call(i) } finally { } } else try { e.call(t) } finally { } } } }(t, e), function (t, e) { const n = t.cleanup, i = e[7]; let s = -1; if (null !== n) for (let r = 0; r < n.length - 1; r += 2)if ("string" == typeof n[r]) { const t = n[r + 1], o = "function" == typeof t ? t(e) : _e(e[t]), a = i[s = n[r + 2]], l = n[r + 3]; "boolean" == typeof l ? o.removeEventListener(n[r], a, l) : l >= 0 ? i[s = l]() : i[s = -l].unsubscribe(), r += 2 } else { const t = i[s = n[r + 1]]; n[r].call(t) } if (null !== i) { for (let t = s + 1; t < i.length; t++)(0, i[t])(); e[7] = null } }(t, e), 1 === e[1].type && me(e[11]) && e[11].destroy(); const n = e[17]; if (null !== n && ee(e[3])) { n !== e[3] && ds(n, e); const i = e[19]; null !== i && i.detachView(t) } } } function gs(t, e, n) { return function (t, e, n) { let i = e; for (; null !== i && 40 & i.type;)i = (e = i).parent; if (null === i) return n[0]; if (2 & i.flags) { const e = t.data[i.directiveStart].encapsulation; if (e === Tt.None || e === Tt.Emulated) return null } return be(i, n) }(t, e.parent, n) } function _s(t, e, n, i, s) { me(t) ? t.insertBefore(e, n, i, s) : e.insertBefore(n, i, s) } function ys(t, e, n) { me(t) ? t.appendChild(e, n) : e.appendChild(n) } function bs(t, e, n, i, s) { null !== i ? _s(t, e, n, i, s) : ys(t, e, n) } function vs(t, e) { return me(t) ? t.parentNode(e) : e.parentNode } function ws(t, e, n) { return Cs(t, e, n) } let Cs = function (t, e, n) { return 40 & t.type ? be(t, n) : null }; function ks(t, e, n, i) { const s = gs(t, i, e), r = e[11], o = ws(i.parent || e[6], i, e); if (null != s) if (Array.isArray(n)) for (let a = 0; a < n.length; a++)bs(r, s, n[a], o, !1); else bs(r, s, n, o, !1) } function xs(t, e) { if (null !== e) { const n = e.type; if (3 & n) return be(e, t); if (4 & n) return Es(-1, t[e.index]); if (8 & n) { const n = e.child; if (null !== n) return xs(t, n); { const n = t[e.index]; return ee(n) ? Es(-1, n) : _e(n) } } if (32 & n) return rs(e, t)() || _e(t[e.index]); { const n = Ss(t, e); return null !== n ? Array.isArray(n) ? n[0] : xs(os(t[16]), n) : xs(t, e.next) } } return null } function Ss(t, e) { return null !== e ? t[16][6].projection[e.projection] : null } function Es(t, e) { const n = Jt + t + 1; if (n < e.length) { const t = e[n], i = t[1].firstChild; if (null !== i) return xs(t, i) } return e[7] } function Ts(t, e, n, i, s, r, o) { for (; null != n;) { const a = i[n.index], l = n.type; if (o && 0 === e && (a && Gi(_e(a), i), n.flags |= 4), 64 != (64 & n.flags)) if (8 & l) Ts(t, e, n.child, i, s, r, !1), hs(e, t, s, a, r); else if (32 & l) { const o = rs(n, i); let l; for (; l = o();)hs(e, t, s, l, r); hs(e, t, s, a, r) } else 16 & l ? As(t, e, i, n, s, r) : hs(e, t, s, a, r); n = o ? n.projectionNext : n.next } } function Rs(t, e, n, i, s, r) { Ts(n, i, t.firstChild, e, s, r, !1) } function As(t, e, n, i, s, r) { const o = n[16], a = o[6].projection[i.projection]; if (Array.isArray(a)) for (let l = 0; l < a.length; l++)hs(e, t, s, a[l], r); else Ts(t, e, a, o[3], s, r, !0) } function Os(t, e, n) { me(t) ? t.setAttribute(e, "style", n) : e.style.cssText = n } function Is(t, e, n) { me(t) ? "" === n ? t.removeAttribute(e, "class") : t.setAttribute(e, "class", n) : e.className = n } function Ds(t, e, n) { let i = t.length; for (; ;) { const s = t.indexOf(e, n); if (-1 === s) return s; if (0 === s || t.charCodeAt(s - 1) <= 32) { const n = e.length; if (s + n === i || t.charCodeAt(s + n) <= 32) return s } n = s + 1 } } const Ps = "ng-template"; function Ms(t, e, n) { let i = 0; for (; i < t.length;) { let s = t[i++]; if (n && "class" === s) { if (s = t[i], -1 !== Ds(s.toLowerCase(), e, 0)) return !0 } else if (1 === s) { for (; i < t.length && "string" == typeof (s = t[i++]);)if (s.toLowerCase() === e) return !0; return !1 } } return !1 } function Ns(t) { return 4 === t.type && t.value !== Ps } function Fs(t, e, n) { return e === (4 !== t.type || n ? t.value : Ps) } function Ls(t, e, n) { let i = 4; const s = t.attrs || [], r = function (t) { for (let e = 0; e < t.length; e++)if (pn(t[e])) return e; return t.length }(s); let o = !1; for (let a = 0; a < e.length; a++) { const l = e[a]; if ("number" != typeof l) { if (!o) if (4 & i) { if (i = 2 | 1 & i, "" !== l && !Fs(t, l, n) || "" === l && 1 === e.length) { if (Vs(i)) return !1; o = !0 } } else { const c = 8 & i ? l : e[++a]; if (8 & i && null !== t.attrs) { if (!Ms(t.attrs, c, n)) { if (Vs(i)) return !1; o = !0 } continue } const h = js(8 & i ? "class" : l, s, Ns(t), n); if (-1 === h) { if (Vs(i)) return !1; o = !0; continue } if ("" !== c) { let t; t = h > r ? "" : s[h + 1].toLowerCase(); const e = 8 & i ? t : null; if (e && -1 !== Ds(e, c, 0) || 2 & i && c !== t) { if (Vs(i)) return !1; o = !0 } } } } else { if (!o && !Vs(i) && !Vs(l)) return !1; if (o && Vs(l)) continue; o = !1, i = l | 1 & i } } return Vs(i) || o } function Vs(t) { return 0 == (1 & t) } function js(t, e, n, i) { if (null === e) return -1; let s = 0; if (i || !n) { let n = !1; for (; s < e.length;) { const i = e[s]; if (i === t) return s; if (3 === i || 6 === i) n = !0; else { if (1 === i || 2 === i) { let t = e[++s]; for (; "string" == typeof t;)t = e[++s]; continue } if (4 === i) break; if (0 === i) { s += 4; continue } } s += n ? 1 : 2 } return -1 } return function (t, e) { let n = t.indexOf(4); if (n > -1) for (n++; n < t.length;) { const i = t[n]; if ("number" == typeof i) return -1; if (i === e) return n; n++ } return -1 }(e, t) } function Bs(t, e, n = !1) { for (let i = 0; i < e.length; i++)if (Ls(t, e[i], n)) return !0; return !1 } function Hs(t, e) { t: for (let n = 0; n < e.length; n++) { const i = e[n]; if (t.length === i.length) { for (let e = 0; e < t.length; e++)if (t[e] !== i[e]) continue t; return !0 } } return !1 } function Us(t, e) { return t ? ":not(" + e.trim() + ")" : e } function zs(t) { let e = t[0], n = 1, i = 2, s = "", r = !1; for (; n < t.length;) { let o = t[n]; if ("string" == typeof o) if (2 & i) { const e = t[++n]; s += "[" + o + (e.length > 0 ? '="' + e + '"' : "") + "]" } else 8 & i ? s += "." + o : 4 & i && (s += " " + o); else "" === s || Vs(o) || (e += Us(r, s), s = ""), i = o, r = r || !Vs(i); n++ } return "" !== s && (e += Us(r, s)), e } const $s = {}; function qs(t) { Ws(Oe(), Ae(), tn() + t, Le()) } function Ws(t, e, n, i) { if (!i) if (3 == (3 & e[2])) { const i = t.preOrderCheckHooks; null !== i && rn(e, i, n) } else { const i = t.preOrderHooks; null !== i && on(e, i, 0, n) } en(n) } function Ks(t, e) { return t << 17 | e << 2 } function Ys(t) { return t >> 17 & 32767 } function Zs(t) { return 2 | t } function Gs(t) { return (131068 & t) >> 2 } function Qs(t, e) { return -131069 & t | e << 2 } function Xs(t) { return 1 | t } function Js(t, e) { const n = t.contentQueries; if (null !== n) for (let i = 0; i < n.length; i += 2) { const s = n[i], r = n[i + 1]; if (-1 !== r) { const n = t.data[r]; qe(s), n.contentQueries(2, e[r], r) } } } function tr(t, e, n, i, s, r, o, a, l, c) { const h = e.blueprint.slice(); return h[0] = s, h[2] = 140 | i, Se(h), h[3] = h[15] = t, h[8] = n, h[10] = o || t && t[10], h[11] = a || t && t[11], h[12] = l || t && t[12] || null, h[9] = c || t && t[9] || null, h[6] = r, h[16] = 2 == e.type ? t[16] : h, h } function er(t, e, n, i, s) { let r = t.data[e]; if (null === r) r = function (t, e, n, i, s) { const r = Pe(), o = Ne(), a = t.data[e] = function (t, e, n, i, s, r) { return { type: n, index: i, insertBeforeIndex: null, injectorIndex: e ? e.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, propertyBindings: null, flags: 0, providerIndexes: 0, value: s, attrs: r, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tViews: null, next: null, projectionNext: null, child: null, parent: e, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, o ? r : r && r.parent, n, e, i, s); return null === t.firstChild && (t.firstChild = a), null !== r && (o ? null == r.child && null !== a.parent && (r.child = a) : null === r.next && (r.next = a)), a }(t, e, n, i, s), Te.lFrame.inI18n && (r.flags |= 64); else if (64 & r.type) { r.type = n, r.value = i, r.attrs = s; const t = function () { const t = Te.lFrame, e = t.currentTNode; return t.isParent ? e : e.parent }(); r.injectorIndex = null === t ? -1 : t.injectorIndex } return Me(r, !0), r } function nr(t, e, n, i) { if (0 === n) return -1; const s = e.length; for (let r = 0; r < n; r++)e.push(i), t.blueprint.push(i), t.data.push(null); return s } function ir(t, e, n) { Ye(e); try { const i = t.viewQuery; null !== i && Pr(1, i, n); const s = t.template; null !== s && or(t, e, s, 1, n), t.firstCreatePass && (t.firstCreatePass = !1), t.staticContentQueries && Js(t, e), t.staticViewQueries && Pr(2, t.viewQuery, n); const r = t.components; null !== r && function (t, e) { for (let n = 0; n < e.length; n++)Rr(t, e[n]) }(e, r) } catch (i) { throw t.firstCreatePass && (t.incompleteFirstPass = !0), i } finally { e[2] &= -5, Je() } } function sr(t, e, n, i) { const s = e[2]; if (256 == (256 & s)) return; Ye(e); const r = Le(); try { Se(e), Te.lFrame.bindingIndex = t.bindingStartIndex, null !== n && or(t, e, n, 2, i); const o = 3 == (3 & s); if (!r) if (o) { const n = t.preOrderCheckHooks; null !== n && rn(e, n, null) } else { const n = t.preOrderHooks; null !== n && on(e, n, 0, null), an(e, 0) } if (function (t) { for (let e = as(t); null !== e; e = ls(e)) { if (!e[2]) continue; const t = e[9]; for (let e = 0; e < t.length; e++) { const n = t[e], i = n[3]; 0 == (1024 & n[2]) && Ee(i, 1), n[2] |= 1024 } } }(e), function (t) { for (let e = as(t); null !== e; e = ls(e))for (let t = Jt; t < e.length; t++) { const n = e[t], i = n[1]; ke(n) && sr(i, n, i.template, n[8]) } }(e), null !== t.contentQueries && Js(t, e), !r) if (o) { const n = t.contentCheckHooks; null !== n && rn(e, n) } else { const n = t.contentHooks; null !== n && on(e, n, 1), an(e, 1) } !function (t, e) { const n = t.hostBindingOpCodes; if (null !== n) try { for (let t = 0; t < n.length; t++) { const i = n[t]; if (i < 0) en(~i); else { const s = i, r = n[++t], o = n[++t]; He(r, s), o(2, e[s]) } } } finally { en(-1) } }(t, e); const a = t.components; null !== a && function (t, e) { for (let n = 0; n < e.length; n++)Er(t, e[n]) }(e, a); const l = t.viewQuery; if (null !== l && Pr(2, l, i), !r) if (o) { const n = t.viewCheckHooks; null !== n && rn(e, n) } else { const n = t.viewHooks; null !== n && on(e, n, 2), an(e, 2) } !0 === t.firstUpdatePass && (t.firstUpdatePass = !1), r || (e[2] &= -73), 1024 & e[2] && (e[2] &= -1025, Ee(e[3], -1)) } finally { Je() } } function rr(t, e, n, i) { const s = e[10], r = !Le(), o = Ce(e); try { r && !o && s.begin && s.begin(), o && ir(t, e, i), sr(t, e, n, i) } finally { r && !o && s.end && s.end() } } function or(t, e, n, i, s) { const r = tn(), o = 2 & i; try { en(-1), o && e.length > Xt && Ws(t, e, Xt, Le()), n(i, s) } finally { en(r) } } function ar(t, e, n) { if (ne(e)) { const i = e.directiveEnd; for (let s = e.directiveStart; s < i; s++) { const e = t.data[s]; e.contentQueries && e.contentQueries(1, n[s], s) } } } function lr(t, e, n) { Re() && (function (t, e, n, i) { const s = n.directiveStart, r = n.directiveEnd; t.firstCreatePass || kn(n, e), Gi(i, e); const o = n.initialInputs; for (let a = s; a < r; a++) { const i = t.data[a], r = re(i); r && Cr(e, n, i); const l = Nn(e, t, a, n); Gi(l, e), null !== o && kr(0, a - s, l, i, 0, o), r && (we(n.index, e)[8] = l) } }(t, e, n, be(n, e)), 128 == (128 & n.flags) && function (t, e, n) { const i = n.directiveStart, s = n.directiveEnd, r = n.index, o = Te.lFrame.currentDirectiveIndex; try { en(r); for (let n = i; n < s; n++) { const i = t.data[n], s = e[n]; Ue(n), null === i.hostBindings && 0 === i.hostVars && null === i.hostAttrs || _r(i, s) } } finally { en(-1), Ue(o) } }(t, e, n)) } function cr(t, e, n = be) { const i = e.localNames; if (null !== i) { let s = e.index + 1; for (let r = 0; r < i.length; r += 2) { const o = i[r + 1], a = -1 === o ? n(e, t) : t[o]; t[s++] = a } } } function hr(t) { const e = t.tView; return null === e || e.incompleteFirstPass ? t.tView = ur(1, null, t.template, t.decls, t.vars, t.directiveDefs, t.pipeDefs, t.viewQuery, t.schemas, t.consts) : e } function ur(t, e, n, i, s, r, o, a, l, c) { const h = Xt + i, u = h + s, d = function (t, e) { const n = []; for (let i = 0; i < e; i++)n.push(i < t ? null : $s); return n }(h, u), p = "function" == typeof c ? c() : c; return d[1] = { type: t, blueprint: d, template: n, queries: null, viewQuery: a, declTNode: e, data: d.slice().fill(null, h), bindingStartIndex: h, expandoStartIndex: u, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof r ? r() : r, pipeRegistry: "function" == typeof o ? o() : o, firstChild: null, schemas: l, consts: p, incompleteFirstPass: !1 } } function dr(t, e, n, i) { const s = Nr(e); null === n ? s.push(i) : (s.push(n), t.firstCreatePass && Fr(t).push(i, s.length - 1)) } function pr(t, e, n) { for (let i in t) if (t.hasOwnProperty(i)) { const s = t[i]; (n = null === n ? {} : n).hasOwnProperty(i) ? n[i].push(e, s) : n[i] = [e, s] } return n } function fr(t, e, n, i, s, r, o, a) { const l = be(e, n); let c, h = e.inputs; var u; !a && null != h && (c = h[i]) ? (jr(t, n, c, i, s), ie(e) && function (t, e) { const n = we(e, t); 16 & n[2] || (n[2] |= 64) }(n, e.index)) : 3 & e.type && (i = "class" === (u = i) ? "className" : "for" === u ? "htmlFor" : "formaction" === u ? "formAction" : "innerHtml" === u ? "innerHTML" : "readonly" === u ? "readOnly" : "tabindex" === u ? "tabIndex" : u, s = null != o ? o(s, e.value || "", i) : s, me(r) ? r.setProperty(l, i, s) : fn(i) || (l.setProperty ? l.setProperty(i, s) : l[i] = s)) } function mr(t, e, n, i) { let s = !1; if (Re()) { const r = function (t, e, n) { const i = t.directiveRegistry; let s = null; if (i) for (let r = 0; r < i.length; r++) { const o = i[r]; Bs(n, o.selectors, !1) && (s || (s = []), Tn(kn(n, e), t, o.type), re(o) ? (yr(t, n), s.unshift(o)) : s.push(o)) } return s }(t, e, n), o = null === i ? null : { "": -1 }; if (null !== r) { s = !0, vr(n, t.data.length, r.length); for (let t = 0; t < r.length; t++) { const e = r[t]; e.providersResolver && e.providersResolver(e) } let i = !1, a = !1, l = nr(t, e, r.length, null); for (let s = 0; s < r.length; s++) { const c = r[s]; n.mergedAttrs = mn(n.mergedAttrs, c.hostAttrs), wr(t, n, e, l, c), br(l, c, o), null !== c.contentQueries && (n.flags |= 8), null === c.hostBindings && null === c.hostAttrs && 0 === c.hostVars || (n.flags |= 128); const h = c.type.prototype; !i && (h.ngOnChanges || h.ngOnInit || h.ngDoCheck) && ((t.preOrderHooks || (t.preOrderHooks = [])).push(n.index), i = !0), a || !h.ngOnChanges && !h.ngDoCheck || ((t.preOrderCheckHooks || (t.preOrderCheckHooks = [])).push(n.index), a = !0), l++ } !function (t, e) { const n = e.directiveEnd, i = t.data, s = e.attrs, r = []; let o = null, a = null; for (let l = e.directiveStart; l < n; l++) { const t = i[l], n = t.inputs, c = null === s || Ns(e) ? null : xr(n, s); r.push(c), o = pr(n, l, o), a = pr(t.outputs, l, a) } null !== o && (o.hasOwnProperty("class") && (e.flags |= 16), o.hasOwnProperty("style") && (e.flags |= 32)), e.initialInputs = r, e.inputs = o, e.outputs = a }(t, n) } o && function (t, e, n) { if (e) { const i = t.localNames = []; for (let t = 0; t < e.length; t += 2) { const s = n[e[t + 1]]; if (null == s) throw new lt("301", `Export of name '${e[t + 1]}' not found!`); i.push(e[t], s) } } }(n, i, o) } return n.mergedAttrs = mn(n.mergedAttrs, n.attrs), s } function gr(t, e, n, i, s, r) { const o = r.hostBindings; if (o) { let n = t.hostBindingOpCodes; null === n && (n = t.hostBindingOpCodes = []); const r = ~e.index; (function (t) { let e = t.length; for (; e > 0;) { const n = t[--e]; if ("number" == typeof n && n < 0) return n } return 0 })(n) != r && n.push(r), n.push(i, s, o) } } function _r(t, e) { null !== t.hostBindings && t.hostBindings(1, e) } function yr(t, e) { e.flags |= 2, (t.components || (t.components = [])).push(e.index) } function br(t, e, n) { if (n) { if (e.exportAs) for (let i = 0; i < e.exportAs.length; i++)n[e.exportAs[i]] = t; re(e) && (n[""] = t) } } function vr(t, e, n) { t.flags |= 1, t.directiveStart = e, t.directiveEnd = e + n, t.providerIndexes = e } function wr(t, e, n, i, s) { t.data[i] = s; const r = s.factory || (s.factory = oe(s.type)), o = new un(r, re(s), null); t.blueprint[i] = o, n[i] = o, gr(t, e, 0, i, nr(t, n, s.hostVars, $s), s) } function Cr(t, e, n) { const i = be(e, t), s = hr(n), r = t[10], o = Ar(t, tr(t, s, null, n.onPush ? 64 : 16, i, e, r, r.createRenderer(i, n), null, null)); t[e.index] = o } function kr(t, e, n, i, s, r) { const o = r[e]; if (null !== o) { const t = i.setInput; for (let e = 0; e < o.length;) { const s = o[e++], r = o[e++], a = o[e++]; null !== t ? i.setInput(n, a, s, r) : n[r] = a } } } function xr(t, e) { let n = null, i = 0; for (; i < e.length;) { const s = e[i]; if (0 !== s) if (5 !== s) { if ("number" == typeof s) break; t.hasOwnProperty(s) && (null === n && (n = []), n.push(s, t[s], e[i + 1])), i += 2 } else i += 2; else i += 4 } return n } function Sr(t, e, n, i) { return new Array(t, !0, !1, e, null, 0, i, n, null, null) } function Er(t, e) { const n = we(e, t); if (ke(n)) { const t = n[1]; 80 & n[2] ? sr(t, n, t.template, n[8]) : n[5] > 0 && Tr(n) } } function Tr(t) { for (let n = as(t); null !== n; n = ls(n))for (let t = Jt; t < n.length; t++) { const e = n[t]; if (1024 & e[2]) { const t = e[1]; sr(t, e, t.template, e[8]) } else e[5] > 0 && Tr(e) } const e = t[1].components; if (null !== e) for (let n = 0; n < e.length; n++) { const i = we(e[n], t); ke(i) && i[5] > 0 && Tr(i) } } function Rr(t, e) { const n = we(e, t), i = n[1]; !function (t, e) { for (let n = e.length; n < t.blueprint.length; n++)e.push(t.blueprint[n]) }(i, n), ir(i, n, n[8]) } function Ar(t, e) { return t[13] ? t[14][4] = e : t[13] = e, t[14] = e, e } function Or(t) { for (; t;) { t[2] |= 64; const e = os(t); if (0 != (512 & t[2]) && !e) return t; t = e } return null } function Ir(t, e, n) { const i = e[10]; i.begin && i.begin(); try { sr(t, e, t.template, n) } catch (s) { throw Vr(e, s), s } finally { i.end && i.end() } } function Dr(t) { !function (t) { for (let e = 0; e < t.components.length; e++) { const n = t.components[e], i = Qi(n), s = i[1]; rr(s, i, s.template, n) } }(t[8]) } function Pr(t, e, n) { qe(0), e(t, n) } const Mr = (() => Promise.resolve(null))(); function Nr(t) { return t[7] || (t[7] = []) } function Fr(t) { return t.cleanup || (t.cleanup = []) } function Lr(t, e, n) { return (null === t || re(t)) && (n = function (t) { for (; Array.isArray(t);) { if ("object" == typeof t[1]) return t; t = t[0] } return null }(n[e.index])), n[11] } function Vr(t, e) { const n = t[9], i = n ? n.get(es, null) : null; i && i.handleError(e) } function jr(t, e, n, i, s) { for (let r = 0; r < n.length;) { const o = n[r++], a = n[r++], l = e[o], c = t.data[o]; null !== c.setInput ? c.setInput(l, s, i, a) : l[a] = s } } function Br(t, e, n) { let i = n ? t.styles : null, s = n ? t.classes : null, r = 0; if (null !== e) for (let o = 0; o < e.length; o++) { const t = e[o]; "number" == typeof t ? r = t : 1 == r ? s = it(s, t) : 2 == r && (i = it(i, t + ": " + e[++o] + ";")) } n ? t.styles = i : t.stylesWithoutHost = i, n ? t.classes = s : t.classesWithoutHost = s } const Hr = new $n("INJECTOR", -1); class Ur { get(t, e = ei) { if (e === ei) { const e = new Error(`NullInjectorError: No provider for ${nt(t)}!`); throw e.name = "NullInjectorError", e } return e } } const zr = new $n("Set Injector scope."), $r = {}, qr = {}; let Wr; function Kr() { return void 0 === Wr && (Wr = new Ur), Wr } function Yr(t, e = null, n = null, i) { return new Zr(t, n, e || Kr(), i) } class Zr { constructor(t, e, n, i = null) { this.parent = n, this.records = new Map, this.injectorDefTypes = new Set, this.onDestroy = new Set, this._destroyed = !1; const s = []; e && Yn(e, n => this.processProvider(n, t, e)), Yn([t], t => this.processInjectorType(t, [], s)), this.records.set(Hr, Xr(void 0, this)); const r = this.records.get(zr); this.scope = null != r ? r.value : null, this.source = i || ("object" == typeof t ? null : nt(t)) } get destroyed() { return this._destroyed } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { this.onDestroy.forEach(t => t.ngOnDestroy()) } finally { this.records.clear(), this.onDestroy.clear(), this.injectorDefTypes.clear() } } get(t, e = ei, n = wt.Default) { this.assertNotDestroyed(); const i = oi(this); try { if (!(n & wt.SkipSelf)) { let e = this.records.get(t); if (void 0 === e) { const n = ("function" == typeof (s = t) || "object" == typeof s && s instanceof $n) && ft(t); e = n && this.injectableDefInScope(n) ? Xr(Gr(t), $r) : null, this.records.set(t, e) } if (null != e) return this.hydrate(t, e) } return (n & wt.Self ? Kr() : this.parent).get(t, e = n & wt.Optional && e === ei ? null : e) } catch (r) { if ("NullInjectorError" === r.name) { if ((r.ngTempTokenPath = r.ngTempTokenPath || []).unshift(nt(t)), i) throw r; return function (t, e, n, i) { const s = t.ngTempTokenPath; throw e[ii] && s.unshift(e[ii]), t.message = function (t, e, n, i = null) { t = t && "\n" === t.charAt(0) && "\u0275" == t.charAt(1) ? t.substr(2) : t; let s = nt(e); if (Array.isArray(e)) s = e.map(nt).join(" -> "); else if ("object" == typeof e) { let t = []; for (let n in e) if (e.hasOwnProperty(n)) { let i = e[n]; t.push(n + ":" + ("string" == typeof i ? JSON.stringify(i) : nt(i))) } s = `{${t.join(", ")}}` } return `${n}${i ? "(" + i + ")" : ""}[${s}]: ${t.replace(ni, "\n  ")}` }("\n" + t.message, s, n, i), t.ngTokenPath = s, t.ngTempTokenPath = null, t }(r, t, "R3InjectorError", this.source) } throw r } finally { oi(i) } var s } _resolveInjectorDefTypes() { this.injectorDefTypes.forEach(t => this.get(t)) } toString() { const t = []; return this.records.forEach((e, n) => t.push(nt(n))), `R3Injector[${t.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new Error("Injector has already been destroyed.") } processInjectorType(t, e, n) { if (!(t = ot(t))) return !1; let i = gt(t); const s = null == i && t.ngModule || void 0, r = void 0 === s ? t : s, o = -1 !== n.indexOf(r); if (void 0 !== s && (i = gt(s)), null == i) return !1; if (null != i.imports && !o) { let t; n.push(r); try { Yn(i.imports, i => { this.processInjectorType(i, e, n) && (void 0 === t && (t = []), t.push(i)) }) } finally { } if (void 0 !== t) for (let e = 0; e < t.length; e++) { const { ngModule: n, providers: i } = t[e]; Yn(i, t => this.processProvider(t, n, i || Mt)) } } this.injectorDefTypes.add(r); const a = oe(r) || (() => new r); this.records.set(r, Xr(a, $r)); const l = i.providers; if (null != l && !o) { const e = t; Yn(l, t => this.processProvider(t, e, l)) } return void 0 !== s && void 0 !== t.providers } processProvider(t, e, n) { let i = to(t = ot(t)) ? t : ot(t && t.provide); const s = function (t, e, n) { return Jr(t) ? Xr(void 0, t.useValue) : Xr(Qr(t), $r) }(t); if (to(t) || !0 !== t.multi) this.records.get(i); else { let e = this.records.get(i); e || (e = Xr(void 0, $r, !0), e.factory = () => hi(e.multi), this.records.set(i, e)), i = t, e.multi.push(t) } this.records.set(i, s) } hydrate(t, e) { var n; return e.value === $r && (e.value = qr, e.value = e.factory()), "object" == typeof e.value && e.value && null !== (n = e.value) && "object" == typeof n && "function" == typeof n.ngOnDestroy && this.onDestroy.add(e.value), e.value } injectableDefInScope(t) { if (!t.providedIn) return !1; const e = ot(t.providedIn); return "string" == typeof e ? "any" === e || e === this.scope : this.injectorDefTypes.has(e) } } function Gr(t) { const e = ft(t), n = null !== e ? e.factory : oe(t); if (null !== n) return n; if (t instanceof $n) throw new Error(`Token ${nt(t)} is missing a \u0275prov definition.`); if (t instanceof Function) return function (t) { const e = t.length; if (e > 0) { const n = Qn(e, "?"); throw new Error(`Can't resolve all parameters for ${nt(t)}: (${n.join(", ")}).`) } const n = function (t) { const e = t && (t[_t] || t[bt]); if (e) { const n = function (t) { if (t.hasOwnProperty("name")) return t.name; const e = ("" + t).match(/^function\s*([^\s(]+)/); return null === e ? "" : e[1] }(t); return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`), e } return null }(t); return null !== n ? () => n.factory(t) : () => new t }(t); throw new Error("unreachable") } function Qr(t, e, n) { let i; if (to(t)) { const e = ot(t); return oe(e) || Gr(e) } if (Jr(t)) i = () => ot(t.useValue); else if ((s = t) && s.useFactory) i = () => t.useFactory(...hi(t.deps || [])); else if (function (t) { return !(!t || !t.useExisting) }(t)) i = () => li(ot(t.useExisting)); else { const e = ot(t && (t.useClass || t.provide)); if (!function (t) { return !!t.deps }(t)) return oe(e) || Gr(e); i = () => new e(...hi(t.deps)) } var s; return i } function Xr(t, e, n = !1) { return { factory: t, value: e, multi: n ? [] : void 0 } } function Jr(t) { return null !== t && "object" == typeof t && si in t } function to(t) { return "function" == typeof t } const eo = function (t, e, n) { return function (t, e = null, n = null, i) { const s = Yr(t, e, n, i); return s._resolveInjectorDefTypes(), s }({ name: n }, e, t, n) }; let no = (() => { class t { static create(t, e) { return Array.isArray(t) ? eo(t, e, "") : eo(t.providers, t.parent, t.name || "") } } return t.THROW_IF_NOT_FOUND = ei, t.NULL = new Ur, t.\u0275prov = dt({ token: t, providedIn: "any", factory: () => li(Hr) }), t.__NG_ELEMENT_ID__ = -1, t })(); function io(t, e) { sn(Qi(t)[1], De()) } function so(t) { let e = Object.getPrototypeOf(t.type.prototype).constructor, n = !0; const i = [t]; for (; e;) { let s; if (re(t)) s = e.\u0275cmp || e.\u0275dir; else { if (e.\u0275cmp) throw new Error("Directives cannot inherit Components"); s = e.\u0275dir } if (s) { if (n) { i.push(s); const e = t; e.inputs = ro(t.inputs), e.declaredInputs = ro(t.declaredInputs), e.outputs = ro(t.outputs); const n = s.hostBindings; n && lo(t, n); const r = s.viewQuery, o = s.contentQueries; if (r && oo(t, r), o && ao(t, o), et(t.inputs, s.inputs), et(t.declaredInputs, s.declaredInputs), et(t.outputs, s.outputs), re(s) && s.data.animation) { const e = t.data; e.animation = (e.animation || []).concat(s.data.animation) } } const e = s.features; if (e) for (let i = 0; i < e.length; i++) { const s = e[i]; s && s.ngInherit && s(t), s === so && (n = !1) } } e = Object.getPrototypeOf(e) } !function (t) { let e = 0, n = null; for (let i = t.length - 1; i >= 0; i--) { const s = t[i]; s.hostVars = e += s.hostVars, s.hostAttrs = mn(s.hostAttrs, n = mn(n, s.hostAttrs)) } }(i) } function ro(t) { return t === Pt ? {} : t === Mt ? [] : t } function oo(t, e) { const n = t.viewQuery; t.viewQuery = n ? (t, i) => { e(t, i), n(t, i) } : e } function ao(t, e) { const n = t.contentQueries; t.contentQueries = n ? (t, i, s) => { e(t, i, s), n(t, i, s) } : e } function lo(t, e) { const n = t.hostBindings; t.hostBindings = n ? (t, i) => { e(t, i), n(t, i) } : e } let co = null; function ho() { if (!co) { const t = Dt.Symbol; if (t && t.iterator) co = t.iterator; else { const t = Object.getOwnPropertyNames(Map.prototype); for (let e = 0; e < t.length; ++e) { const n = t[e]; "entries" !== n && "size" !== n && Map.prototype[n] === Map.prototype.entries && (co = n) } } } return co } function uo(t) { return !!po(t) && (Array.isArray(t) || !(t instanceof Map) && ho() in t) } function po(t) { return null !== t && ("function" == typeof t || "object" == typeof t) } function fo(t, e, n) { return !Object.is(t[e], n) && (t[e] = n, !0) } function mo(t, e, n, i) { const s = Ae(); return fo(s, je(), e) && (Oe(), function (t, e, n, i, s, r) { const o = be(t, e); !function (t, e, n, i, s, r, o) { if (null == r) me(t) ? t.removeAttribute(e, s, n) : e.removeAttribute(s); else { const a = null == o ? ct(r) : o(r, i || "", s); me(t) ? t.setAttribute(e, s, a, n) : n ? e.setAttributeNS(n, s, a) : e.setAttribute(s, a) } }(e[11], o, r, t.value, n, i, s) }(nn(), s, t, e, n, i)), mo } function go(t, e, n, i) { return fo(t, je(), n) ? e + ct(n) + i : $s } function _o(t, e, n, i, s, r, o, a) { const l = Ae(), c = Oe(), h = t + Xt, u = c.firstCreatePass ? function (t, e, n, i, s, r, o, a, l) { const c = e.consts, h = er(e, t, 4, o || null, xe(c, a)); mr(e, n, h, xe(c, l)), sn(e, h); const u = h.tViews = ur(2, h, i, s, r, e.directiveRegistry, e.pipeRegistry, null, e.schemas, c); return null !== e.queries && (e.queries.template(e, h), u.queries = e.queries.embeddedTView(h)), h }(h, c, l, e, n, i, s, r, o) : c.data[h]; Me(u, !1); const d = l[11].createComment(""); ks(c, l, d, u), Gi(d, l), Ar(l, l[h] = Sr(d, l, d, u)), se(u) && lr(c, l, u), null != o && cr(l, u, a) } function yo(t) { return function (t, e) { return t[e] }(Te.lFrame.contextLView, Xt + t) } function bo(t, e = wt.Default) { const n = Ae(); return null === n ? li(t, e) : On(De(), n, ot(t), e) } function vo(t, e, n) { const i = Ae(); return fo(i, je(), e) && fr(Oe(), nn(), i, t, e, i[11], n, !1), vo } function wo(t, e, n, i, s) { const r = s ? "class" : "style"; jr(t, n, e.inputs[r], r, i) } function Co(t, e, n, i) { const s = Ae(), r = Oe(), o = Xt + t, a = s[11], l = s[o] = us(a, e, Te.lFrame.currentNamespace), c = r.firstCreatePass ? function (t, e, n, i, s, r, o) { const a = e.consts, l = er(e, t, 2, s, xe(a, r)); return mr(e, n, l, xe(a, o)), null !== l.attrs && Br(l, l.attrs, !1), null !== l.mergedAttrs && Br(l, l.mergedAttrs, !0), null !== e.queries && e.queries.elementStart(e, l), l }(o, r, s, 0, e, n, i) : r.data[o]; Me(c, !0); const h = c.mergedAttrs; null !== h && dn(a, l, h); const u = c.classes; null !== u && Is(a, l, u); const d = c.styles; null !== d && Os(a, l, d), 64 != (64 & c.flags) && ks(r, s, l, c), 0 === Te.lFrame.elementDepthCount && Gi(l, s), Te.lFrame.elementDepthCount++, se(c) && (lr(r, s, c), ar(r, c, s)), null !== i && cr(s, c) } function ko() { let t = De(); Ne() ? Fe() : (t = t.parent, Me(t, !1)); const e = t; Te.lFrame.elementDepthCount--; const n = Oe(); n.firstCreatePass && (sn(n, t), ne(t) && n.queries.elementEnd(t)), null != e.classesWithoutHost && function (t) { return 0 != (16 & t.flags) }(e) && wo(n, e, Ae(), e.classesWithoutHost, !0), null != e.stylesWithoutHost && function (t) { return 0 != (32 & t.flags) }(e) && wo(n, e, Ae(), e.stylesWithoutHost, !1) } function xo(t, e, n, i) { Co(t, e, n, i), ko() } function So(t, e, n) { const i = Ae(), s = Oe(), r = t + Xt, o = s.firstCreatePass ? function (t, e, n, i, s) { const r = e.consts, o = xe(r, i), a = er(e, t, 8, "ng-container", o); return null !== o && Br(a, o, !0), mr(e, n, a, xe(r, s)), null !== e.queries && e.queries.elementStart(e, a), a }(r, s, i, e, n) : s.data[r]; Me(o, !0); const a = i[r] = i[11].createComment(""); ks(s, i, a, o), Gi(a, i), se(o) && (lr(s, i, o), ar(s, o, i)), null != n && cr(i, o) } function Eo() { let t = De(); const e = Oe(); Ne() ? Fe() : (t = t.parent, Me(t, !1)), e.firstCreatePass && (sn(e, t), ne(t) && e.queries.elementEnd(t)) } function To(t, e, n) { So(t, e, n), Eo() } function Ro() { return Ae() } function Ao(t) { return !!t && "function" == typeof t.then } const Oo = function (t) { return !!t && "function" == typeof t.subscribe }; function Io(t, e, n, i) { const s = Ae(), r = Oe(), o = De(); return Po(r, s, s[11], o, t, e, !!n, i), Io } function Do(t, e) { const n = De(), i = Ae(), s = Oe(); return Po(s, i, Lr(ze(s.data), n, i), n, t, e, !1), Do } function Po(t, e, n, i, s, r, o, a) { const l = se(i), c = t.firstCreatePass && Fr(t), h = Nr(e); let u = !0; if (3 & i.type || a) { const d = be(i, e), p = a ? a(d) : d, f = h.length, m = a ? t => a(_e(t[i.index])) : i.index; if (me(n)) { let o = null; if (!a && l && (o = function (t, e, n, i) { const s = t.cleanup; if (null != s) for (let r = 0; r < s.length - 1; r += 2) { const t = s[r]; if (t === n && s[r + 1] === i) { const t = e[7], n = s[r + 2]; return t.length > n ? t[n] : null } "string" == typeof t && (r += 2) } return null }(t, e, s, i.index)), null !== o) (o.__ngLastListenerFn__ || o).__ngNextListenerFn__ = r, o.__ngLastListenerFn__ = r, u = !1; else { r = No(i, e, 0, r, !1); const t = n.listen(p, s, r); h.push(r, t), c && c.push(s, m, f, f + 1) } } else r = No(i, e, 0, r, !0), p.addEventListener(s, r, o), h.push(r), c && c.push(s, m, f, o) } else r = No(i, e, 0, r, !1); const d = i.outputs; let p; if (u && null !== d && (p = d[s])) { const t = p.length; if (t) for (let n = 0; n < t; n += 2) { const t = e[p[n]][p[n + 1]].subscribe(r), o = h.length; h.push(r, t), c && c.push(s, i.index, o, -(o + 1)) } } } function Mo(t, e, n, i) { try { return !1 !== n(i) } catch (s) { return Vr(t, s), !1 } } function No(t, e, n, i, s) { return function n(r) { if (r === Function) return i; const o = 2 & t.flags ? we(t.index, e) : e; 0 == (32 & e[2]) && Or(o); let a = Mo(e, 0, i, r), l = n.__ngNextListenerFn__; for (; l;)a = Mo(e, 0, l, r) && a, l = l.__ngNextListenerFn__; return s && !1 === a && (r.preventDefault(), r.returnValue = !1), a } } function Fo(t = 1) { return function (t) { return (Te.lFrame.contextLView = function (t, e) { for (; t > 0;)e = e[15], t--; return e }(t, Te.lFrame.contextLView))[8] }(t) } function Lo(t, e) { let n = null; const i = function (t) { const e = t.attrs; if (null != e) { const t = e.indexOf(5); if (0 == (1 & t)) return e[t + 1] } return null }(t); for (let s = 0; s < e.length; s++) { const r = e[s]; if ("*" !== r) { if (null === i ? Bs(t, r, !0) : Hs(i, r)) return s } else n = s } return n } function Vo(t) { const e = Ae()[16][6]; if (!e.projection) { const n = e.projection = Qn(t ? t.length : 1, null), i = n.slice(); let s = e.child; for (; null !== s;) { const e = t ? Lo(s, t) : 0; null !== e && (i[e] ? i[e].projectionNext = s : n[e] = s, i[e] = s), s = s.next } } } function jo(t, e = 0, n) { const i = Ae(), s = Oe(), r = er(s, Xt + t, 16, null, n || null); null === r.projection && (r.projection = e), Fe(), 64 != (64 & r.flags) && function (t, e, n) { As(e[11], 0, e, n, gs(t, n, e), ws(n.parent || e[6], n, e)) }(s, i, r) } function Bo(t, e, n, i, s) { const r = t[n + 1], o = null === e; let a = i ? Ys(r) : Gs(r), l = !1; for (; 0 !== a && (!1 === l || o);) { const n = t[a + 1]; Ho(t[a], e) && (l = !0, t[a + 1] = i ? Xs(n) : Zs(n)), a = i ? Ys(n) : Gs(n) } l && (t[n + 1] = i ? Zs(r) : Xs(r)) } function Ho(t, e) { return null === t || null == e || (Array.isArray(t) ? t[1] : t) === e || !(!Array.isArray(t) || "string" != typeof e) && ti(t, e) >= 0 } const Uo = { textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0 }; function zo(t) { return t.substring(Uo.key, Uo.keyEnd) } function $o(t, e) { const n = Uo.textEnd; return n === e ? -1 : (e = Uo.keyEnd = function (t, e, n) { for (; e < n && t.charCodeAt(e) > 32;)e++; return e }(t, Uo.key = e, n), qo(t, e, n)) } function qo(t, e, n) { for (; e < n && t.charCodeAt(e) <= 32;)e++; return e } function Wo(t, e, n) { return Zo(t, e, n, !1), Wo } function Ko(t, e) { return Zo(t, e, null, !0), Ko } function Yo(t, e) { for (let n = function (t) { return function (t) { Uo.key = 0, Uo.keyEnd = 0, Uo.value = 0, Uo.valueEnd = 0, Uo.textEnd = t.length }(t), $o(t, qo(t, 0, Uo.textEnd)) }(e); n >= 0; n = $o(e, n))Xn(t, zo(e), !0) } function Zo(t, e, n, i) { const s = Ae(), r = Oe(), o = Be(2); r.firstUpdatePass && Xo(r, t, o, i), e !== $s && fo(s, o, e) && ea(r, r.data[tn()], s, s[11], t, s[o + 1] = function (t, e) { return null == t || ("string" == typeof e ? t += e : "object" == typeof t && (t = nt(ki(t)))), t }(e, n), i, o) } function Go(t, e, n, i) { const s = Oe(), r = Be(2); s.firstUpdatePass && Xo(s, null, r, i); const o = Ae(); if (n !== $s && fo(o, r, n)) { const a = s.data[tn()]; if (sa(a, i) && !Qo(s, r)) { let t = i ? a.classesWithoutHost : a.stylesWithoutHost; null !== t && (n = it(t, n || "")), wo(s, a, o, n, i) } else !function (t, e, n, i, s, r, o, a) { s === $s && (s = Mt); let l = 0, c = 0, h = 0 < s.length ? s[0] : null, u = 0 < r.length ? r[0] : null; for (; null !== h || null !== u;) { const d = l < s.length ? s[l + 1] : void 0, p = c < r.length ? r[c + 1] : void 0; let f, m = null; h === u ? (l += 2, c += 2, d !== p && (m = u, f = p)) : null === u || null !== h && h < u ? (l += 2, m = h) : (c += 2, m = u, f = p), null !== m && ea(t, e, n, i, m, f, o, a), h = l < s.length ? s[l] : null, u = c < r.length ? r[c] : null } }(s, a, o, o[11], o[r + 1], o[r + 1] = function (t, e, n) { if (null == n || "" === n) return Mt; const i = [], s = ki(n); if (Array.isArray(s)) for (let r = 0; r < s.length; r++)t(i, s[r], !0); else if ("object" == typeof s) for (const r in s) s.hasOwnProperty(r) && t(i, r, s[r]); else "string" == typeof s && e(i, s); return i }(t, e, n), i, r) } } function Qo(t, e) { return e >= t.expandoStartIndex } function Xo(t, e, n, i) { const s = t.data; if (null === s[n + 1]) { const r = s[tn()], o = Qo(t, n); sa(r, i) && null === e && !o && (e = !1), e = function (t, e, n, i) { const s = ze(t); let r = i ? e.residualClasses : e.residualStyles; if (null === s) 0 === (i ? e.classBindings : e.styleBindings) && (n = ta(n = Jo(null, t, e, n, i), e.attrs, i), r = null); else { const o = e.directiveStylingLast; if (-1 === o || t[o] !== s) if (n = Jo(s, t, e, n, i), null === r) { let n = function (t, e, n) { const i = n ? e.classBindings : e.styleBindings; if (0 !== Gs(i)) return t[Ys(i)] }(t, e, i); void 0 !== n && Array.isArray(n) && (n = Jo(null, t, e, n[1], i), n = ta(n, e.attrs, i), function (t, e, n, i) { t[Ys(n ? e.classBindings : e.styleBindings)] = i }(t, e, i, n)) } else r = function (t, e, n) { let i; const s = e.directiveEnd; for (let r = 1 + e.directiveStylingLast; r < s; r++)i = ta(i, t[r].hostAttrs, n); return ta(i, e.attrs, n) }(t, e, i) } return void 0 !== r && (i ? e.residualClasses = r : e.residualStyles = r), n }(s, r, e, i), function (t, e, n, i, s, r) { let o = r ? e.classBindings : e.styleBindings, a = Ys(o), l = Gs(o); t[i] = n; let c, h = !1; if (Array.isArray(n)) { const t = n; c = t[1], (null === c || ti(t, c) > 0) && (h = !0) } else c = n; if (s) if (0 !== l) { const e = Ys(t[a + 1]); t[i + 1] = Ks(e, a), 0 !== e && (t[e + 1] = Qs(t[e + 1], i)), t[a + 1] = 131071 & t[a + 1] | i << 17 } else t[i + 1] = Ks(a, 0), 0 !== a && (t[a + 1] = Qs(t[a + 1], i)), a = i; else t[i + 1] = Ks(l, 0), 0 === a ? a = i : t[l + 1] = Qs(t[l + 1], i), l = i; h && (t[i + 1] = Zs(t[i + 1])), Bo(t, c, i, !0), Bo(t, c, i, !1), function (t, e, n, i, s) { const r = s ? t.residualClasses : t.residualStyles; null != r && "string" == typeof e && ti(r, e) >= 0 && (n[i + 1] = Xs(n[i + 1])) }(e, c, t, i, r), o = Ks(a, l), r ? e.classBindings = o : e.styleBindings = o }(s, r, e, n, o, i) } } function Jo(t, e, n, i, s) { let r = null; const o = n.directiveEnd; let a = n.directiveStylingLast; for (-1 === a ? a = n.directiveStart : a++; a < o && (r = e[a], i = ta(i, r.hostAttrs, s), r !== t);)a++; return null !== t && (n.directiveStylingLast = a), i } function ta(t, e, n) { const i = n ? 1 : 2; let s = -1; if (null !== e) for (let r = 0; r < e.length; r++) { const o = e[r]; "number" == typeof o ? s = o : s === i && (Array.isArray(t) || (t = void 0 === t ? [] : ["", t]), Xn(t, o, !!n || e[++r])) } return void 0 === t ? null : t } function ea(t, e, n, i, s, r, o, a) { if (!(3 & e.type)) return; const l = t.data, c = l[a + 1]; ia(1 == (1 & c) ? na(l, e, n, s, Gs(c), o) : void 0) || (ia(r) || 2 == (2 & c) && (r = na(l, null, n, s, a, o)), function (t, e, n, i, s) { const r = me(t); if (e) s ? r ? t.addClass(n, i) : n.classList.add(i) : r ? t.removeClass(n, i) : n.classList.remove(i); else { let e = -1 === i.indexOf("-") ? void 0 : ss.DashCase; if (null == s) r ? t.removeStyle(n, i, e) : n.style.removeProperty(i); else { const o = "string" == typeof s && s.endsWith("!important"); o && (s = s.slice(0, -10), e |= ss.Important), r ? t.setStyle(n, i, s, e) : n.style.setProperty(i, s, o ? "important" : "") } } }(i, o, ye(tn(), n), s, r)) } function na(t, e, n, i, s, r) { const o = null === e; let a; for (; s > 0;) { const e = t[s], r = Array.isArray(e), l = r ? e[1] : e, c = null === l; let h = n[s + 1]; h === $s && (h = c ? Mt : void 0); let u = c ? Jn(h, i) : l === i ? h : void 0; if (r && !ia(u) && (u = Jn(e, i)), ia(u) && (a = u, o)) return a; const d = t[s + 1]; s = o ? Ys(d) : Gs(d) } if (null !== e) { let t = r ? e.residualClasses : e.residualStyles; null != t && (a = Jn(t, i)) } return a } function ia(t) { return void 0 !== t } function sa(t, e) { return 0 != (t.flags & (e ? 16 : 32)) } function ra(t, e = "") { const n = Ae(), i = Oe(), s = t + Xt, r = i.firstCreatePass ? er(i, s, 1, e, null) : i.data[s], o = n[s] = function (t, e) { return me(t) ? t.createText(e) : t.createTextNode(e) }(n[11], e); ks(i, n, o, r), Me(r, !1) } function oa(t) { return aa("", t, ""), oa } function aa(t, e, n) { const i = Ae(), s = go(i, t, e, n); return s !== $s && function (t, e, n) { const i = ye(e, t); !function (t, e, n) { me(t) ? t.setValue(e, n) : e.textContent = n }(t[11], i, n) }(i, tn(), s), aa } function la(t, e, n) { Go(Xn, Yo, go(Ae(), t, e, n), !0) } function ca(t, e, n, i, s) { Go(Xn, Yo, function (t, e, n, i, s, r) { const o = function (t, e, n, i) { const s = fo(t, e, n); return fo(t, e + 1, i) || s }(t, Te.lFrame.bindingIndex, n, s); return Be(2), o ? e + ct(n) + i + ct(s) + r : $s }(Ae(), t, e, n, i, s), !0) } function ha(t, e, n) { const i = Ae(); return fo(i, je(), e) && fr(Oe(), nn(), i, t, e, i[11], n, !0), ha } function ua(t, e, n) { const i = Ae(); if (fo(i, je(), e)) { const s = Oe(), r = nn(); fr(s, r, i, t, e, Lr(ze(s.data), r, i), n, !0) } return ua } const da = void 0; var pa = ["en", [["a", "p"], ["AM", "PM"], da], [["AM", "PM"], da, da], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], da, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], da, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", da, "{1} 'at' {0}", da], [".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":"], ["#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", function (t) { let e = Math.floor(Math.abs(t)), n = t.toString().replace(/^[^.]*\.?/, "").length; return 1 === e && 0 === n ? 1 : 5 }]; let fa = {}; function ma(t) { return t in fa || (fa[t] = Dt.ng && Dt.ng.common && Dt.ng.common.locales && Dt.ng.common.locales[t]), fa[t] } var ga = function (t) { return t[t.LocaleId = 0] = "LocaleId", t[t.DayPeriodsFormat = 1] = "DayPeriodsFormat", t[t.DayPeriodsStandalone = 2] = "DayPeriodsStandalone", t[t.DaysFormat = 3] = "DaysFormat", t[t.DaysStandalone = 4] = "DaysStandalone", t[t.MonthsFormat = 5] = "MonthsFormat", t[t.MonthsStandalone = 6] = "MonthsStandalone", t[t.Eras = 7] = "Eras", t[t.FirstDayOfWeek = 8] = "FirstDayOfWeek", t[t.WeekendRange = 9] = "WeekendRange", t[t.DateFormat = 10] = "DateFormat", t[t.TimeFormat = 11] = "TimeFormat", t[t.DateTimeFormat = 12] = "DateTimeFormat", t[t.NumberSymbols = 13] = "NumberSymbols", t[t.NumberFormats = 14] = "NumberFormats", t[t.CurrencyCode = 15] = "CurrencyCode", t[t.CurrencySymbol = 16] = "CurrencySymbol", t[t.CurrencyName = 17] = "CurrencyName", t[t.Currencies = 18] = "Currencies", t[t.Directionality = 19] = "Directionality", t[t.PluralCase = 20] = "PluralCase", t[t.ExtraData = 21] = "ExtraData", t }({}); const _a = "en-US"; let ya = _a; function ba(t) { var e, n; n = "Expected localeId to be defined", null == (e = t) && function (t, e, n, i) { throw new Error(`ASSERTION ERROR: ${t} [Expected=> null != ${e} <=Actual]`) }(n, e), "string" == typeof t && (ya = t.toLowerCase().replace(/_/g, "-")) } function va(t, e, n, i, s) { if (t = ot(t), Array.isArray(t)) for (let r = 0; r < t.length; r++)va(t[r], e, n, i, s); else { const r = Oe(), o = Ae(); let a = to(t) ? t : ot(t.provide), l = Qr(t); const c = De(), h = 1048575 & c.providerIndexes, u = c.directiveStart, d = c.providerIndexes >> 20; if (to(t) || !t.multi) { const i = new un(l, s, bo), p = ka(a, e, s ? h : h + d, u); -1 === p ? (Tn(kn(c, o), r, a), wa(r, t, e.length), e.push(a), c.directiveStart++, c.directiveEnd++, s && (c.providerIndexes += 1048576), n.push(i), o.push(i)) : (n[p] = i, o[p] = i) } else { const p = ka(a, e, h + d, u), f = ka(a, e, h, h + d), m = p >= 0 && n[p], g = f >= 0 && n[f]; if (s && !g || !s && !m) { Tn(kn(c, o), r, a); const h = function (t, e, n, i, s) { const r = new un(t, n, bo); return r.multi = [], r.index = e, r.componentProviders = 0, Ca(r, s, i && !n), r }(s ? Sa : xa, n.length, s, i, l); !s && g && (n[f].providerFactory = h), wa(r, t, e.length, 0), e.push(a), c.directiveStart++, c.directiveEnd++, s && (c.providerIndexes += 1048576), n.push(h), o.push(h) } else wa(r, t, p > -1 ? p : f, Ca(n[s ? f : p], l, !s && i)); !s && i && g && n[f].componentProviders++ } } } function wa(t, e, n, i) { const s = to(e); if (s || e.useClass) { const r = (e.useClass || e).prototype.ngOnDestroy; if (r) { const o = t.destroyHooks || (t.destroyHooks = []); if (!s && e.multi) { const t = o.indexOf(n); -1 === t ? o.push(n, [i, r]) : o[t + 1].push(i, r) } else o.push(n, r) } } } function Ca(t, e, n) { return n && t.componentProviders++, t.multi.push(e) - 1 } function ka(t, e, n, i) { for (let s = n; s < i; s++)if (e[s] === t) return s; return -1 } function xa(t, e, n, i) { return Ea(this.multi, []) } function Sa(t, e, n, i) { const s = this.multi; let r; if (this.providerFactory) { const t = this.providerFactory.componentProviders, e = Nn(n, n[1], this.providerFactory.index, i); r = e.slice(0, t), Ea(s, r); for (let n = t; n < e.length; n++)r.push(e[n]) } else r = [], Ea(s, r); return r } function Ea(t, e) { for (let n = 0; n < t.length; n++)e.push((0, t[n])()); return e } function Ta(t, e = []) { return n => { n.providersResolver = (n, i) => function (t, e, n) { const i = Oe(); if (i.firstCreatePass) { const s = re(t); va(n, i.data, i.blueprint, s, !0), va(e, i.data, i.blueprint, s, !1) } }(n, i ? i(t) : t, e) } } class Ra { } class Aa { resolveComponentFactory(t) { throw function (t) { const e = Error(`No component factory found for ${nt(t)}. Did you add it to @NgModule.entryComponents?`); return e.ngComponent = t, e }(t) } } let Oa = (() => { class t { } return t.NULL = new Aa, t })(); function Ia(...t) { } function Da(t, e) { return new Ma(be(t, e)) } const Pa = function () { return Da(De(), Ae()) }; let Ma = (() => { class t { constructor(t) { this.nativeElement = t } } return t.__NG_ELEMENT_ID__ = Pa, t })(); function Na(t) { return t instanceof Ma ? t.nativeElement : t } class Fa { } let La = (() => { class t { } return t.__NG_ELEMENT_ID__ = () => Va(), t })(); const Va = function () { const t = Ae(), e = we(De().index, t); return function (t) { return t[11] }(te(e) ? e : t) }; let ja = (() => { class t { } return t.\u0275prov = dt({ token: t, providedIn: "root", factory: () => null }), t })(); class Ba { constructor(t) { this.full = t, this.major = t.split(".")[0], this.minor = t.split(".")[1], this.patch = t.split(".").slice(2).join(".") } } const Ha = new Ba("12.0.4"); class Ua { constructor() { } supports(t) { return uo(t) } create(t) { return new $a(t) } } const za = (t, e) => e; class $a { constructor(t) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = t || za } forEachItem(t) { let e; for (e = this._itHead; null !== e; e = e._next)t(e) } forEachOperation(t) { let e = this._itHead, n = this._removalsHead, i = 0, s = null; for (; e || n;) { const r = !n || e && e.currentIndex < Ya(n, i, s) ? e : n, o = Ya(r, i, s), a = r.currentIndex; if (r === n) i--, n = n._nextRemoved; else if (e = e._next, null == r.previousIndex) i++; else { s || (s = []); const t = o - i, e = a - i; if (t != e) { for (let n = 0; n < t; n++) { const i = n < s.length ? s[n] : s[n] = 0, r = i + n; e <= r && r < t && (s[n] = i + 1) } s[r.previousIndex] = e - t } } o !== a && t(r, o, a) } } forEachPreviousItem(t) { let e; for (e = this._previousItHead; null !== e; e = e._nextPrevious)t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)t(e) } forEachMovedItem(t) { let e; for (e = this._movesHead; null !== e; e = e._nextMoved)t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)t(e) } forEachIdentityChange(t) { let e; for (e = this._identityChangesHead; null !== e; e = e._nextIdentityChange)t(e) } diff(t) { if (null == t && (t = []), !uo(t)) throw new Error(`Error trying to diff '${nt(t)}'. Only arrays and iterables are allowed`); return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let e, n, i, s = this._itHead, r = !1; if (Array.isArray(t)) { this.length = t.length; for (let e = 0; e < this.length; e++)n = t[e], i = this._trackByFn(e, n), null !== s && Object.is(s.trackById, i) ? (r && (s = this._verifyReinsertion(s, n, i, e)), Object.is(s.item, n) || this._addIdentityChange(s, n)) : (s = this._mismatch(s, n, i, e), r = !0), s = s._next } else e = 0, function (t, e) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++)e(t[n]); else { const n = t[ho()](); let i; for (; !(i = n.next()).done;)e(i.value) } }(t, t => { i = this._trackByFn(e, t), null !== s && Object.is(s.trackById, i) ? (r && (s = this._verifyReinsertion(s, t, i, e)), Object.is(s.item, t) || this._addIdentityChange(s, t)) : (s = this._mismatch(s, t, i, e), r = !0), s = s._next, e++ }), this.length = e; return this._truncate(s), this.collection = t, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let t; for (t = this._previousItHead = this._itHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._additionsHead; null !== t; t = t._nextAdded)t.previousIndex = t.currentIndex; for (this._additionsHead = this._additionsTail = null, t = this._movesHead; null !== t; t = t._nextMoved)t.previousIndex = t.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(t, e, n, i) { let s; return null === t ? s = this._itTail : (s = t._prev, this._remove(t)), null !== (t = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(n, null)) ? (Object.is(t.item, e) || this._addIdentityChange(t, e), this._reinsertAfter(t, s, i)) : null !== (t = null === this._linkedRecords ? null : this._linkedRecords.get(n, i)) ? (Object.is(t.item, e) || this._addIdentityChange(t, e), this._moveAfter(t, s, i)) : t = this._addAfter(new qa(e, n), s, i), t } _verifyReinsertion(t, e, n, i) { let s = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(n, null); return null !== s ? t = this._reinsertAfter(s, t._prev, i) : t.currentIndex != i && (t.currentIndex = i, this._addToMoves(t, i)), t } _truncate(t) { for (; null !== t;) { const e = t._next; this._addToRemovals(this._unlink(t)), t = e } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(t, e, n) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(t); const i = t._prevRemoved, s = t._nextRemoved; return null === i ? this._removalsHead = s : i._nextRemoved = s, null === s ? this._removalsTail = i : s._prevRemoved = i, this._insertAfter(t, e, n), this._addToMoves(t, n), t } _moveAfter(t, e, n) { return this._unlink(t), this._insertAfter(t, e, n), this._addToMoves(t, n), t } _addAfter(t, e, n) { return this._insertAfter(t, e, n), this._additionsTail = null === this._additionsTail ? this._additionsHead = t : this._additionsTail._nextAdded = t, t } _insertAfter(t, e, n) { const i = null === e ? this._itHead : e._next; return t._next = i, t._prev = e, null === i ? this._itTail = t : i._prev = t, null === e ? this._itHead = t : e._next = t, null === this._linkedRecords && (this._linkedRecords = new Ka), this._linkedRecords.put(t), t.currentIndex = n, t } _remove(t) { return this._addToRemovals(this._unlink(t)) } _unlink(t) { null !== this._linkedRecords && this._linkedRecords.remove(t); const e = t._prev, n = t._next; return null === e ? this._itHead = n : e._next = n, null === n ? this._itTail = e : n._prev = e, t } _addToMoves(t, e) { return t.previousIndex === e || (this._movesTail = null === this._movesTail ? this._movesHead = t : this._movesTail._nextMoved = t), t } _addToRemovals(t) { return null === this._unlinkedRecords && (this._unlinkedRecords = new Ka), this._unlinkedRecords.put(t), t.currentIndex = null, t._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = t, t._prevRemoved = null) : (t._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = t), t } _addIdentityChange(t, e) { return t.item = e, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = t : this._identityChangesTail._nextIdentityChange = t, t } } class qa { constructor(t, e) { this.item = t, this.trackById = e, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class Wa { constructor() { this._head = null, this._tail = null } add(t) { null === this._head ? (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) : (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null, this._tail = t) } get(t, e) { let n; for (n = this._head; null !== n; n = n._nextDup)if ((null === e || e <= n.currentIndex) && Object.is(n.trackById, t)) return n; return null } remove(t) { const e = t._prevDup, n = t._nextDup; return null === e ? this._head = n : e._nextDup = n, null === n ? this._tail = e : n._prevDup = e, null === this._head } } class Ka { constructor() { this.map = new Map } put(t) { const e = t.trackById; let n = this.map.get(e); n || (n = new Wa, this.map.set(e, n)), n.add(t) } get(t, e) { const n = this.map.get(t); return n ? n.get(t, e) : null } remove(t) { const e = t.trackById; return this.map.get(e).remove(t) && this.map.delete(e), t } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function Ya(t, e, n) { const i = t.previousIndex; if (null === i) return i; let s = 0; return n && i < n.length && (s = n[i]), i + e + s } class Za { constructor() { } supports(t) { return t instanceof Map || po(t) } create() { return new Ga } } class Ga { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(t) { let e; for (e = this._mapHead; null !== e; e = e._next)t(e) } forEachPreviousItem(t) { let e; for (e = this._previousMapHead; null !== e; e = e._nextPrevious)t(e) } forEachChangedItem(t) { let e; for (e = this._changesHead; null !== e; e = e._nextChanged)t(e) } forEachAddedItem(t) { let e; for (e = this._additionsHead; null !== e; e = e._nextAdded)t(e) } forEachRemovedItem(t) { let e; for (e = this._removalsHead; null !== e; e = e._nextRemoved)t(e) } diff(t) { if (t) { if (!(t instanceof Map || po(t))) throw new Error(`Error trying to diff '${nt(t)}'. Only maps and objects are allowed`) } else t = new Map; return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let e = this._mapHead; if (this._appendAfter = null, this._forEach(t, (t, n) => { if (e && e.key === n) this._maybeAddToChanges(e, t), this._appendAfter = e, e = e._next; else { const i = this._getOrCreateRecordForKey(n, t); e = this._insertBeforeOrAppend(e, i) } }), e) { e._prev && (e._prev._next = null), this._removalsHead = e; for (let t = e; null !== t; t = t._nextRemoved)t === this._mapHead && (this._mapHead = null), this._records.delete(t.key), t._nextRemoved = t._next, t.previousValue = t.currentValue, t.currentValue = null, t._prev = null, t._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(t, e) { if (t) { const n = t._prev; return e._next = t, e._prev = n, t._prev = e, n && (n._next = e), t === this._mapHead && (this._mapHead = e), this._appendAfter = t, t } return this._appendAfter ? (this._appendAfter._next = e, e._prev = this._appendAfter) : this._mapHead = e, this._appendAfter = e, null } _getOrCreateRecordForKey(t, e) { if (this._records.has(t)) { const n = this._records.get(t); this._maybeAddToChanges(n, e); const i = n._prev, s = n._next; return i && (i._next = s), s && (s._prev = i), n._next = null, n._prev = null, n } const n = new Qa(t); return this._records.set(t, n), n.currentValue = e, this._addToAdditions(n), n } _reset() { if (this.isDirty) { let t; for (this._previousMapHead = this._mapHead, t = this._previousMapHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._changesHead; null !== t; t = t._nextChanged)t.previousValue = t.currentValue; for (t = this._additionsHead; null != t; t = t._nextAdded)t.previousValue = t.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(t, e) { Object.is(e, t.currentValue) || (t.previousValue = t.currentValue, t.currentValue = e, this._addToChanges(t)) } _addToAdditions(t) { null === this._additionsHead ? this._additionsHead = this._additionsTail = t : (this._additionsTail._nextAdded = t, this._additionsTail = t) } _addToChanges(t) { null === this._changesHead ? this._changesHead = this._changesTail = t : (this._changesTail._nextChanged = t, this._changesTail = t) } _forEach(t, e) { t instanceof Map ? t.forEach(e) : Object.keys(t).forEach(n => e(t[n], n)) } } class Qa { constructor(t) { this.key = t, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } function Xa() { return new Ja([new Ua]) } let Ja = (() => { class t { constructor(t) { this.factories = t } static create(e, n) { if (null != n) { const t = n.factories.slice(); e = e.concat(t) } return new t(e) } static extend(e) { return { provide: t, useFactory: n => t.create(e, n || Xa()), deps: [[t, new fi, new pi]] } } find(t) { const e = this.factories.find(e => e.supports(t)); if (null != e) return e; throw new Error(`Cannot find a differ supporting object '${t}' of type '${n = t, n.name || typeof n}'`); var n } } return t.\u0275prov = dt({ token: t, providedIn: "root", factory: Xa }), t })(); function tl() { return new el([new Za]) } let el = (() => { class t { constructor(t) { this.factories = t } static create(e, n) { if (n) { const t = n.factories.slice(); e = e.concat(t) } return new t(e) } static extend(e) { return { provide: t, useFactory: n => t.create(e, n || tl()), deps: [[t, new fi, new pi]] } } find(t) { const e = this.factories.find(e => e.supports(t)); if (e) return e; throw new Error(`Cannot find a differ supporting object '${t}'`) } } return t.\u0275prov = dt({ token: t, providedIn: "root", factory: tl }), t })(); function nl(t, e, n, i, s = !1) { for (; null !== n;) { const r = e[n.index]; if (null !== r && i.push(_e(r)), ee(r)) for (let t = Jt; t < r.length; t++) { const e = r[t], n = e[1].firstChild; null !== n && nl(e[1], e, n, i) } const o = n.type; if (8 & o) nl(t, e, n.child, i); else if (32 & o) { const t = rs(n, e); let s; for (; s = t();)i.push(s) } else if (16 & o) { const t = Ss(e, n); if (Array.isArray(t)) i.push(...t); else { const n = os(e[16]); nl(n[1], n, t, i, !0) } } n = s ? n.projectionNext : n.next } return i } class il { constructor(t, e) { this._lView = t, this._cdRefInjectingView = e, this._appRef = null, this._attachedToViewContainer = !1 } get rootNodes() { const t = this._lView, e = t[1]; return nl(e, t, e.firstChild, []) } get context() { return this._lView[8] } set context(t) { this._lView[8] = t } get destroyed() { return 256 == (256 & this._lView[2]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const t = this._lView[3]; if (ee(t)) { const e = t[8], n = e ? e.indexOf(this) : -1; n > -1 && (ps(t, n), Gn(e, n)) } this._attachedToViewContainer = !1 } fs(this._lView[1], this._lView) } onDestroy(t) { dr(this._lView[1], this._lView, null, t) } markForCheck() { Or(this._cdRefInjectingView || this._lView) } detach() { this._lView[2] &= -129 } reattach() { this._lView[2] |= 128 } detectChanges() { Ir(this._lView[1], this._lView, this.context) } checkNoChanges() { !function (t, e, n) { Ve(!0); try { Ir(t, e, n) } finally { Ve(!1) } }(this._lView[1], this._lView, this.context) } attachToViewContainerRef() { if (this._appRef) throw new Error("This view is already attached directly to the ApplicationRef!"); this._attachedToViewContainer = !0 } detachFromAppRef() { var t; this._appRef = null, Rs(this._lView[1], t = this._lView, t[11], 2, null, null) } attachToAppRef(t) { if (this._attachedToViewContainer) throw new Error("This view is already attached to a ViewContainer!"); this._appRef = t } } class sl extends il { constructor(t) { super(t), this._view = t } detectChanges() { Dr(this._view) } checkNoChanges() { !function (t) { Ve(!0); try { Dr(t) } finally { Ve(!1) } }(this._view) } get context() { return null } } const rl = function (t) { return function (t, e, n) { if (ie(t) && !n) { const n = we(t.index, e); return new il(n, n) } return 47 & t.type ? new il(e[16], e) : null }(De(), Ae(), 16 == (16 & t)) }; let ol = (() => { class t { } return t.__NG_ELEMENT_ID__ = rl, t })(); const al = [new Za], ll = new Ja([new Ua]), cl = new el(al), hl = function () { return fl(De(), Ae()) }; let ul = (() => { class t { } return t.__NG_ELEMENT_ID__ = hl, t })(); const dl = ul, pl = class extends dl { constructor(t, e, n) { super(), this._declarationLView = t, this._declarationTContainer = e, this.elementRef = n } createEmbeddedView(t) { const e = this._declarationTContainer.tViews, n = tr(this._declarationLView, e, t, 16, null, e.declTNode, null, null, null, null); n[17] = this._declarationLView[this._declarationTContainer.index]; const i = this._declarationLView[19]; return null !== i && (n[19] = i.createEmbeddedView(e)), ir(e, n, t), new il(n) } }; function fl(t, e) { return 4 & t.type ? new pl(e, t, Da(t, e)) : null } class ml { } class gl { } const _l = function () { return kl(De(), Ae()) }; let yl = (() => { class t { } return t.__NG_ELEMENT_ID__ = _l, t })(); const bl = yl, vl = class extends bl { constructor(t, e, n) { super(), this._lContainer = t, this._hostTNode = e, this._hostLView = n } get element() { return Da(this._hostTNode, this._hostLView) } get injector() { return new Vn(this._hostTNode, this._hostLView) } get parentInjector() { const t = En(this._hostTNode, this._hostLView); if (_n(t)) { const e = bn(t, this._hostLView), n = yn(t); return new Vn(e[1].data[n + 8], e) } return new Vn(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(t) { const e = wl(this._lContainer); return null !== e && e[t] || null } get length() { return this._lContainer.length - Jt } createEmbeddedView(t, e, n) { const i = t.createEmbeddedView(e || {}); return this.insert(i, n), i } createComponent(t, e, n, i, s) { const r = n || this.parentInjector; if (!s && null == t.ngModule && r) { const t = r.get(ml, null); t && (s = t) } const o = t.create(r, i, void 0, s); return this.insert(o.hostView, e), o } insert(t, e) { const n = t._lView, i = n[1]; if (ee(n[3])) { const e = this.indexOf(t); if (-1 !== e) this.detach(e); else { const e = n[3], i = new vl(e, e[6], e[3]); i.detach(i.indexOf(t)) } } const s = this._adjustIndex(e), r = this._lContainer; !function (t, e, n, i) { const s = Jt + i, r = n.length; i > 0 && (n[s - 1][4] = e), i < r - Jt ? (e[4] = n[s], Zn(n, Jt + i, e)) : (n.push(e), e[4] = null), e[3] = n; const o = e[17]; null !== o && n !== o && function (t, e) { const n = t[9]; e[16] !== e[3][3][16] && (t[2] = !0), null === n ? t[9] = [e] : n.push(e) }(o, e); const a = e[19]; null !== a && a.insertView(t), e[2] |= 128 }(i, n, r, s); const o = Es(s, r), a = n[11], l = vs(a, r[7]); return null !== l && function (t, e, n, i, s, r) { i[0] = s, i[6] = e, Rs(t, i, n, 1, s, r) }(i, r[6], a, n, l, o), t.attachToViewContainerRef(), Zn(Cl(r), s, t), t } move(t, e) { return this.insert(t, e) } indexOf(t) { const e = wl(this._lContainer); return null !== e ? e.indexOf(t) : -1 } remove(t) { const e = this._adjustIndex(t, -1), n = ps(this._lContainer, e); n && (Gn(Cl(this._lContainer), e), fs(n[1], n)) } detach(t) { const e = this._adjustIndex(t, -1), n = ps(this._lContainer, e); return n && null != Gn(Cl(this._lContainer), e) ? new il(n) : null } _adjustIndex(t, e = 0) { return null == t ? this.length + e : t } }; function wl(t) { return t[8] } function Cl(t) { return t[8] || (t[8] = []) } function kl(t, e) { let n; const i = e[t.index]; if (ee(i)) n = i; else { let s; if (8 & t.type) s = _e(i); else { const n = e[11]; s = n.createComment(""); const i = be(t, e); _s(n, vs(n, i), s, function (t, e) { return me(t) ? t.nextSibling(e) : e.nextSibling }(n, i), !1) } e[t.index] = n = Sr(i, e, s, t), Ar(e, n) } return new vl(n, t, e) } const xl = {}; class Sl extends Oa { constructor(t) { super(), this.ngModule = t } resolveComponentFactory(t) { const e = Gt(t); return new Rl(e, this.ngModule) } } function El(t) { const e = []; for (let n in t) t.hasOwnProperty(n) && e.push({ propName: t[n], templateName: n }); return e } const Tl = new $n("SCHEDULER_TOKEN", { providedIn: "root", factory: () => ns }); class Rl extends Ra { constructor(t, e) { super(), this.componentDef = t, this.ngModule = e, this.componentType = t.type, this.selector = t.selectors.map(zs).join(","), this.ngContentSelectors = t.ngContentSelectors ? t.ngContentSelectors : [], this.isBoundToModule = !!e } get inputs() { return El(this.componentDef.inputs) } get outputs() { return El(this.componentDef.outputs) } create(t, e, n, i) { const s = (i = i || this.ngModule) ? function (t, e) { return { get: (n, i, s) => { const r = t.get(n, xl, s); return r !== xl || i === xl ? r : e.get(n, i, s) } } }(t, i.injector) : t, r = s.get(Fa, ge), o = s.get(ja, null), a = r.createRenderer(null, this.componentDef), l = this.componentDef.selectors[0][0] || "div", c = n ? function (t, e, n) { if (me(t)) return t.selectRootElement(e, n === Tt.ShadowDom); let i = "string" == typeof e ? t.querySelector(e) : e; return i.textContent = "", i }(a, n, this.componentDef.encapsulation) : us(r.createRenderer(null, this.componentDef), l, function (t) { const e = t.toLowerCase(); return "svg" === e ? pe : "math" === e ? "http://www.w3.org/1998/MathML/" : null }(l)), h = this.componentDef.onPush ? 576 : 528, u = { components: [], scheduler: ns, clean: Mr, playerHandler: null, flags: 0 }, d = ur(0, null, null, 1, 0, null, null, null, null, null), p = tr(null, d, u, h, null, null, r, a, o, s); let f, m; Ye(p); try { const t = function (t, e, n, i, s, r) { const o = n[1]; n[20] = t; const a = er(o, 20, 2, "#host", null), l = a.mergedAttrs = e.hostAttrs; null !== l && (Br(a, l, !0), null !== t && (dn(s, t, l), null !== a.classes && Is(s, t, a.classes), null !== a.styles && Os(s, t, a.styles))); const c = i.createRenderer(t, e), h = tr(n, hr(e), null, e.onPush ? 64 : 16, n[20], a, i, c, null, null); return o.firstCreatePass && (Tn(kn(a, n), o, e.type), yr(o, a), vr(a, n.length, 1)), Ar(n, h), n[20] = h }(c, this.componentDef, p, r, a); if (c) if (n) dn(a, c, ["ng-version", Ha.full]); else { const { attrs: t, classes: e } = function (t) { const e = [], n = []; let i = 1, s = 2; for (; i < t.length;) { let r = t[i]; if ("string" == typeof r) 2 === s ? "" !== r && e.push(r, t[++i]) : 8 === s && n.push(r); else { if (!Vs(s)) break; s = r } i++ } return { attrs: e, classes: n } }(this.componentDef.selectors[0]); t && dn(a, c, t), e && e.length > 0 && Is(a, c, e.join(" ")) } if (m = ve(d, Xt), void 0 !== e) { const t = m.projection = []; for (let n = 0; n < this.ngContentSelectors.length; n++) { const i = e[n]; t.push(null != i ? Array.from(i) : null) } } f = function (t, e, n, i, s) { const r = n[1], o = function (t, e, n) { const i = De(); t.firstCreatePass && (n.providersResolver && n.providersResolver(n), wr(t, i, e, nr(t, e, 1, null), n)); const s = Nn(e, t, i.directiveStart, i); Gi(s, e); const r = be(i, e); return r && Gi(r, e), s }(r, n, e); if (i.components.push(o), t[8] = o, s && s.forEach(t => t(o, e)), e.contentQueries) { const t = De(); e.contentQueries(1, o, t.directiveStart) } const a = De(); return !r.firstCreatePass || null === e.hostBindings && null === e.hostAttrs || (en(a.index), gr(n[1], a, 0, a.directiveStart, a.directiveEnd, e), _r(e, o)), o }(t, this.componentDef, p, u, [io]), ir(d, p, null) } finally { Je() } return new Al(this.componentType, f, Da(m, p), p, m) } } class Al extends class { }{ constructor(t, e, n, i, s) { super(), this.location = n, this._rootLView = i, this._tNode = s, this.instance = e, this.hostView = this.changeDetectorRef = new sl(i), this.componentType = t } get injector() { return new Vn(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(t) { this.hostView.onDestroy(t) } } const Ol = new Map; class Il extends ml { constructor(t, e) { super(), this._parent = e, this._bootstrapComponents = [], this.injector = this, this.destroyCbs = [], this.componentFactoryResolver = new Sl(this); const n = Qt(t), i = t[jt] || null; i && ba(i), this._bootstrapComponents = is(n.bootstrap), this._r3Injector = Yr(t, e, [{ provide: ml, useValue: this }, { provide: Oa, useValue: this.componentFactoryResolver }], nt(t)), this._r3Injector._resolveInjectorDefTypes(), this.instance = this.get(t) } get(t, e = no.THROW_IF_NOT_FOUND, n = wt.Default) { return t === no || t === ml || t === Hr ? this : this._r3Injector.get(t, e, n) } destroy() { const t = this._r3Injector; !t.destroyed && t.destroy(), this.destroyCbs.forEach(t => t()), this.destroyCbs = null } onDestroy(t) { this.destroyCbs.push(t) } } class Dl extends gl { constructor(t) { super(), this.moduleType = t, null !== Qt(t) && function (t) { const e = new Set; !function t(n) { const i = Qt(n, !0), s = i.id; null !== s && (function (t, e, n) { if (e && e !== n) throw new Error(`Duplicate module registered for ${t} - ${nt(e)} vs ${nt(e.name)}`) }(s, Ol.get(s), n), Ol.set(s, n)); const r = is(i.imports); for (const o of r) e.has(o) || (e.add(o), t(o)) }(t) }(t) } create(t) { return new Il(this.moduleType, t) } } function Pl(t) { return e => { setTimeout(t, void 0, e) } } const Ml = class extends k { constructor(t = !1) { super(), this.__isAsync = t } emit(t) { super.next(t) } subscribe(t, e, n) { var i, s, r; let o = t, a = e || (() => null), l = n; if (t && "object" == typeof t) { const e = t; o = null === (i = e.next) || void 0 === i ? void 0 : i.bind(e), a = null === (s = e.error) || void 0 === s ? void 0 : s.bind(e), l = null === (r = e.complete) || void 0 === r ? void 0 : r.bind(e) } this.__isAsync && (a = Pl(a), o && (o = Pl(o)), l && (l = Pl(l))); const c = super.subscribe({ next: o, error: a, complete: l }); return t instanceof u && t.add(c), c } }; function Nl() { return this._results[ho()]() } class Fl { constructor(t = !1) { this._emitDistinctChangesOnly = t, this.dirty = !0, this._results = [], this._changesDetected = !1, this._changes = null, this.length = 0, this.first = void 0, this.last = void 0; const e = ho(), n = Fl.prototype; n[e] || (n[e] = Nl) } get changes() { return this._changes || (this._changes = new Ml) } get(t) { return this._results[t] } map(t) { return this._results.map(t) } filter(t) { return this._results.filter(t) } find(t) { return this._results.find(t) } reduce(t, e) { return this._results.reduce(t, e) } forEach(t) { this._results.forEach(t) } some(t) { return this._results.some(t) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(t, e) { const n = this; n.dirty = !1; const i = Kn(t); (this._changesDetected = !function (t, e, n) { if (t.length !== e.length) return !1; for (let i = 0; i < t.length; i++) { let s = t[i], r = e[i]; if (n && (s = n(s), r = n(r)), r !== s) return !1 } return !0 }(n._results, i, e)) && (n._results = i, n.length = i.length, n.last = i[this.length - 1], n.first = i[0]) } notifyOnChanges() { !this._changes || !this._changesDetected && this._emitDistinctChangesOnly || this._changes.emit(this) } setDirty() { this.dirty = !0 } destroy() { this.changes.complete(), this.changes.unsubscribe() } } class Ll { constructor(t) { this.queryList = t, this.matches = null } clone() { return new Ll(this.queryList) } setDirty() { this.queryList.setDirty() } } class Vl { constructor(t = []) { this.queries = t } createEmbeddedView(t) { const e = t.queries; if (null !== e) { const n = null !== t.contentQueries ? t.contentQueries[0] : e.length, i = []; for (let t = 0; t < n; t++) { const n = e.getByIndex(t); i.push(this.queries[n.indexInDeclarationView].clone()) } return new Vl(i) } return null } insertView(t) { this.dirtyQueriesWithMatches(t) } detachView(t) { this.dirtyQueriesWithMatches(t) } dirtyQueriesWithMatches(t) { for (let e = 0; e < this.queries.length; e++)null !== Xl(t, e).matches && this.queries[e].setDirty() } } class jl { constructor(t, e, n = null) { this.predicate = t, this.flags = e, this.read = n } } class Bl { constructor(t = []) { this.queries = t } elementStart(t, e) { for (let n = 0; n < this.queries.length; n++)this.queries[n].elementStart(t, e) } elementEnd(t) { for (let e = 0; e < this.queries.length; e++)this.queries[e].elementEnd(t) } embeddedTView(t) { let e = null; for (let n = 0; n < this.length; n++) { const i = null !== e ? e.length : 0, s = this.getByIndex(n).embeddedTView(t, i); s && (s.indexInDeclarationView = n, null !== e ? e.push(s) : e = [s]) } return null !== e ? new Bl(e) : null } template(t, e) { for (let n = 0; n < this.queries.length; n++)this.queries[n].template(t, e) } getByIndex(t) { return this.queries[t] } get length() { return this.queries.length } track(t) { this.queries.push(t) } } class Hl { constructor(t, e = -1) { this.metadata = t, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = e } elementStart(t, e) { this.isApplyingToNode(e) && this.matchTNode(t, e) } elementEnd(t) { this._declarationNodeIndex === t.index && (this._appliesToNextNode = !1) } template(t, e) { this.elementStart(t, e) } embeddedTView(t, e) { return this.isApplyingToNode(t) ? (this.crossesNgTemplate = !0, this.addMatch(-t.index, e), new Hl(this.metadata)) : null } isApplyingToNode(t) { if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) { const e = this._declarationNodeIndex; let n = t.parent; for (; null !== n && 8 & n.type && n.index !== e;)n = n.parent; return e === (null !== n ? n.index : -1) } return this._appliesToNextNode } matchTNode(t, e) { const n = this.metadata.predicate; if (Array.isArray(n)) for (let i = 0; i < n.length; i++) { const s = n[i]; this.matchTNodeWithReadOption(t, e, Ul(e, s)), this.matchTNodeWithReadOption(t, e, Mn(e, t, s, !1, !1)) } else n === ul ? 4 & e.type && this.matchTNodeWithReadOption(t, e, -1) : this.matchTNodeWithReadOption(t, e, Mn(e, t, n, !1, !1)) } matchTNodeWithReadOption(t, e, n) { if (null !== n) { const i = this.metadata.read; if (null !== i) if (i === Ma || i === yl || i === ul && 4 & e.type) this.addMatch(e.index, -2); else { const n = Mn(e, t, i, !1, !1); null !== n && this.addMatch(e.index, n) } else this.addMatch(e.index, n) } } addMatch(t, e) { null === this.matches ? this.matches = [t, e] : this.matches.push(t, e) } } function Ul(t, e) { const n = t.localNames; if (null !== n) for (let i = 0; i < n.length; i += 2)if (n[i] === e) return n[i + 1]; return null } function zl(t, e, n, i) { return -1 === n ? function (t, e) { return 11 & t.type ? Da(t, e) : 4 & t.type ? fl(t, e) : null }(e, t) : -2 === n ? function (t, e, n) { return n === Ma ? Da(e, t) : n === ul ? fl(e, t) : n === yl ? kl(e, t) : void 0 }(t, e, i) : Nn(t, t[1], n, e) } function $l(t, e, n, i) { const s = e[19].queries[i]; if (null === s.matches) { const i = t.data, r = n.matches, o = []; for (let t = 0; t < r.length; t += 2) { const s = r[t]; o.push(s < 0 ? null : zl(e, i[s], r[t + 1], n.metadata.read)) } s.matches = o } return s.matches } function ql(t, e, n, i) { const s = t.queries.getByIndex(n), r = s.matches; if (null !== r) { const o = $l(t, e, s, n); for (let t = 0; t < r.length; t += 2) { const n = r[t]; if (n > 0) i.push(o[t / 2]); else { const s = r[t + 1], o = e[-n]; for (let t = Jt; t < o.length; t++) { const e = o[t]; e[17] === e[3] && ql(e[1], e, s, i) } if (null !== o[9]) { const t = o[9]; for (let e = 0; e < t.length; e++) { const n = t[e]; ql(n[1], n, s, i) } } } } } return i } function Wl(t) { const e = Ae(), n = Oe(), i = $e(); qe(i + 1); const s = Xl(n, i); if (t.dirty && Ce(e) === (2 == (2 & s.metadata.flags))) { if (null === s.matches) t.reset([]); else { const r = s.crossesNgTemplate ? ql(n, e, i, []) : $l(n, e, s, i); t.reset(r, Na), t.notifyOnChanges() } return !0 } return !1 } function Kl(t, e, n) { const i = Oe(); i.firstCreatePass && (Ql(i, new jl(t, e, n), -1), 2 == (2 & e) && (i.staticViewQueries = !0)), Gl(i, Ae(), e) } function Yl(t, e, n, i) { const s = Oe(); if (s.firstCreatePass) { const r = De(); Ql(s, new jl(e, n, i), r.index), function (t, e) { const n = t.contentQueries || (t.contentQueries = []); e !== (n.length ? n[n.length - 1] : -1) && n.push(t.queries.length - 1, e) }(s, t), 2 == (2 & n) && (s.staticContentQueries = !0) } Gl(s, Ae(), n) } function Zl() { return t = Ae(), e = $e(), t[19].queries[e].queryList; var t, e } function Gl(t, e, n) { const i = new Fl(4 == (4 & n)); dr(t, e, i, i.destroy), null === e[19] && (e[19] = new Vl), e[19].queries.push(new Ll(i)) } function Ql(t, e, n) { null === t.queries && (t.queries = new Bl), t.queries.track(new Hl(e, n)) } function Xl(t, e) { return t.queries.getByIndex(e) } const Jl = new $n("Application Initializer"); let tc = (() => { class t { constructor(t) { this.appInits = t, this.resolve = Ia, this.reject = Ia, this.initialized = !1, this.done = !1, this.donePromise = new Promise((t, e) => { this.resolve = t, this.reject = e }) } runInitializers() { if (this.initialized) return; const t = [], e = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let n = 0; n < this.appInits.length; n++) { const e = this.appInits[n](); if (Ao(e)) t.push(e); else if (Oo(e)) { const n = new Promise((t, n) => { e.subscribe({ complete: t, error: n }) }); t.push(n) } } Promise.all(t).then(() => { e() }).catch(t => { this.reject(t) }), 0 === t.length && e(), this.initialized = !0 } } return t.\u0275fac = function (e) { return new (e || t)(li(Jl, 8)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const ec = new $n("AppId"), nc = { provide: ec, useFactory: function () { return `${ic()}${ic()}${ic()}` }, deps: [] }; function ic() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const sc = new $n("Platform Initializer"), rc = new $n("Platform ID"), oc = new $n("appBootstrapListener"); let ac = (() => { class t { log(t) { console.log(t) } warn(t) { console.warn(t) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const lc = new $n("LocaleId"), cc = new $n("DefaultCurrencyCode"); class hc { constructor(t, e) { this.ngModuleFactory = t, this.componentFactories = e } } const uc = function (t) { return new Dl(t) }, dc = uc, pc = function (t) { return Promise.resolve(uc(t)) }, fc = function (t) { const e = uc(t), n = is(Qt(t).declarations).reduce((t, e) => { const n = Gt(e); return n && t.push(new Rl(n)), t }, []); return new hc(e, n) }, mc = fc, gc = function (t) { return Promise.resolve(fc(t)) }; let _c = (() => { class t { constructor() { this.compileModuleSync = dc, this.compileModuleAsync = pc, this.compileModuleAndAllComponentsSync = mc, this.compileModuleAndAllComponentsAsync = gc } clearCache() { } clearCacheFor(t) { } getModuleId(t) { } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const yc = (() => Promise.resolve(0))(); function bc(t) { "undefined" == typeof Zone ? yc.then(() => { t && t.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", t) } class vc { constructor({ enableLongStackTrace: t = !1, shouldCoalesceEventChangeDetection: e = !1, shouldCoalesceRunChangeDetection: n = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new Ml(!1), this.onMicrotaskEmpty = new Ml(!1), this.onStable = new Ml(!1), this.onError = new Ml(!1), "undefined" == typeof Zone) throw new Error("In this configuration Angular requires Zone.js"); Zone.assertZonePatched(); const i = this; i._nesting = 0, i._outer = i._inner = Zone.current, Zone.TaskTrackingZoneSpec && (i._inner = i._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (i._inner = i._inner.fork(Zone.longStackTraceZoneSpec)), i.shouldCoalesceEventChangeDetection = !n && e, i.shouldCoalesceRunChangeDetection = n, i.lastRequestAnimationFrameId = -1, i.nativeRequestAnimationFrame = function () { let t = Dt.requestAnimationFrame, e = Dt.cancelAnimationFrame; if ("undefined" != typeof Zone && t && e) { const n = t[Zone.__symbol__("OriginalDelegate")]; n && (t = n); const i = e[Zone.__symbol__("OriginalDelegate")]; i && (e = i) } return { nativeRequestAnimationFrame: t, nativeCancelAnimationFrame: e } }().nativeRequestAnimationFrame, function (t) { const e = () => { !function (t) { t.isCheckStableRunning || -1 !== t.lastRequestAnimationFrameId || (t.lastRequestAnimationFrameId = t.nativeRequestAnimationFrame.call(Dt, () => { t.fakeTopEventTask || (t.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { t.lastRequestAnimationFrameId = -1, kc(t), t.isCheckStableRunning = !0, Cc(t), t.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), t.fakeTopEventTask.invoke() }), kc(t)) }(t) }; t._inner = t._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (n, i, s, r, o, a) => { try { return xc(t), n.invokeTask(s, r, o, a) } finally { (t.shouldCoalesceEventChangeDetection && "eventTask" === r.type || t.shouldCoalesceRunChangeDetection) && e(), Sc(t) } }, onInvoke: (n, i, s, r, o, a, l) => { try { return xc(t), n.invoke(s, r, o, a, l) } finally { t.shouldCoalesceRunChangeDetection && e(), Sc(t) } }, onHasTask: (e, n, i, s) => { e.hasTask(i, s), n === i && ("microTask" == s.change ? (t._hasPendingMicrotasks = s.microTask, kc(t), Cc(t)) : "macroTask" == s.change && (t.hasPendingMacrotasks = s.macroTask)) }, onHandleError: (e, n, i, s) => (e.handleError(i, s), t.runOutsideAngular(() => t.onError.emit(s)), !1) }) }(i) } static isInAngularZone() { return !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!vc.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!") } static assertNotInAngularZone() { if (vc.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!") } run(t, e, n) { return this._inner.run(t, e, n) } runTask(t, e, n, i) { const s = this._inner, r = s.scheduleEventTask("NgZoneEvent: " + i, t, wc, Ia, Ia); try { return s.runTask(r, e, n) } finally { s.cancelTask(r) } } runGuarded(t, e, n) { return this._inner.runGuarded(t, e, n) } runOutsideAngular(t) { return this._outer.run(t) } } const wc = {}; function Cc(t) { if (0 == t._nesting && !t.hasPendingMicrotasks && !t.isStable) try { t._nesting++, t.onMicrotaskEmpty.emit(null) } finally { if (t._nesting--, !t.hasPendingMicrotasks) try { t.runOutsideAngular(() => t.onStable.emit(null)) } finally { t.isStable = !0 } } } function kc(t) { t.hasPendingMicrotasks = !!(t._hasPendingMicrotasks || (t.shouldCoalesceEventChangeDetection || t.shouldCoalesceRunChangeDetection) && -1 !== t.lastRequestAnimationFrameId) } function xc(t) { t._nesting++, t.isStable && (t.isStable = !1, t.onUnstable.emit(null)) } function Sc(t) { t._nesting--, Cc(t) } class Ec { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new Ml, this.onMicrotaskEmpty = new Ml, this.onStable = new Ml, this.onError = new Ml } run(t, e, n) { return t.apply(e, n) } runGuarded(t, e, n) { return t.apply(e, n) } runOutsideAngular(t) { return t() } runTask(t, e, n, i) { return t.apply(e, n) } } let Tc = (() => { class t { constructor(t) { this._ngZone = t, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, this._watchAngularEvents(), t.run(() => { this.taskTrackingZone = "undefined" == typeof Zone ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { vc.assertNotInAngularZone(), bc(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) bc(() => { for (; 0 !== this._callbacks.length;) { let t = this._callbacks.pop(); clearTimeout(t.timeoutId), t.doneCb(this._didWork) } this._didWork = !1 }); else { let t = this.getPendingTasks(); this._callbacks = this._callbacks.filter(e => !e.updateCb || !e.updateCb(t) || (clearTimeout(e.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(t => ({ source: t.source, creationLocation: t.creationLocation, data: t.data })) : [] } addCallback(t, e, n) { let i = -1; e && e > 0 && (i = setTimeout(() => { this._callbacks = this._callbacks.filter(t => t.timeoutId !== i), t(this._didWork, this.getPendingTasks()) }, e)), this._callbacks.push({ doneCb: t, timeoutId: i, updateCb: n }) } whenStable(t, e, n) { if (n && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(t, e, n), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } findProviders(t, e, n) { return [] } } return t.\u0275fac = function (e) { return new (e || t)(li(vc)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), Rc = (() => { class t { constructor() { this._applications = new Map, Ic.addToWindow(this) } registerApplication(t, e) { this._applications.set(t, e) } unregisterApplication(t) { this._applications.delete(t) } unregisterAllApplications() { this._applications.clear() } getTestability(t) { return this._applications.get(t) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(t, e = !0) { return Ic.findTestabilityInTree(this, t, e) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); class Ac { addToWindow(t) { } findTestabilityInTree(t, e, n) { return null } } let Oc, Ic = new Ac, Dc = !0, Pc = !1; function Mc() { return Pc = !0, Dc } const Nc = new $n("AllowMultipleToken"); class Fc { constructor(t, e) { this.name = t, this.token = e } } function Lc(t, e, n = []) { const i = `Platform: ${e}`, s = new $n(i); return (e = []) => { let r = Vc(); if (!r || r.injector.get(Nc, !1)) if (t) t(n.concat(e).concat({ provide: s, useValue: !0 })); else { const t = n.concat(e).concat({ provide: s, useValue: !0 }, { provide: zr, useValue: "platform" }); !function (t) { if (Oc && !Oc.destroyed && !Oc.injector.get(Nc, !1)) throw new Error("There can be only one platform. Destroy the previous one to create a new one."); Oc = t.get(jc); const e = t.get(sc, null); e && e.forEach(t => t()) }(no.create({ providers: t, name: i })) } return function (t) { const e = Vc(); if (!e) throw new Error("No platform exists!"); if (!e.injector.get(t, null)) throw new Error("A platform with a different configuration has been created. Please destroy it first."); return e }(s) } } function Vc() { return Oc && !Oc.destroyed ? Oc : null } let jc = (() => { class t { constructor(t) { this._injector = t, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(t, e) { const n = function (t, e) { let n; return n = "noop" === t ? new Ec : ("zone.js" === t ? void 0 : t) || new vc({ enableLongStackTrace: Mc(), shouldCoalesceEventChangeDetection: !!(null == e ? void 0 : e.ngZoneEventCoalescing), shouldCoalesceRunChangeDetection: !!(null == e ? void 0 : e.ngZoneRunCoalescing) }), n }(e ? e.ngZone : void 0, { ngZoneEventCoalescing: e && e.ngZoneEventCoalescing || !1, ngZoneRunCoalescing: e && e.ngZoneRunCoalescing || !1 }), i = [{ provide: vc, useValue: n }]; return n.run(() => { const e = no.create({ providers: i, parent: this.injector, name: t.moduleType.name }), s = t.create(e), r = s.injector.get(es, null); if (!r) throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?"); return n.runOutsideAngular(() => { const t = n.onError.subscribe({ next: t => { r.handleError(t) } }); s.onDestroy(() => { Uc(this._modules, s), t.unsubscribe() }) }), function (t, e, n) { try { const i = n(); return Ao(i) ? i.catch(n => { throw e.runOutsideAngular(() => t.handleError(n)), n }) : i } catch (i) { throw e.runOutsideAngular(() => t.handleError(i)), i } }(r, n, () => { const t = s.injector.get(tc); return t.runInitializers(), t.donePromise.then(() => (ba(s.injector.get(lc, _a) || _a), this._moduleDoBootstrap(s), s)) }) }) } bootstrapModule(t, e = []) { const n = Bc({}, e); return function (t, e, n) { const i = new Dl(n); return Promise.resolve(i) }(0, 0, t).then(t => this.bootstrapModuleFactory(t, n)) } _moduleDoBootstrap(t) { const e = t.injector.get(Hc); if (t._bootstrapComponents.length > 0) t._bootstrapComponents.forEach(t => e.bootstrap(t)); else { if (!t.instance.ngDoBootstrap) throw new Error(`The module ${nt(t.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`); t.instance.ngDoBootstrap(e) } this._modules.push(t) } onDestroy(t) { this._destroyListeners.push(t) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new Error("The platform has already been destroyed!"); this._modules.slice().forEach(t => t.destroy()), this._destroyListeners.forEach(t => t()), this._destroyed = !0 } get destroyed() { return this._destroyed } } return t.\u0275fac = function (e) { return new (e || t)(li(no)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); function Bc(t, e) { return Array.isArray(e) ? e.reduce(Bc, t) : Object.assign(Object.assign({}, t), e) } let Hc = (() => { class t { constructor(t, e, n, i, s) { this._zone = t, this._injector = e, this._exceptionHandler = n, this._componentFactoryResolver = i, this._initStatus = s, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const r = new y(t => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { t.next(this._stable), t.complete() }) }), o = new y(t => { let e; this._zone.runOutsideAngular(() => { e = this._zone.onStable.subscribe(() => { vc.assertNotInAngularZone(), bc(() => { this._stable || this._zone.hasPendingMacrotasks || this._zone.hasPendingMicrotasks || (this._stable = !0, t.next(!0)) }) }) }); const n = this._zone.onUnstable.subscribe(() => { vc.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { t.next(!1) })) }); return () => { e.unsubscribe(), n.unsubscribe() } }); this.isStable = q(r, o.pipe(J())) } bootstrap(t, e) { if (!this._initStatus.done) throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module."); let n; n = t instanceof Ra ? t : this._componentFactoryResolver.resolveComponentFactory(t), this.componentTypes.push(n.componentType); const i = n.isBoundToModule ? void 0 : this._injector.get(ml), s = n.create(no.NULL, [], e || n.selector, i), r = s.location.nativeElement, o = s.injector.get(Tc, null), a = o && s.injector.get(Rc); return o && a && a.registerApplication(r, o), s.onDestroy(() => { this.detachView(s.hostView), Uc(this.components, s), a && a.unregisterApplication(r) }), this._loadComponent(s), s } tick() { if (this._runningTick) throw new Error("ApplicationRef.tick is called recursively"); try { this._runningTick = !0; for (let t of this._views) t.detectChanges() } catch (t) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(t)) } finally { this._runningTick = !1 } } attachView(t) { const e = t; this._views.push(e), e.attachToAppRef(this) } detachView(t) { const e = t; Uc(this._views, e), e.detachFromAppRef() } _loadComponent(t) { this.attachView(t.hostView), this.tick(), this.components.push(t), this._injector.get(oc, []).concat(this._bootstrapListeners).forEach(e => e(t)) } ngOnDestroy() { this._views.slice().forEach(t => t.destroy()), this._onMicrotaskEmptySubscription.unsubscribe() } get viewCount() { return this._views.length } } return t.\u0275fac = function (e) { return new (e || t)(li(vc), li(no), li(es), li(Oa), li(tc)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); function Uc(t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) } class zc { } class $c { } const qc = { factoryPathPrefix: "", factoryPathSuffix: ".ngfactory" }; let Wc = (() => { class t { constructor(t, e) { this._compiler = t, this._config = e || qc } load(t) { return this.loadAndCompile(t) } loadAndCompile(t) { let [e, i] = t.split("#"); return void 0 === i && (i = "default"), n(255)(e).then(t => t[i]).then(t => Kc(t, e, i)).then(t => this._compiler.compileModuleAsync(t)) } loadFactory(t) { let [e, i] = t.split("#"), s = "NgFactory"; return void 0 === i && (i = "default", s = ""), n(255)(this._config.factoryPathPrefix + e + this._config.factoryPathSuffix).then(t => t[i + s]).then(t => Kc(t, e, i)) } } return t.\u0275fac = function (e) { return new (e || t)(li(_c), li($c, 8)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); function Kc(t, e, n) { if (!t) throw new Error(`Cannot find '${n}' in '${e}'`); return t } const Yc = Lc(null, "core", [{ provide: rc, useValue: "unknown" }, { provide: jc, deps: [no] }, { provide: Rc, deps: [] }, { provide: ac, deps: [] }]), Zc = [{ provide: Hc, useClass: Hc, deps: [vc, no, es, Oa, tc] }, { provide: Tl, deps: [vc], useFactory: function (t) { let e = []; return t.onStable.subscribe(() => { for (; e.length;)e.pop()() }), function (t) { e.push(t) } } }, { provide: tc, useClass: tc, deps: [[new pi, Jl]] }, { provide: _c, useClass: _c, deps: [] }, nc, { provide: Ja, useFactory: function () { return ll }, deps: [] }, { provide: el, useFactory: function () { return cl }, deps: [] }, { provide: lc, useFactory: function (t) { return ba(t = t || "undefined" != typeof $localize && $localize.locale || _a), t }, deps: [[new di(lc), new pi, new fi]] }, { provide: cc, useValue: "USD" }]; let Gc = (() => { class t { constructor(t) { } } return t.\u0275fac = function (e) { return new (e || t)(li(Hc)) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ providers: Zc }), t })(), Qc = null; function Xc() { return Qc } const Jc = new $n("DocumentToken"); let th = (() => { class t { historyGo(t) { throw new Error("Not implemented") } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ factory: eh, token: t, providedIn: "platform" }), t })(); function eh() { return li(ih) } const nh = new $n("Location Initialized"); let ih = (() => { class t extends th { constructor(t) { super(), this._doc = t, this._init() } _init() { this.location = window.location, this._history = window.history } getBaseHrefFromDOM() { return Xc().getBaseHref(this._doc) } onPopState(t) { const e = Xc().getGlobalEventTarget(this._doc, "window"); return e.addEventListener("popstate", t, !1), () => e.removeEventListener("popstate", t) } onHashChange(t) { const e = Xc().getGlobalEventTarget(this._doc, "window"); return e.addEventListener("hashchange", t, !1), () => e.removeEventListener("hashchange", t) } get href() { return this.location.href } get protocol() { return this.location.protocol } get hostname() { return this.location.hostname } get port() { return this.location.port } get pathname() { return this.location.pathname } get search() { return this.location.search } get hash() { return this.location.hash } set pathname(t) { this.location.pathname = t } pushState(t, e, n) { sh() ? this._history.pushState(t, e, n) : this.location.hash = n } replaceState(t, e, n) { sh() ? this._history.replaceState(t, e, n) : this.location.hash = n } forward() { this._history.forward() } back() { this._history.back() } historyGo(t = 0) { this._history.go(t) } getState() { return this._history.state } } return t.\u0275fac = function (e) { return new (e || t)(li(Jc)) }, t.\u0275prov = dt({ factory: rh, token: t, providedIn: "platform" }), t })(); function sh() { return !!window.history.pushState } function rh() { return new ih(li(Jc)) } function oh(t, e) { if (0 == t.length) return e; if (0 == e.length) return t; let n = 0; return t.endsWith("/") && n++, e.startsWith("/") && n++, 2 == n ? t + e.substring(1) : 1 == n ? t + e : t + "/" + e } function ah(t) { const e = t.match(/#|\?|$/), n = e && e.index || t.length; return t.slice(0, n - ("/" === t[n - 1] ? 1 : 0)) + t.slice(n) } function lh(t) { return t && "?" !== t[0] ? "?" + t : t } let ch = (() => { class t { historyGo(t) { throw new Error("Not implemented") } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ factory: hh, token: t, providedIn: "root" }), t })(); function hh(t) { const e = li(Jc).location; return new dh(li(th), e && e.origin || "") } const uh = new $n("appBaseHref"); let dh = (() => { class t extends ch { constructor(t, e) { if (super(), this._platformLocation = t, this._removeListenerFns = [], null == e && (e = this._platformLocation.getBaseHrefFromDOM()), null == e) throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document."); this._baseHref = e } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(t) { this._removeListenerFns.push(this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t)) } getBaseHref() { return this._baseHref } prepareExternalUrl(t) { return oh(this._baseHref, t) } path(t = !1) { const e = this._platformLocation.pathname + lh(this._platformLocation.search), n = this._platformLocation.hash; return n && t ? `${e}${n}` : e } pushState(t, e, n, i) { const s = this.prepareExternalUrl(n + lh(i)); this._platformLocation.pushState(t, e, s) } replaceState(t, e, n, i) { const s = this.prepareExternalUrl(n + lh(i)); this._platformLocation.replaceState(t, e, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } historyGo(t = 0) { var e, n; null === (n = (e = this._platformLocation).historyGo) || void 0 === n || n.call(e, t) } } return t.\u0275fac = function (e) { return new (e || t)(li(th), li(uh, 8)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), ph = (() => { class t extends ch { constructor(t, e) { super(), this._platformLocation = t, this._baseHref = "", this._removeListenerFns = [], null != e && (this._baseHref = e) } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(t) { this._removeListenerFns.push(this._platformLocation.onPopState(t), this._platformLocation.onHashChange(t)) } getBaseHref() { return this._baseHref } path(t = !1) { let e = this._platformLocation.hash; return null == e && (e = "#"), e.length > 0 ? e.substring(1) : e } prepareExternalUrl(t) { const e = oh(this._baseHref, t); return e.length > 0 ? "#" + e : e } pushState(t, e, n, i) { let s = this.prepareExternalUrl(n + lh(i)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.pushState(t, e, s) } replaceState(t, e, n, i) { let s = this.prepareExternalUrl(n + lh(i)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.replaceState(t, e, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } historyGo(t = 0) { var e, n; null === (n = (e = this._platformLocation).historyGo) || void 0 === n || n.call(e, t) } } return t.\u0275fac = function (e) { return new (e || t)(li(th), li(uh, 8)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), fh = (() => { class t { constructor(t, e) { this._subject = new Ml, this._urlChangeListeners = [], this._platformStrategy = t; const n = this._platformStrategy.getBaseHref(); this._platformLocation = e, this._baseHref = ah(gh(n)), this._platformStrategy.onPopState(t => { this._subject.emit({ url: this.path(!0), pop: !0, state: t.state, type: t.type }) }) } path(t = !1) { return this.normalize(this._platformStrategy.path(t)) } getState() { return this._platformLocation.getState() } isCurrentPathEqualTo(t, e = "") { return this.path() == this.normalize(t + lh(e)) } normalize(e) { return t.stripTrailingSlash(function (t, e) { return t && e.startsWith(t) ? e.substring(t.length) : e }(this._baseHref, gh(e))) } prepareExternalUrl(t) { return t && "/" !== t[0] && (t = "/" + t), this._platformStrategy.prepareExternalUrl(t) } go(t, e = "", n = null) { this._platformStrategy.pushState(n, "", t, e), this._notifyUrlChangeListeners(this.prepareExternalUrl(t + lh(e)), n) } replaceState(t, e = "", n = null) { this._platformStrategy.replaceState(n, "", t, e), this._notifyUrlChangeListeners(this.prepareExternalUrl(t + lh(e)), n) } forward() { this._platformStrategy.forward() } back() { this._platformStrategy.back() } historyGo(t = 0) { var e, n; null === (n = (e = this._platformStrategy).historyGo) || void 0 === n || n.call(e, t) } onUrlChange(t) { this._urlChangeListeners.push(t), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(t => { this._notifyUrlChangeListeners(t.url, t.state) })) } _notifyUrlChangeListeners(t = "", e) { this._urlChangeListeners.forEach(n => n(t, e)) } subscribe(t, e, n) { return this._subject.subscribe({ next: t, error: e, complete: n }) } } return t.\u0275fac = function (e) { return new (e || t)(li(ch), li(th)) }, t.normalizeQueryParams = lh, t.joinWithSlash = oh, t.stripTrailingSlash = ah, t.\u0275prov = dt({ factory: mh, token: t, providedIn: "root" }), t })(); function mh() { return new fh(li(ch), li(th)) } function gh(t) { return t.replace(/\/index.html$/, "") } var _h = function (t) { return t[t.Zero = 0] = "Zero", t[t.One = 1] = "One", t[t.Two = 2] = "Two", t[t.Few = 3] = "Few", t[t.Many = 4] = "Many", t[t.Other = 5] = "Other", t }({}); class yh { } let bh = (() => { class t extends yh { constructor(t) { super(), this.locale = t } getPluralCategory(t, e) { switch (function (t) { return function (t) { const e = function (t) { return t.toLowerCase().replace(/_/g, "-") }(t); let n = ma(e); if (n) return n; const i = e.split("-")[0]; if (n = ma(i), n) return n; if ("en" === i) return pa; throw new Error(`Missing locale data for the locale "${t}".`) }(t)[ga.PluralCase] }(e || this.locale)(t)) { case _h.Zero: return "zero"; case _h.One: return "one"; case _h.Two: return "two"; case _h.Few: return "few"; case _h.Many: return "many"; default: return "other" } } } return t.\u0275fac = function (e) { return new (e || t)(li(lc)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); function vh(t, e) { e = encodeURIComponent(e); for (const n of t.split(";")) { const t = n.indexOf("="), [i, s] = -1 == t ? [n, ""] : [n.slice(0, t), n.slice(t + 1)]; if (i.trim() === e) return decodeURIComponent(s) } return null } let wh = (() => { class t { constructor(t, e, n, i) { this._iterableDiffers = t, this._keyValueDiffers = e, this._ngEl = n, this._renderer = i, this._iterableDiffer = null, this._keyValueDiffer = null, this._initialClasses = [], this._rawClass = null } set klass(t) { this._removeClasses(this._initialClasses), this._initialClasses = "string" == typeof t ? t.split(/\s+/) : [], this._applyClasses(this._initialClasses), this._applyClasses(this._rawClass) } set ngClass(t) { this._removeClasses(this._rawClass), this._applyClasses(this._initialClasses), this._iterableDiffer = null, this._keyValueDiffer = null, this._rawClass = "string" == typeof t ? t.split(/\s+/) : t, this._rawClass && (uo(this._rawClass) ? this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create() : this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create()) } ngDoCheck() { if (this._iterableDiffer) { const t = this._iterableDiffer.diff(this._rawClass); t && this._applyIterableChanges(t) } else if (this._keyValueDiffer) { const t = this._keyValueDiffer.diff(this._rawClass); t && this._applyKeyValueChanges(t) } } _applyKeyValueChanges(t) { t.forEachAddedItem(t => this._toggleClass(t.key, t.currentValue)), t.forEachChangedItem(t => this._toggleClass(t.key, t.currentValue)), t.forEachRemovedItem(t => { t.previousValue && this._toggleClass(t.key, !1) }) } _applyIterableChanges(t) { t.forEachAddedItem(t => { if ("string" != typeof t.item) throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${nt(t.item)}`); this._toggleClass(t.item, !0) }), t.forEachRemovedItem(t => this._toggleClass(t.item, !1)) } _applyClasses(t) { t && (Array.isArray(t) || t instanceof Set ? t.forEach(t => this._toggleClass(t, !0)) : Object.keys(t).forEach(e => this._toggleClass(e, !!t[e]))) } _removeClasses(t) { t && (Array.isArray(t) || t instanceof Set ? t.forEach(t => this._toggleClass(t, !1)) : Object.keys(t).forEach(t => this._toggleClass(t, !1))) } _toggleClass(t, e) { (t = t.trim()) && t.split(/\s+/g).forEach(t => { e ? this._renderer.addClass(this._ngEl.nativeElement, t) : this._renderer.removeClass(this._ngEl.nativeElement, t) }) } } return t.\u0275fac = function (e) { return new (e || t)(bo(Ja), bo(el), bo(Ma), bo(La)) }, t.\u0275dir = Zt({ type: t, selectors: [["", "ngClass", ""]], inputs: { klass: ["class", "klass"], ngClass: "ngClass" } }), t })(), Ch = (() => { class t { constructor(t, e) { this._viewContainer = t, this._context = new kh, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = e } set ngIf(t) { this._context.$implicit = this._context.ngIf = t, this._updateView() } set ngIfThen(t) { xh("ngIfThen", t), this._thenTemplateRef = t, this._thenViewRef = null, this._updateView() } set ngIfElse(t) { xh("ngIfElse", t), this._elseTemplateRef = t, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngTemplateContextGuard(t, e) { return !0 } } return t.\u0275fac = function (e) { return new (e || t)(bo(yl), bo(ul)) }, t.\u0275dir = Zt({ type: t, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" } }), t })(); class kh { constructor() { this.$implicit = null, this.ngIf = null } } function xh(t, e) { if (e && !e.createEmbeddedView) throw new Error(`${t} must be a TemplateRef, but received '${nt(e)}'.`) } class Sh { constructor(t, e) { this._viewContainerRef = t, this._templateRef = e, this._created = !1 } create() { this._created = !0, this._viewContainerRef.createEmbeddedView(this._templateRef) } destroy() { this._created = !1, this._viewContainerRef.clear() } enforceState(t) { t && !this._created ? this.create() : !t && this._created && this.destroy() } } let Eh = (() => { class t { constructor() { this._defaultUsed = !1, this._caseCount = 0, this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1 } set ngSwitch(t) { this._ngSwitch = t, 0 === this._caseCount && this._updateDefaultCases(!0) } _addCase() { return this._caseCount++ } _addDefault(t) { this._defaultViews || (this._defaultViews = []), this._defaultViews.push(t) } _matchCase(t) { const e = t == this._ngSwitch; return this._lastCasesMatched = this._lastCasesMatched || e, this._lastCaseCheckIndex++, this._lastCaseCheckIndex === this._caseCount && (this._updateDefaultCases(!this._lastCasesMatched), this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1), e } _updateDefaultCases(t) { if (this._defaultViews && t !== this._defaultUsed) { this._defaultUsed = t; for (let e = 0; e < this._defaultViews.length; e++)this._defaultViews[e].enforceState(t) } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = Zt({ type: t, selectors: [["", "ngSwitch", ""]], inputs: { ngSwitch: "ngSwitch" } }), t })(), Th = (() => { class t { constructor(t, e, n) { this.ngSwitch = n, n._addCase(), this._view = new Sh(t, e) } ngDoCheck() { this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase)) } } return t.\u0275fac = function (e) { return new (e || t)(bo(yl), bo(ul), bo(Eh, 9)) }, t.\u0275dir = Zt({ type: t, selectors: [["", "ngSwitchCase", ""]], inputs: { ngSwitchCase: "ngSwitchCase" } }), t })(), Rh = (() => { class t { constructor(t, e, n) { n._addDefault(new Sh(t, e)) } } return t.\u0275fac = function (e) { return new (e || t)(bo(yl), bo(ul), bo(Eh, 9)) }, t.\u0275dir = Zt({ type: t, selectors: [["", "ngSwitchDefault", ""]] }), t })(), Ah = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ providers: [{ provide: yh, useClass: bh }] }), t })(), Oh = (() => { class t { } return t.\u0275prov = dt({ token: t, providedIn: "root", factory: () => new Ih(li(Jc), window) }), t })(); class Ih { constructor(t, e) { this.document = t, this.window = e, this.offset = () => [0, 0] } setOffset(t) { this.offset = Array.isArray(t) ? () => t : t } getScrollPosition() { return this.supportsScrolling() ? [this.window.pageXOffset, this.window.pageYOffset] : [0, 0] } scrollToPosition(t) { this.supportsScrolling() && this.window.scrollTo(t[0], t[1]) } scrollToAnchor(t) { if (!this.supportsScrolling()) return; const e = function (t, e) { const n = t.getElementById(e) || t.getElementsByName(e)[0]; if (n) return n; if ("function" == typeof t.createTreeWalker && t.body && (t.body.createShadowRoot || t.body.attachShadow)) { const n = t.createTreeWalker(t.body, NodeFilter.SHOW_ELEMENT); let i = n.currentNode; for (; i;) { const t = i.shadowRoot; if (t) { const n = t.getElementById(e) || t.querySelector(`[name="${e}"]`); if (n) return n } i = n.nextNode() } } return null }(this.document, t); e && (this.scrollToElement(e), this.attemptFocus(e)) } setHistoryScrollRestoration(t) { if (this.supportScrollRestoration()) { const e = this.window.history; e && e.scrollRestoration && (e.scrollRestoration = t) } } scrollToElement(t) { const e = t.getBoundingClientRect(), n = e.left + this.window.pageXOffset, i = e.top + this.window.pageYOffset, s = this.offset(); this.window.scrollTo(n - s[0], i - s[1]) } attemptFocus(t) { return t.focus(), this.document.activeElement === t } supportScrollRestoration() { try { if (!this.supportsScrolling()) return !1; const t = Dh(this.window.history) || Dh(Object.getPrototypeOf(this.window.history)); return !(!t || !t.writable && !t.set) } catch (t) { return !1 } } supportsScrolling() { try { return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window } catch (t) { return !1 } } } function Dh(t) { return Object.getOwnPropertyDescriptor(t, "scrollRestoration") } class Ph { } class Mh extends class extends class { }{ constructor() { super(...arguments), this.supportsDOMEvents = !0 } }{ static makeCurrent() { var t; t = new Mh, Qc || (Qc = t) } onAndCancel(t, e, n) { return t.addEventListener(e, n, !1), () => { t.removeEventListener(e, n, !1) } } dispatchEvent(t, e) { t.dispatchEvent(e) } remove(t) { t.parentNode && t.parentNode.removeChild(t) } createElement(t, e) { return (e = e || this.getDefaultDocument()).createElement(t) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } isShadowRoot(t) { return t instanceof DocumentFragment } getGlobalEventTarget(t, e) { return "window" === e ? window : "document" === e ? t : "body" === e ? t.body : null } getBaseHref(t) { const e = (Fh = Fh || document.querySelector("base"), Fh ? Fh.getAttribute("href") : null); return null == e ? null : function (t) { Nh = Nh || document.createElement("a"), Nh.setAttribute("href", t); const e = Nh.pathname; return "/" === e.charAt(0) ? e : `/${e}` }(e) } resetBaseElement() { Fh = null } getUserAgent() { return window.navigator.userAgent } getCookie(t) { return vh(document.cookie, t) } } let Nh, Fh = null; const Lh = new $n("TRANSITION_ID"), Vh = [{ provide: Jl, useFactory: function (t, e, n) { return () => { n.get(tc).donePromise.then(() => { const n = Xc(); Array.prototype.slice.apply(e.querySelectorAll("style[ng-transition]")).filter(e => e.getAttribute("ng-transition") === t).forEach(t => n.remove(t)) }) } }, deps: [Lh, Jc, no], multi: !0 }]; class jh { static init() { var t; t = new jh, Ic = t } addToWindow(t) { Dt.getAngularTestability = (e, n = !0) => { const i = t.findTestabilityInTree(e, n); if (null == i) throw new Error("Could not find testability for element."); return i }, Dt.getAllAngularTestabilities = () => t.getAllTestabilities(), Dt.getAllAngularRootElements = () => t.getAllRootElements(), Dt.frameworkStabilizers || (Dt.frameworkStabilizers = []), Dt.frameworkStabilizers.push(t => { const e = Dt.getAllAngularTestabilities(); let n = e.length, i = !1; const s = function (e) { i = i || e, n--, 0 == n && t(i) }; e.forEach(function (t) { t.whenStable(s) }) }) } findTestabilityInTree(t, e, n) { if (null == e) return null; const i = t.getTestability(e); return null != i ? i : n ? Xc().isShadowRoot(e) ? this.findTestabilityInTree(t, e.host, !0) : this.findTestabilityInTree(t, e.parentElement, !0) : null } } let Bh = (() => { class t { build() { return new XMLHttpRequest } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const Hh = new $n("EventManagerPlugins"); let Uh = (() => { class t { constructor(t, e) { this._zone = e, this._eventNameToPlugin = new Map, t.forEach(t => t.manager = this), this._plugins = t.slice().reverse() } addEventListener(t, e, n) { return this._findPluginFor(e).addEventListener(t, e, n) } addGlobalEventListener(t, e, n) { return this._findPluginFor(e).addGlobalEventListener(t, e, n) } getZone() { return this._zone } _findPluginFor(t) { const e = this._eventNameToPlugin.get(t); if (e) return e; const n = this._plugins; for (let i = 0; i < n.length; i++) { const e = n[i]; if (e.supports(t)) return this._eventNameToPlugin.set(t, e), e } throw new Error(`No event manager plugin found for event ${t}`) } } return t.\u0275fac = function (e) { return new (e || t)(li(Hh), li(vc)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); class zh { constructor(t) { this._doc = t } addGlobalEventListener(t, e, n) { const i = Xc().getGlobalEventTarget(this._doc, t); if (!i) throw new Error(`Unsupported event target ${i} for event ${e}`); return this.addEventListener(i, e, n) } } let $h = (() => { class t { constructor() { this._stylesSet = new Set } addStyles(t) { const e = new Set; t.forEach(t => { this._stylesSet.has(t) || (this._stylesSet.add(t), e.add(t)) }), this.onStylesAdded(e) } onStylesAdded(t) { } getAllStyles() { return Array.from(this._stylesSet) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), qh = (() => { class t extends $h { constructor(t) { super(), this._doc = t, this._hostNodes = new Map, this._hostNodes.set(t.head, []) } _addStylesToHost(t, e, n) { t.forEach(t => { const i = this._doc.createElement("style"); i.textContent = t, n.push(e.appendChild(i)) }) } addHost(t) { const e = []; this._addStylesToHost(this._stylesSet, t, e), this._hostNodes.set(t, e) } removeHost(t) { const e = this._hostNodes.get(t); e && e.forEach(Wh), this._hostNodes.delete(t) } onStylesAdded(t) { this._hostNodes.forEach((e, n) => { this._addStylesToHost(t, n, e) }) } ngOnDestroy() { this._hostNodes.forEach(t => t.forEach(Wh)) } } return t.\u0275fac = function (e) { return new (e || t)(li(Jc)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); function Wh(t) { Xc().remove(t) } const Kh = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" }, Yh = /%COMP%/g; function Zh(t, e, n) { for (let i = 0; i < e.length; i++) { let s = e[i]; Array.isArray(s) ? Zh(t, s, n) : (s = s.replace(Yh, t), n.push(s)) } return n } function Gh(t) { return e => { if ("__ngUnwrap__" === e) return t; !1 === t(e) && (e.preventDefault(), e.returnValue = !1) } } let Qh = (() => { class t { constructor(t, e, n) { this.eventManager = t, this.sharedStylesHost = e, this.appId = n, this.rendererByCompId = new Map, this.defaultRenderer = new Xh(t) } createRenderer(t, e) { if (!t || !e) return this.defaultRenderer; switch (e.encapsulation) { case Tt.Emulated: { let n = this.rendererByCompId.get(e.id); return n || (n = new Jh(this.eventManager, this.sharedStylesHost, e, this.appId), this.rendererByCompId.set(e.id, n)), n.applyToHost(t), n } case 1: case Tt.ShadowDom: return new tu(this.eventManager, this.sharedStylesHost, t, e); default: if (!this.rendererByCompId.has(e.id)) { const t = Zh(e.id, e.styles, []); this.sharedStylesHost.addStyles(t), this.rendererByCompId.set(e.id, this.defaultRenderer) } return this.defaultRenderer } } begin() { } end() { } } return t.\u0275fac = function (e) { return new (e || t)(li(Uh), li(qh), li(ec)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); class Xh { constructor(t) { this.eventManager = t, this.data = Object.create(null) } destroy() { } createElement(t, e) { return e ? document.createElementNS(Kh[e] || e, t) : document.createElement(t) } createComment(t) { return document.createComment(t) } createText(t) { return document.createTextNode(t) } appendChild(t, e) { t.appendChild(e) } insertBefore(t, e, n) { t && t.insertBefore(e, n) } removeChild(t, e) { t && t.removeChild(e) } selectRootElement(t, e) { let n = "string" == typeof t ? document.querySelector(t) : t; if (!n) throw new Error(`The selector "${t}" did not match any elements`); return e || (n.textContent = ""), n } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, e, n, i) { if (i) { e = i + ":" + e; const s = Kh[i]; s ? t.setAttributeNS(s, e, n) : t.setAttribute(e, n) } else t.setAttribute(e, n) } removeAttribute(t, e, n) { if (n) { const i = Kh[n]; i ? t.removeAttributeNS(i, e) : t.removeAttribute(`${n}:${e}`) } else t.removeAttribute(e) } addClass(t, e) { t.classList.add(e) } removeClass(t, e) { t.classList.remove(e) } setStyle(t, e, n, i) { i & (ss.DashCase | ss.Important) ? t.style.setProperty(e, n, i & ss.Important ? "important" : "") : t.style[e] = n } removeStyle(t, e, n) { n & ss.DashCase ? t.style.removeProperty(e) : t.style[e] = "" } setProperty(t, e, n) { t[e] = n } setValue(t, e) { t.nodeValue = e } listen(t, e, n) { return "string" == typeof t ? this.eventManager.addGlobalEventListener(t, e, Gh(n)) : this.eventManager.addEventListener(t, e, Gh(n)) } } class Jh extends Xh { constructor(t, e, n, i) { super(t), this.component = n; const s = Zh(i + "-" + n.id, n.styles, []); e.addStyles(s), this.contentAttr = "_ngcontent-%COMP%".replace(Yh, i + "-" + n.id), this.hostAttr = "_nghost-%COMP%".replace(Yh, i + "-" + n.id) } applyToHost(t) { super.setAttribute(t, this.hostAttr, "") } createElement(t, e) { const n = super.createElement(t, e); return super.setAttribute(n, this.contentAttr, ""), n } } class tu extends Xh { constructor(t, e, n, i) { super(t), this.sharedStylesHost = e, this.hostEl = n, this.shadowRoot = n.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const s = Zh(i.id, i.styles, []); for (let r = 0; r < s.length; r++) { const t = document.createElement("style"); t.textContent = s[r], this.shadowRoot.appendChild(t) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } appendChild(t, e) { return super.appendChild(this.nodeOrShadowRoot(t), e) } insertBefore(t, e, n) { return super.insertBefore(this.nodeOrShadowRoot(t), e, n) } removeChild(t, e) { return super.removeChild(this.nodeOrShadowRoot(t), e) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } } let eu = (() => { class t extends zh { constructor(t) { super(t) } supports(t) { return !0 } addEventListener(t, e, n) { return t.addEventListener(e, n, !1), () => this.removeEventListener(t, e, n) } removeEventListener(t, e, n) { return t.removeEventListener(e, n) } } return t.\u0275fac = function (e) { return new (e || t)(li(Jc)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const nu = ["alt", "control", "meta", "shift"], iu = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, su = { A: "1", B: "2", C: "3", D: "4", E: "5", F: "6", G: "7", H: "8", I: "9", J: "*", K: "+", M: "-", N: ".", O: "/", "`": "0", "\x90": "NumLock" }, ru = { alt: t => t.altKey, control: t => t.ctrlKey, meta: t => t.metaKey, shift: t => t.shiftKey }; let ou = (() => { class t extends zh { constructor(t) { super(t) } supports(e) { return null != t.parseEventName(e) } addEventListener(e, n, i) { const s = t.parseEventName(n), r = t.eventCallback(s.fullKey, i, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => Xc().onAndCancel(e, s.domEventName, r)) } static parseEventName(e) { const n = e.toLowerCase().split("."), i = n.shift(); if (0 === n.length || "keydown" !== i && "keyup" !== i) return null; const s = t._normalizeKey(n.pop()); let r = ""; if (nu.forEach(t => { const e = n.indexOf(t); e > -1 && (n.splice(e, 1), r += t + ".") }), r += s, 0 != n.length || 0 === s.length) return null; const o = {}; return o.domEventName = i, o.fullKey = r, o } static getEventFullKey(t) { let e = "", n = function (t) { let e = t.key; if (null == e) { if (e = t.keyIdentifier, null == e) return "Unidentified"; e.startsWith("U+") && (e = String.fromCharCode(parseInt(e.substring(2), 16)), 3 === t.location && su.hasOwnProperty(e) && (e = su[e])) } return iu[e] || e }(t); return n = n.toLowerCase(), " " === n ? n = "space" : "." === n && (n = "dot"), nu.forEach(i => { i != n && (0, ru[i])(t) && (e += i + ".") }), e += n, e } static eventCallback(e, n, i) { return s => { t.getEventFullKey(s) === e && i.runGuarded(() => n(s)) } } static _normalizeKey(t) { switch (t) { case "esc": return "escape"; default: return t } } } return t.\u0275fac = function (e) { return new (e || t)(li(Jc)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), au = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ factory: function () { return li(cu) }, token: t, providedIn: "root" }), t })(); function lu(t) { return new cu(t.get(Jc)) } let cu = (() => { class t extends au { constructor(t) { super(), this._doc = t } sanitize(t, e) { if (null == e) return null; switch (t) { case Yi.NONE: return e; case Yi.HTML: return xi(e, "HTML") ? ki(e) : function (t, e) { let n = null; try { Wi = Wi || function (t) { const e = new Ti(t); return function () { try { return !!(new window.DOMParser).parseFromString(gi(""), "text/html") } catch (t) { return !1 } }() ? new Ei(e) : e }(t); let i = e ? String(e) : ""; n = Wi.getInertBodyElement(i); let s = 5, r = i; do { if (0 === s) throw new Error("Failed to sanitize html because the input is unstable"); s--, i = r, r = n.innerHTML, n = Wi.getInertBodyElement(i) } while (i !== r); return gi((new Ui).sanitizeChildren(Ki(n) || n)) } finally { if (n) { const t = Ki(n) || n; for (; t.firstChild;)t.removeChild(t.firstChild) } } }(this._doc, String(e)).toString(); case Yi.STYLE: return xi(e, "Style") ? ki(e) : e; case Yi.SCRIPT: if (xi(e, "Script")) return ki(e); throw new Error("unsafe value used in a script context"); case Yi.URL: return Si(e), xi(e, "URL") ? ki(e) : Oi(String(e)); case Yi.RESOURCE_URL: if (xi(e, "ResourceURL")) return ki(e); throw new Error("unsafe value used in a resource URL context (see https://g.co/ng/security#xss)"); default: throw new Error(`Unexpected SecurityContext ${t} (see https://g.co/ng/security#xss)`) } } bypassSecurityTrustHtml(t) { return new yi(t) } bypassSecurityTrustStyle(t) { return new bi(t) } bypassSecurityTrustScript(t) { return new vi(t) } bypassSecurityTrustUrl(t) { return new wi(t) } bypassSecurityTrustResourceUrl(t) { return new Ci(t) } } return t.\u0275fac = function (e) { return new (e || t)(li(Jc)) }, t.\u0275prov = dt({ factory: function () { return lu(li(Hr)) }, token: t, providedIn: "root" }), t })(); const hu = Lc(Yc, "browser", [{ provide: rc, useValue: "browser" }, { provide: sc, useValue: function () { Mh.makeCurrent(), jh.init() }, multi: !0 }, { provide: Jc, useFactory: function () { return function (t) { fe = t }(document), document }, deps: [] }]), uu = [[], { provide: zr, useValue: "root" }, { provide: es, useFactory: function () { return new es }, deps: [] }, { provide: Hh, useClass: eu, multi: !0, deps: [Jc, vc, rc] }, { provide: Hh, useClass: ou, multi: !0, deps: [Jc] }, [], { provide: Qh, useClass: Qh, deps: [Uh, qh, ec] }, { provide: Fa, useExisting: Qh }, { provide: $h, useExisting: qh }, { provide: qh, useClass: qh, deps: [Jc] }, { provide: Tc, useClass: Tc, deps: [vc] }, { provide: Uh, useClass: Uh, deps: [Hh, vc] }, { provide: Ph, useClass: Bh, deps: [] }, []]; let du = (() => { class t { constructor(t) { if (t) throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.") } static withServerTransition(e) { return { ngModule: t, providers: [{ provide: ec, useValue: e.appId }, { provide: Lh, useExisting: ec }, Vh] } } } return t.\u0275fac = function (e) { return new (e || t)(li(t, 12)) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ providers: uu, imports: [Ah, Gc] }), t })(); function pu(...t) { let e = t[t.length - 1]; return S(e) ? (t.pop(), N(t, e)) : $(t) } "undefined" != typeof window && window; class fu extends k { constructor(t) { super(), this._value = t } get value() { return this.getValue() } _subscribe(t) { const e = super._subscribe(t); return e && !e.closed && t.next(this._value), e } getValue() { if (this.hasError) throw this.thrownError; if (this.closed) throw new v; return this._value } next(t) { super.next(this._value = t) } } class mu extends f { notifyNext(t, e, n, i, s) { this.destination.next(e) } notifyError(t, e) { this.destination.error(t) } notifyComplete(t) { this.destination.complete() } } class gu extends f { constructor(t, e, n) { super(), this.parent = t, this.outerValue = e, this.outerIndex = n, this.index = 0 } _next(t) { this.parent.notifyNext(this.outerValue, t, this.outerIndex, this.index++, this) } _error(t) { this.parent.notifyError(t, this), this.unsubscribe() } _complete() { this.parent.notifyComplete(this), this.unsubscribe() } } function _u(t, e, n, i, s = new gu(t, n, i)) { if (!s.closed) return e instanceof y ? e.subscribe(s) : M(e)(s) } const yu = {}; function bu(...t) { let e, n; return S(t[t.length - 1]) && (n = t.pop()), "function" == typeof t[t.length - 1] && (e = t.pop()), 1 === t.length && l(t[0]) && (t = t[0]), $(t, n).lift(new vu(e)) } class vu { constructor(t) { this.resultSelector = t } call(t, e) { return e.subscribe(new wu(t, this.resultSelector)) } } class wu extends mu { constructor(t, e) { super(t), this.resultSelector = e, this.active = 0, this.values = [], this.observables = [] } _next(t) { this.values.push(yu), this.observables.push(t) } _complete() { const t = this.observables, e = t.length; if (0 === e) this.destination.complete(); else { this.active = e, this.toRespond = e; for (let n = 0; n < e; n++)this.add(_u(this, t[n], void 0, n)) } } notifyComplete(t) { 0 == (this.active -= 1) && this.destination.complete() } notifyNext(t, e, n) { const i = this.values, s = this.toRespond ? i[n] === yu ? --this.toRespond : this.toRespond : 0; i[n] = e, 0 === s && (this.resultSelector ? this._tryResultSelector(i) : this.destination.next(i.slice())) } _tryResultSelector(t) { let e; try { e = this.resultSelector.apply(this, t) } catch (n) { return void this.destination.error(n) } this.destination.next(e) } } const Cu = (() => { function t() { return Error.call(this), this.message = "no elements in sequence", this.name = "EmptyError", this } return t.prototype = Object.create(Error.prototype), t })(); function ku(...t) { return z(1)(pu(...t)) } const xu = new y(t => t.complete()); function Su(t) { return t ? function (t) { return new y(e => t.schedule(() => e.complete())) }(t) : xu } function Eu(t) { return new y(e => { let n; try { n = t() } catch (i) { return void e.error(i) } return (n ? F(n) : Su()).subscribe(e) }) } function Tu(t, e) { return "function" == typeof e ? n => n.pipe(Tu((n, i) => F(t(n, i)).pipe(E((t, s) => e(n, t, i, s))))) : e => e.lift(new Ru(t)) } class Ru { constructor(t) { this.project = t } call(t, e) { return e.subscribe(new Au(t, this.project)) } } class Au extends V { constructor(t, e) { super(t), this.project = e, this.index = 0 } _next(t) { let e; const n = this.index++; try { e = this.project(t, n) } catch (i) { return void this.destination.error(i) } this._innerSub(e) } _innerSub(t) { const e = this.innerSubscription; e && e.unsubscribe(); const n = new L(this), i = this.destination; i.add(n), this.innerSubscription = j(t, n), this.innerSubscription !== n && i.add(this.innerSubscription) } _complete() { const { innerSubscription: t } = this; t && !t.closed || super._complete(), this.unsubscribe() } _unsubscribe() { this.innerSubscription = void 0 } notifyComplete() { this.innerSubscription = void 0, this.isStopped && super._complete() } notifyNext(t) { this.destination.next(t) } } const Ou = (() => { function t() { return Error.call(this), this.message = "argument out of range", this.name = "ArgumentOutOfRangeError", this } return t.prototype = Object.create(Error.prototype), t })(); function Iu(t) { return e => 0 === t ? Su() : e.lift(new Du(t)) } class Du { constructor(t) { if (this.total = t, this.total < 0) throw new Ou } call(t, e) { return e.subscribe(new Pu(t, this.total)) } } class Pu extends f { constructor(t, e) { super(t), this.total = e, this.count = 0 } _next(t) { const e = this.total, n = ++this.count; n <= e && (this.destination.next(t), n === e && (this.destination.complete(), this.unsubscribe())) } } function Mu(...t) { const e = t[t.length - 1]; return S(e) ? (t.pop(), n => ku(t, n, e)) : e => ku(t, e) } function Nu(t, e) { let n = !1; return arguments.length >= 2 && (n = !0), function (i) { return i.lift(new Fu(t, e, n)) } } class Fu { constructor(t, e, n = !1) { this.accumulator = t, this.seed = e, this.hasSeed = n } call(t, e) { return e.subscribe(new Lu(t, this.accumulator, this.seed, this.hasSeed)) } } class Lu extends f { constructor(t, e, n, i) { super(t), this.accumulator = e, this._seed = n, this.hasSeed = i, this.index = 0 } get seed() { return this._seed } set seed(t) { this.hasSeed = !0, this._seed = t } _next(t) { if (this.hasSeed) return this._tryNext(t); this.seed = t, this.destination.next(t) } _tryNext(t) { const e = this.index++; let n; try { n = this.accumulator(this.seed, t, e) } catch (i) { this.destination.error(i) } this.seed = n, this.destination.next(n) } } function Vu(t, e) { return function (n) { return n.lift(new ju(t, e)) } } class ju { constructor(t, e) { this.predicate = t, this.thisArg = e } call(t, e) { return e.subscribe(new Bu(t, this.predicate, this.thisArg)) } } class Bu extends f { constructor(t, e, n) { super(t), this.predicate = e, this.thisArg = n, this.count = 0 } _next(t) { let e; try { e = this.predicate.call(this.thisArg, t, this.count++) } catch (n) { return void this.destination.error(n) } e && this.destination.next(t) } } function Hu(t) { return function (e) { const n = new Uu(t), i = e.lift(n); return n.caught = i } } class Uu { constructor(t) { this.selector = t } call(t, e) { return e.subscribe(new zu(t, this.selector, this.caught)) } } class zu extends V { constructor(t, e, n) { super(t), this.selector = e, this.caught = n } error(t) { if (!this.isStopped) { let n; try { n = this.selector(t, this.caught) } catch (e) { return void super.error(e) } this._unsubscribeAndRecycle(); const i = new L(this); this.add(i); const s = j(n, i); s !== i && this.add(s) } } } function $u(t, e) { return B(t, e, 1) } function qu(t) { return function (e) { return 0 === t ? Su() : e.lift(new Wu(t)) } } class Wu { constructor(t) { if (this.total = t, this.total < 0) throw new Ou } call(t, e) { return e.subscribe(new Ku(t, this.total)) } } class Ku extends f { constructor(t, e) { super(t), this.total = e, this.ring = new Array, this.count = 0 } _next(t) { const e = this.ring, n = this.total, i = this.count++; e.length < n ? e.push(t) : e[i % n] = t } _complete() { const t = this.destination; let e = this.count; if (e > 0) { const n = this.count >= this.total ? this.total : this.count, i = this.ring; for (let s = 0; s < n; s++) { const s = e++ % n; t.next(i[s]) } } t.complete() } } function Yu(t = Qu) { return e => e.lift(new Zu(t)) } class Zu { constructor(t) { this.errorFactory = t } call(t, e) { return e.subscribe(new Gu(t, this.errorFactory)) } } class Gu extends f { constructor(t, e) { super(t), this.errorFactory = e, this.hasValue = !1 } _next(t) { this.hasValue = !0, this.destination.next(t) } _complete() { if (this.hasValue) return this.destination.complete(); { let e; try { e = this.errorFactory() } catch (t) { e = t } this.destination.error(e) } } } function Qu() { return new Cu } function Xu(t = null) { return e => e.lift(new Ju(t)) } class Ju { constructor(t) { this.defaultValue = t } call(t, e) { return e.subscribe(new td(t, this.defaultValue)) } } class td extends f { constructor(t, e) { super(t), this.defaultValue = e, this.isEmpty = !0 } _next(t) { this.isEmpty = !1, this.destination.next(t) } _complete() { this.isEmpty && this.destination.next(this.defaultValue), this.destination.complete() } } function ed(t, e) { const n = arguments.length >= 2; return i => i.pipe(t ? Vu((e, n) => t(e, n, i)) : _, Iu(1), n ? Xu(e) : Yu(() => new Cu)) } function nd() { } function id(t, e, n) { return function (i) { return i.lift(new sd(t, e, n)) } } class sd { constructor(t, e, n) { this.nextOrObserver = t, this.error = e, this.complete = n } call(t, e) { return e.subscribe(new rd(t, this.nextOrObserver, this.error, this.complete)) } } class rd extends f { constructor(t, e, n, s) { super(t), this._tapNext = nd, this._tapError = nd, this._tapComplete = nd, this._tapError = n || nd, this._tapComplete = s || nd, i(e) ? (this._context = this, this._tapNext = e) : e && (this._context = e, this._tapNext = e.next || nd, this._tapError = e.error || nd, this._tapComplete = e.complete || nd) } _next(t) { try { this._tapNext.call(this._context, t) } catch (e) { return void this.destination.error(e) } this.destination.next(t) } _error(t) { try { this._tapError.call(this._context, t) } catch (t) { return void this.destination.error(t) } this.destination.error(t) } _complete() { try { this._tapComplete.call(this._context) } catch (t) { return void this.destination.error(t) } return this.destination.complete() } } function od(t) { return e => e.lift(new ad(t)) } class ad { constructor(t) { this.callback = t } call(t, e) { return e.subscribe(new ld(t, this.callback)) } } class ld extends f { constructor(t, e) { super(t), this.add(new u(e)) } } class cd { constructor(t, e) { this.id = t, this.url = e } } class hd extends cd { constructor(t, e, n = "imperative", i = null) { super(t, e), this.navigationTrigger = n, this.restoredState = i } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class ud extends cd { constructor(t, e, n) { super(t, e), this.urlAfterRedirects = n } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } class dd extends cd { constructor(t, e, n) { super(t, e), this.reason = n } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class pd extends cd { constructor(t, e, n) { super(t, e), this.error = n } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class fd extends cd { constructor(t, e, n, i) { super(t, e), this.urlAfterRedirects = n, this.state = i } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class md extends cd { constructor(t, e, n, i) { super(t, e), this.urlAfterRedirects = n, this.state = i } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class gd extends cd { constructor(t, e, n, i, s) { super(t, e), this.urlAfterRedirects = n, this.state = i, this.shouldActivate = s } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class _d extends cd { constructor(t, e, n, i) { super(t, e), this.urlAfterRedirects = n, this.state = i } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class yd extends cd { constructor(t, e, n, i) { super(t, e), this.urlAfterRedirects = n, this.state = i } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class bd { constructor(t) { this.route = t } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class vd { constructor(t) { this.route = t } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class wd { constructor(t) { this.snapshot = t } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class Cd { constructor(t) { this.snapshot = t } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class kd { constructor(t) { this.snapshot = t } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class xd { constructor(t) { this.snapshot = t } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class Sd { constructor(t, e, n) { this.routerEvent = t, this.position = e, this.anchor = n } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')` } } const Ed = "primary"; class Td { constructor(t) { this.params = t || {} } has(t) { return Object.prototype.hasOwnProperty.call(this.params, t) } get(t) { if (this.has(t)) { const e = this.params[t]; return Array.isArray(e) ? e[0] : e } return null } getAll(t) { if (this.has(t)) { const e = this.params[t]; return Array.isArray(e) ? e : [e] } return [] } get keys() { return Object.keys(this.params) } } function Rd(t) { return new Td(t) } function Ad(t) { const e = Error("NavigationCancelingError: " + t); return e.ngNavigationCancelingError = !0, e } function Od(t, e, n) { const i = n.path.split("/"); if (i.length > t.length) return null; if ("full" === n.pathMatch && (e.hasChildren() || i.length < t.length)) return null; const s = {}; for (let r = 0; r < i.length; r++) { const e = i[r], n = t[r]; if (e.startsWith(":")) s[e.substring(1)] = n; else if (e !== n.path) return null } return { consumed: t.slice(0, i.length), posParams: s } } function Id(t, e) { const n = t ? Object.keys(t) : void 0, i = e ? Object.keys(e) : void 0; if (!n || !i || n.length != i.length) return !1; let s; for (let r = 0; r < n.length; r++)if (s = n[r], !Dd(t[s], e[s])) return !1; return !0 } function Dd(t, e) { if (Array.isArray(t) && Array.isArray(e)) { if (t.length !== e.length) return !1; const n = [...t].sort(), i = [...e].sort(); return n.every((t, e) => i[e] === t) } return t === e } function Pd(t) { return Array.prototype.concat.apply([], t) } function Md(t) { return t.length > 0 ? t[t.length - 1] : null } function Nd(t, e) { for (const n in t) t.hasOwnProperty(n) && e(t[n], n) } function Fd(t) { return Oo(t) ? t : Ao(t) ? F(Promise.resolve(t)) : pu(t) } const Ld = { exact: function t(e, n, i) { if (!Wd(e.segments, n.segments)) return !1; if (!Ud(e.segments, n.segments, i)) return !1; if (e.numberOfChildren !== n.numberOfChildren) return !1; for (const s in n.children) { if (!e.children[s]) return !1; if (!t(e.children[s], n.children[s], i)) return !1 } return !0 }, subset: Bd }, Vd = { exact: function (t, e) { return Id(t, e) }, subset: function (t, e) { return Object.keys(e).length <= Object.keys(t).length && Object.keys(e).every(n => Dd(t[n], e[n])) }, ignored: () => !0 }; function jd(t, e, n) { return Ld[n.paths](t.root, e.root, n.matrixParams) && Vd[n.queryParams](t.queryParams, e.queryParams) && !("exact" === n.fragment && t.fragment !== e.fragment) } function Bd(t, e, n) { return Hd(t, e, e.segments, n) } function Hd(t, e, n, i) { if (t.segments.length > n.length) { const s = t.segments.slice(0, n.length); return !!Wd(s, n) && !e.hasChildren() && !!Ud(s, n, i) } if (t.segments.length === n.length) { if (!Wd(t.segments, n)) return !1; if (!Ud(t.segments, n, i)) return !1; for (const n in e.children) { if (!t.children[n]) return !1; if (!Bd(t.children[n], e.children[n], i)) return !1 } return !0 } { const s = n.slice(0, t.segments.length), r = n.slice(t.segments.length); return !!Wd(t.segments, s) && !!Ud(t.segments, s, i) && !!t.children.primary && Hd(t.children.primary, e, r, i) } } function Ud(t, e, n) { return e.every((e, i) => Vd[n](t[i].parameters, e.parameters)) } class zd { constructor(t, e, n) { this.root = t, this.queryParams = e, this.fragment = n } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Rd(this.queryParams)), this._queryParamMap } toString() { return Zd.serialize(this) } } class $d { constructor(t, e) { this.segments = t, this.children = e, this.parent = null, Nd(e, (t, e) => t.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return Gd(this) } } class qd { constructor(t, e) { this.path = t, this.parameters = e } get parameterMap() { return this._parameterMap || (this._parameterMap = Rd(this.parameters)), this._parameterMap } toString() { return ip(this) } } function Wd(t, e) { return t.length === e.length && t.every((t, n) => t.path === e[n].path) } class Kd { } class Yd { parse(t) { const e = new lp(t); return new zd(e.parseRootSegment(), e.parseQueryParams(), e.parseFragment()) } serialize(t) { var e; return `/${Qd(t.root, !0)}${function (t) { const e = Object.keys(t).map(e => { const n = t[e]; return Array.isArray(n) ? n.map(t => `${Jd(e)}=${Jd(t)}`).join("&") : `${Jd(e)}=${Jd(n)}` }).filter(t => !!t); return e.length ? `?${e.join("&")}` : "" }(t.queryParams)}${"string" == typeof t.fragment ? `#${e = t.fragment, encodeURI(e)}` : ""}` } } const Zd = new Yd; function Gd(t) { return t.segments.map(t => ip(t)).join("/") } function Qd(t, e) { if (!t.hasChildren()) return Gd(t); if (e) { const e = t.children.primary ? Qd(t.children.primary, !1) : "", n = []; return Nd(t.children, (t, e) => { e !== Ed && n.push(`${e}:${Qd(t, !1)}`) }), n.length > 0 ? `${e}(${n.join("//")})` : e } { const e = function (t, e) { let n = []; return Nd(t.children, (t, i) => { i === Ed && (n = n.concat(e(t, i))) }), Nd(t.children, (t, i) => { i !== Ed && (n = n.concat(e(t, i))) }), n }(t, (e, n) => n === Ed ? [Qd(t.children.primary, !1)] : [`${n}:${Qd(e, !1)}`]); return 1 === Object.keys(t.children).length && null != t.children.primary ? `${Gd(t)}/${e[0]}` : `${Gd(t)}/(${e.join("//")})` } } function Xd(t) { return encodeURIComponent(t).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function Jd(t) { return Xd(t).replace(/%3B/gi, ";") } function tp(t) { return Xd(t).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function ep(t) { return decodeURIComponent(t) } function np(t) { return ep(t.replace(/\+/g, "%20")) } function ip(t) { return `${tp(t.path)}${e = t.parameters, Object.keys(e).map(t => `;${tp(t)}=${tp(e[t])}`).join("")}`; var e } const sp = /^[^\/()?;=#]+/; function rp(t) { const e = t.match(sp); return e ? e[0] : "" } const op = /^[^=?&#]+/, ap = /^[^?&#]+/; class lp { constructor(t) { this.url = t, this.remaining = t } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new $d([], {}) : new $d([], this.parseChildren()) } parseQueryParams() { const t = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(t) } while (this.consumeOptional("&")); return t } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const t = []; for (this.peekStartsWith("(") || t.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), t.push(this.parseSegment()); let e = {}; this.peekStartsWith("/(") && (this.capture("/"), e = this.parseParens(!0)); let n = {}; return this.peekStartsWith("(") && (n = this.parseParens(!1)), (t.length > 0 || Object.keys(e).length > 0) && (n.primary = new $d(t, e)), n } parseSegment() { const t = rp(this.remaining); if ("" === t && this.peekStartsWith(";")) throw new Error(`Empty path url segment cannot have parameters: '${this.remaining}'.`); return this.capture(t), new qd(ep(t), this.parseMatrixParams()) } parseMatrixParams() { const t = {}; for (; this.consumeOptional(";");)this.parseParam(t); return t } parseParam(t) { const e = rp(this.remaining); if (!e) return; this.capture(e); let n = ""; if (this.consumeOptional("=")) { const t = rp(this.remaining); t && (n = t, this.capture(n)) } t[ep(e)] = ep(n) } parseQueryParam(t) { const e = function (t) { const e = t.match(op); return e ? e[0] : "" }(this.remaining); if (!e) return; this.capture(e); let n = ""; if (this.consumeOptional("=")) { const t = function (t) { const e = t.match(ap); return e ? e[0] : "" }(this.remaining); t && (n = t, this.capture(n)) } const i = np(e), s = np(n); if (t.hasOwnProperty(i)) { let e = t[i]; Array.isArray(e) || (e = [e], t[i] = e), e.push(s) } else t[i] = s } parseParens(t) { const e = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const n = rp(this.remaining), i = this.remaining[n.length]; if ("/" !== i && ")" !== i && ";" !== i) throw new Error(`Cannot parse url '${this.url}'`); let s; n.indexOf(":") > -1 ? (s = n.substr(0, n.indexOf(":")), this.capture(s), this.capture(":")) : t && (s = Ed); const r = this.parseChildren(); e[s] = 1 === Object.keys(r).length ? r.primary : new $d([], r), this.consumeOptional("//") } return e } peekStartsWith(t) { return this.remaining.startsWith(t) } consumeOptional(t) { return !!this.peekStartsWith(t) && (this.remaining = this.remaining.substring(t.length), !0) } capture(t) { if (!this.consumeOptional(t)) throw new Error(`Expected "${t}".`) } } class cp { constructor(t) { this._root = t } get root() { return this._root.value } parent(t) { const e = this.pathFromRoot(t); return e.length > 1 ? e[e.length - 2] : null } children(t) { const e = hp(t, this._root); return e ? e.children.map(t => t.value) : [] } firstChild(t) { const e = hp(t, this._root); return e && e.children.length > 0 ? e.children[0].value : null } siblings(t) { const e = up(t, this._root); return e.length < 2 ? [] : e[e.length - 2].children.map(t => t.value).filter(e => e !== t) } pathFromRoot(t) { return up(t, this._root).map(t => t.value) } } function hp(t, e) { if (t === e.value) return e; for (const n of e.children) { const e = hp(t, n); if (e) return e } return null } function up(t, e) { if (t === e.value) return [e]; for (const n of e.children) { const i = up(t, n); if (i.length) return i.unshift(e), i } return [] } class dp { constructor(t, e) { this.value = t, this.children = e } toString() { return `TreeNode(${this.value})` } } function pp(t) { const e = {}; return t && t.children.forEach(t => e[t.value.outlet] = t), e } class fp extends cp { constructor(t, e) { super(t), this.snapshot = e, vp(this, t) } toString() { return this.snapshot.toString() } } function mp(t, e) { const n = function (t, e) { const n = new yp([], {}, {}, "", {}, Ed, e, null, t.root, -1, {}); return new bp("", new dp(n, [])) }(t, e), i = new fu([new qd("", {})]), s = new fu({}), r = new fu({}), o = new fu({}), a = new fu(""), l = new gp(i, s, o, a, r, Ed, e, n.root); return l.snapshot = n.root, new fp(new dp(l, []), n) } class gp { constructor(t, e, n, i, s, r, o, a) { this.url = t, this.params = e, this.queryParams = n, this.fragment = i, this.data = s, this.outlet = r, this.component = o, this._futureSnapshot = a } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe(E(t => Rd(t)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe(E(t => Rd(t)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } } function _p(t, e = "emptyOnly") { const n = t.pathFromRoot; let i = 0; if ("always" !== e) for (i = n.length - 1; i >= 1;) { const t = n[i], e = n[i - 1]; if (t.routeConfig && "" === t.routeConfig.path) i--; else { if (e.component) break; i-- } } return function (t) { return t.reduce((t, e) => ({ params: Object.assign(Object.assign({}, t.params), e.params), data: Object.assign(Object.assign({}, t.data), e.data), resolve: Object.assign(Object.assign({}, t.resolve), e._resolvedData) }), { params: {}, data: {}, resolve: {} }) }(n.slice(i)) } class yp { constructor(t, e, n, i, s, r, o, a, l, c, h) { this.url = t, this.params = e, this.queryParams = n, this.fragment = i, this.data = s, this.outlet = r, this.component = o, this.routeConfig = a, this._urlSegment = l, this._lastPathIndex = c, this._resolve = h } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = Rd(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = Rd(this.queryParams)), this._queryParamMap } toString() { return `Route(url:'${this.url.map(t => t.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')` } } class bp extends cp { constructor(t, e) { super(e), this.url = t, vp(this, e) } toString() { return wp(this._root) } } function vp(t, e) { e.value._routerState = t, e.children.forEach(e => vp(t, e)) } function wp(t) { const e = t.children.length > 0 ? ` { ${t.children.map(wp).join(", ")} } ` : ""; return `${t.value}${e}` } function Cp(t) { if (t.snapshot) { const e = t.snapshot, n = t._futureSnapshot; t.snapshot = n, Id(e.queryParams, n.queryParams) || t.queryParams.next(n.queryParams), e.fragment !== n.fragment && t.fragment.next(n.fragment), Id(e.params, n.params) || t.params.next(n.params), function (t, e) { if (t.length !== e.length) return !1; for (let n = 0; n < t.length; ++n)if (!Id(t[n], e[n])) return !1; return !0 }(e.url, n.url) || t.url.next(n.url), Id(e.data, n.data) || t.data.next(n.data) } else t.snapshot = t._futureSnapshot, t.data.next(t._futureSnapshot.data) } function kp(t, e) { var n, i; return Id(t.params, e.params) && Wd(n = t.url, i = e.url) && n.every((t, e) => Id(t.parameters, i[e].parameters)) && !(!t.parent != !e.parent) && (!t.parent || kp(t.parent, e.parent)) } function xp(t, e, n) { if (n && t.shouldReuseRoute(e.value, n.value.snapshot)) { const i = n.value; i._futureSnapshot = e.value; const s = function (t, e, n) { return e.children.map(e => { for (const i of n.children) if (t.shouldReuseRoute(e.value, i.value.snapshot)) return xp(t, e, i); return xp(t, e) }) }(t, e, n); return new dp(i, s) } { if (t.shouldAttach(e.value)) { const n = t.retrieve(e.value); if (null !== n) { const t = n.route; return Sp(e, t), t } } const n = new gp(new fu((i = e.value).url), new fu(i.params), new fu(i.queryParams), new fu(i.fragment), new fu(i.data), i.outlet, i.component, i), s = e.children.map(e => xp(t, e)); return new dp(n, s) } var i } function Sp(t, e) { if (t.value.routeConfig !== e.value.routeConfig) throw new Error("Cannot reattach ActivatedRouteSnapshot created from a different route"); if (t.children.length !== e.children.length) throw new Error("Cannot reattach ActivatedRouteSnapshot with a different number of children"); e.value._futureSnapshot = t.value; for (let n = 0; n < t.children.length; ++n)Sp(t.children[n], e.children[n]) } function Ep(t) { return "object" == typeof t && null != t && !t.outlets && !t.segmentPath } function Tp(t) { return "object" == typeof t && null != t && t.outlets } function Rp(t, e, n, i, s) { let r = {}; return i && Nd(i, (t, e) => { r[e] = Array.isArray(t) ? t.map(t => `${t}`) : `${t}` }), new zd(n.root === t ? e : Ap(n.root, t, e), r, s) } function Ap(t, e, n) { const i = {}; return Nd(t.children, (t, s) => { i[s] = t === e ? n : Ap(t, e, n) }), new $d(t.segments, i) } class Op { constructor(t, e, n) { if (this.isAbsolute = t, this.numberOfDoubleDots = e, this.commands = n, t && n.length > 0 && Ep(n[0])) throw new Error("Root segment cannot have matrix parameters"); const i = n.find(Tp); if (i && i !== Md(n)) throw new Error("{outlets:{}} has to be the last command") } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class Ip { constructor(t, e, n) { this.segmentGroup = t, this.processChildren = e, this.index = n } } function Dp(t, e, n) { if (t || (t = new $d([], {})), 0 === t.segments.length && t.hasChildren()) return Pp(t, e, n); const i = function (t, e, n) { let i = 0, s = e; const r = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; s < t.segments.length;) { if (i >= n.length) return r; const e = t.segments[s], o = n[i]; if (Tp(o)) break; const a = `${o}`, l = i < n.length - 1 ? n[i + 1] : null; if (s > 0 && void 0 === a) break; if (a && l && "object" == typeof l && void 0 === l.outlets) { if (!Lp(a, l, e)) return r; i += 2 } else { if (!Lp(a, {}, e)) return r; i++ } s++ } return { match: !0, pathIndex: s, commandIndex: i } }(t, e, n), s = n.slice(i.commandIndex); if (i.match && i.pathIndex < t.segments.length) { const e = new $d(t.segments.slice(0, i.pathIndex), {}); return e.children.primary = new $d(t.segments.slice(i.pathIndex), t.children), Pp(e, 0, s) } return i.match && 0 === s.length ? new $d(t.segments, {}) : i.match && !t.hasChildren() ? Mp(t, e, n) : i.match ? Pp(t, 0, s) : Mp(t, e, n) } function Pp(t, e, n) { if (0 === n.length) return new $d(t.segments, {}); { const i = function (t) { return Tp(t[0]) ? t[0].outlets : { [Ed]: t } }(n), s = {}; return Nd(i, (n, i) => { "string" == typeof n && (n = [n]), null !== n && (s[i] = Dp(t.children[i], e, n)) }), Nd(t.children, (t, e) => { void 0 === i[e] && (s[e] = t) }), new $d(t.segments, s) } } function Mp(t, e, n) { const i = t.segments.slice(0, e); let s = 0; for (; s < n.length;) { const r = n[s]; if (Tp(r)) { const t = Np(r.outlets); return new $d(i, t) } if (0 === s && Ep(n[0])) { i.push(new qd(t.segments[e].path, Fp(n[0]))), s++; continue } const o = Tp(r) ? r.outlets.primary : `${r}`, a = s < n.length - 1 ? n[s + 1] : null; o && a && Ep(a) ? (i.push(new qd(o, Fp(a))), s += 2) : (i.push(new qd(o, {})), s++) } return new $d(i, {}) } function Np(t) { const e = {}; return Nd(t, (t, n) => { "string" == typeof t && (t = [t]), null !== t && (e[n] = Mp(new $d([], {}), 0, t)) }), e } function Fp(t) { const e = {}; return Nd(t, (t, n) => e[n] = `${t}`), e } function Lp(t, e, n) { return t == n.path && Id(e, n.parameters) } class Vp { constructor(t, e, n, i) { this.routeReuseStrategy = t, this.futureState = e, this.currState = n, this.forwardEvent = i } activate(t) { const e = this.futureState._root, n = this.currState ? this.currState._root : null; this.deactivateChildRoutes(e, n, t), Cp(this.futureState.root), this.activateChildRoutes(e, n, t) } deactivateChildRoutes(t, e, n) { const i = pp(e); t.children.forEach(t => { const e = t.value.outlet; this.deactivateRoutes(t, i[e], n), delete i[e] }), Nd(i, (t, e) => { this.deactivateRouteAndItsChildren(t, n) }) } deactivateRoutes(t, e, n) { const i = t.value, s = e ? e.value : null; if (i === s) if (i.component) { const s = n.getContext(i.outlet); s && this.deactivateChildRoutes(t, e, s.children) } else this.deactivateChildRoutes(t, e, n); else s && this.deactivateRouteAndItsChildren(e, n) } deactivateRouteAndItsChildren(t, e) { this.routeReuseStrategy.shouldDetach(t.value.snapshot) ? this.detachAndStoreRouteSubtree(t, e) : this.deactivateRouteAndOutlet(t, e) } detachAndStoreRouteSubtree(t, e) { const n = e.getContext(t.value.outlet); if (n && n.outlet) { const e = n.outlet.detach(), i = n.children.onOutletDeactivated(); this.routeReuseStrategy.store(t.value.snapshot, { componentRef: e, route: t, contexts: i }) } } deactivateRouteAndOutlet(t, e) { const n = e.getContext(t.value.outlet), i = n && t.value.component ? n.children : e, s = pp(t); for (const r of Object.keys(s)) this.deactivateRouteAndItsChildren(s[r], i); n && n.outlet && (n.outlet.deactivate(), n.children.onOutletDeactivated(), n.attachRef = null, n.resolver = null, n.route = null) } activateChildRoutes(t, e, n) { const i = pp(e); t.children.forEach(t => { this.activateRoutes(t, i[t.value.outlet], n), this.forwardEvent(new xd(t.value.snapshot)) }), t.children.length && this.forwardEvent(new Cd(t.value.snapshot)) } activateRoutes(t, e, n) { const i = t.value, s = e ? e.value : null; if (Cp(i), i === s) if (i.component) { const s = n.getOrCreateContext(i.outlet); this.activateChildRoutes(t, e, s.children) } else this.activateChildRoutes(t, e, n); else if (i.component) { const e = n.getOrCreateContext(i.outlet); if (this.routeReuseStrategy.shouldAttach(i.snapshot)) { const t = this.routeReuseStrategy.retrieve(i.snapshot); this.routeReuseStrategy.store(i.snapshot, null), e.children.onOutletReAttached(t.contexts), e.attachRef = t.componentRef, e.route = t.route.value, e.outlet && e.outlet.attach(t.componentRef, t.route.value), jp(t.route) } else { const n = function (t) { for (let e = t.parent; e; e = e.parent) { const t = e.routeConfig; if (t && t._loadedConfig) return t._loadedConfig; if (t && t.component) return null } return null }(i.snapshot), s = n ? n.module.componentFactoryResolver : null; e.attachRef = null, e.route = i, e.resolver = s, e.outlet && e.outlet.activateWith(i, s), this.activateChildRoutes(t, null, e.children) } } else this.activateChildRoutes(t, null, n) } } function jp(t) { Cp(t.value), t.children.forEach(jp) } class Bp { constructor(t, e) { this.routes = t, this.module = e } } function Hp(t) { return "function" == typeof t } function Up(t) { return t instanceof zd } const zp = Symbol("INITIAL_VALUE"); function $p() { return Tu(t => bu(t.map(t => t.pipe(Iu(1), Mu(zp)))).pipe(Nu((t, e) => { let n = !1; return e.reduce((t, i, s) => { if (t !== zp) return t; if (i === zp && (n = !0), !n) { if (!1 === i) return i; if (s === e.length - 1 || Up(i)) return i } return t }, t) }, zp), Vu(t => t !== zp), E(t => Up(t) ? t : !0 === t), Iu(1))) } let qp = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = zt({ type: t, selectors: [["ng-component"]], decls: 1, vars: 0, template: function (t, e) { 1 & t && xo(0, "router-outlet") }, directives: function () { return [zf] }, encapsulation: 2 }), t })(); function Wp(t, e = "") { for (let n = 0; n < t.length; n++) { const i = t[n]; Kp(i, Yp(e, i)) } } function Kp(t, e) { t.children && Wp(t.children, e) } function Yp(t, e) { return e ? t || e.path ? t && !e.path ? `${t}/` : !t && e.path ? e.path : `${t}/${e.path}` : "" : t } function Zp(t) { const e = t.children && t.children.map(Zp), n = e ? Object.assign(Object.assign({}, t), { children: e }) : Object.assign({}, t); return !n.component && (e || n.loadChildren) && n.outlet && n.outlet !== Ed && (n.component = qp), n } function Gp(t) { return t.outlet || Ed } function Qp(t, e) { const n = t.filter(t => Gp(t) === e); return n.push(...t.filter(t => Gp(t) !== e)), n } const Xp = { matched: !1, consumedSegments: [], lastChild: 0, parameters: {}, positionalParamSegments: {} }; function Jp(t, e, n) { var i; if ("" === e.path) return "full" === e.pathMatch && (t.hasChildren() || n.length > 0) ? Object.assign({}, Xp) : { matched: !0, consumedSegments: [], lastChild: 0, parameters: {}, positionalParamSegments: {} }; const s = (e.matcher || Od)(n, t, e); if (!s) return Object.assign({}, Xp); const r = {}; Nd(s.posParams, (t, e) => { r[e] = t.path }); const o = s.consumed.length > 0 ? Object.assign(Object.assign({}, r), s.consumed[s.consumed.length - 1].parameters) : r; return { matched: !0, consumedSegments: s.consumed, lastChild: s.consumed.length, parameters: o, positionalParamSegments: null !== (i = s.posParams) && void 0 !== i ? i : {} } } function tf(t, e, n, i, s = "corrected") { if (n.length > 0 && function (t, e, n) { return n.some(n => ef(t, e, n) && Gp(n) !== Ed) }(t, n, i)) { const s = new $d(e, function (t, e, n, i) { const s = {}; s.primary = i, i._sourceSegment = t, i._segmentIndexShift = e.length; for (const r of n) if ("" === r.path && Gp(r) !== Ed) { const n = new $d([], {}); n._sourceSegment = t, n._segmentIndexShift = e.length, s[Gp(r)] = n } return s }(t, e, i, new $d(n, t.children))); return s._sourceSegment = t, s._segmentIndexShift = e.length, { segmentGroup: s, slicedSegments: [] } } if (0 === n.length && function (t, e, n) { return n.some(n => ef(t, e, n)) }(t, n, i)) { const r = new $d(t.segments, function (t, e, n, i, s, r) { const o = {}; for (const a of i) if (ef(t, n, a) && !s[Gp(a)]) { const n = new $d([], {}); n._sourceSegment = t, n._segmentIndexShift = "legacy" === r ? t.segments.length : e.length, o[Gp(a)] = n } return Object.assign(Object.assign({}, s), o) }(t, e, n, i, t.children, s)); return r._sourceSegment = t, r._segmentIndexShift = e.length, { segmentGroup: r, slicedSegments: n } } const r = new $d(t.segments, t.children); return r._sourceSegment = t, r._segmentIndexShift = e.length, { segmentGroup: r, slicedSegments: n } } function ef(t, e, n) { return (!(t.hasChildren() || e.length > 0) || "full" !== n.pathMatch) && "" === n.path } function nf(t, e, n, i) { return !!(Gp(t) === i || i !== Ed && ef(e, n, t)) && ("**" === t.path || Jp(e, t, n).matched) } function sf(t, e, n) { return 0 === e.length && !t.children[n] } class rf { constructor(t) { this.segmentGroup = t || null } } class of { constructor(t) { this.urlTree = t } } function af(t) { return new y(e => e.error(new rf(t))) } function lf(t) { return new y(e => e.error(new of(t))) } function cf(t) { return new y(e => e.error(new Error(`Only absolute redirects can have named outlets. redirectTo: '${t}'`))) } class hf { constructor(t, e, n, i, s) { this.configLoader = e, this.urlSerializer = n, this.urlTree = i, this.config = s, this.allowRedirects = !0, this.ngModule = t.get(ml) } apply() { const t = tf(this.urlTree.root, [], [], this.config).segmentGroup, e = new $d(t.segments, t.children); return this.expandSegmentGroup(this.ngModule, this.config, e, Ed).pipe(E(t => this.createUrlTree(uf(t), this.urlTree.queryParams, this.urlTree.fragment))).pipe(Hu(t => { if (t instanceof of) return this.allowRedirects = !1, this.match(t.urlTree); if (t instanceof rf) throw this.noMatchError(t); throw t })) } match(t) { return this.expandSegmentGroup(this.ngModule, this.config, t.root, Ed).pipe(E(e => this.createUrlTree(uf(e), t.queryParams, t.fragment))).pipe(Hu(t => { if (t instanceof rf) throw this.noMatchError(t); throw t })) } noMatchError(t) { return new Error(`Cannot match any routes. URL Segment: '${t.segmentGroup}'`) } createUrlTree(t, e, n) { const i = t.segments.length > 0 ? new $d([], { [Ed]: t }) : t; return new zd(i, e, n) } expandSegmentGroup(t, e, n, i) { return 0 === n.segments.length && n.hasChildren() ? this.expandChildren(t, e, n).pipe(E(t => new $d([], t))) : this.expandSegment(t, n, e, n.segments, i, !0) } expandChildren(t, e, n) { const i = []; for (const s of Object.keys(n.children)) "primary" === s ? i.unshift(s) : i.push(s); return F(i).pipe($u(i => { const s = n.children[i], r = Qp(e, i); return this.expandSegmentGroup(t, r, s, i).pipe(E(t => ({ segment: t, outlet: i }))) }), Nu((t, e) => (t[e.outlet] = e.segment, t), {}), function (t, e) { const n = arguments.length >= 2; return i => i.pipe(t ? Vu((e, n) => t(e, n, i)) : _, qu(1), n ? Xu(e) : Yu(() => new Cu)) }()) } expandSegment(t, e, n, i, s, r) { return F(n).pipe($u(o => this.expandSegmentAgainstRoute(t, e, n, o, i, s, r).pipe(Hu(t => { if (t instanceof rf) return pu(null); throw t }))), ed(t => !!t), Hu((t, n) => { if (t instanceof Cu || "EmptyError" === t.name) { if (sf(e, i, s)) return pu(new $d([], {})); throw new rf(e) } throw t })) } expandSegmentAgainstRoute(t, e, n, i, s, r, o) { return nf(i, e, s, r) ? void 0 === i.redirectTo ? this.matchSegmentAgainstRoute(t, e, i, s, r) : o && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(t, e, n, i, s, r) : af(e) : af(e) } expandSegmentAgainstRouteUsingRedirect(t, e, n, i, s, r) { return "**" === i.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(t, n, i, r) : this.expandRegularSegmentAgainstRouteUsingRedirect(t, e, n, i, s, r) } expandWildCardWithParamsAgainstRouteUsingRedirect(t, e, n, i) { const s = this.applyRedirectCommands([], n.redirectTo, {}); return n.redirectTo.startsWith("/") ? lf(s) : this.lineralizeSegments(n, s).pipe(B(n => { const s = new $d(n, {}); return this.expandSegment(t, s, e, n, i, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(t, e, n, i, s, r) { const { matched: o, consumedSegments: a, lastChild: l, positionalParamSegments: c } = Jp(e, i, s); if (!o) return af(e); const h = this.applyRedirectCommands(a, i.redirectTo, c); return i.redirectTo.startsWith("/") ? lf(h) : this.lineralizeSegments(i, h).pipe(B(i => this.expandSegment(t, e, n, i.concat(s.slice(l)), r, !1))) } matchSegmentAgainstRoute(t, e, n, i, s) { if ("**" === n.path) return n.loadChildren ? (n._loadedConfig ? pu(n._loadedConfig) : this.configLoader.load(t.injector, n)).pipe(E(t => (n._loadedConfig = t, new $d(i, {})))) : pu(new $d(i, {})); const { matched: r, consumedSegments: o, lastChild: a } = Jp(e, n, i); if (!r) return af(e); const l = i.slice(a); return this.getChildConfig(t, n, i).pipe(B(t => { const i = t.module, r = t.routes, { segmentGroup: a, slicedSegments: c } = tf(e, o, l, r), h = new $d(a.segments, a.children); if (0 === c.length && h.hasChildren()) return this.expandChildren(i, r, h).pipe(E(t => new $d(o, t))); if (0 === r.length && 0 === c.length) return pu(new $d(o, {})); const u = Gp(n) === s; return this.expandSegment(i, h, r, c, u ? Ed : s, !0).pipe(E(t => new $d(o.concat(t.segments), t.children))) })) } getChildConfig(t, e, n) { return e.children ? pu(new Bp(e.children, t)) : e.loadChildren ? void 0 !== e._loadedConfig ? pu(e._loadedConfig) : this.runCanLoadGuards(t.injector, e, n).pipe(B(n => n ? this.configLoader.load(t.injector, e).pipe(E(t => (e._loadedConfig = t, t))) : function (t) { return new y(e => e.error(Ad(`Cannot load children because the guard of the route "path: '${t.path}'" returned false`))) }(e))) : pu(new Bp([], t)) } runCanLoadGuards(t, e, n) { const i = e.canLoad; return i && 0 !== i.length ? pu(i.map(i => { const s = t.get(i); let r; if (function (t) { return t && Hp(t.canLoad) }(s)) r = s.canLoad(e, n); else { if (!Hp(s)) throw new Error("Invalid CanLoad guard"); r = s(e, n) } return Fd(r) })).pipe($p(), id(t => { if (!Up(t)) return; const e = Ad(`Redirecting to "${this.urlSerializer.serialize(t)}"`); throw e.url = t, e }), E(t => !0 === t)) : pu(!0) } lineralizeSegments(t, e) { let n = [], i = e.root; for (; ;) { if (n = n.concat(i.segments), 0 === i.numberOfChildren) return pu(n); if (i.numberOfChildren > 1 || !i.children.primary) return cf(t.redirectTo); i = i.children.primary } } applyRedirectCommands(t, e, n) { return this.applyRedirectCreatreUrlTree(e, this.urlSerializer.parse(e), t, n) } applyRedirectCreatreUrlTree(t, e, n, i) { const s = this.createSegmentGroup(t, e.root, n, i); return new zd(s, this.createQueryParams(e.queryParams, this.urlTree.queryParams), e.fragment) } createQueryParams(t, e) { const n = {}; return Nd(t, (t, i) => { if ("string" == typeof t && t.startsWith(":")) { const s = t.substring(1); n[i] = e[s] } else n[i] = t }), n } createSegmentGroup(t, e, n, i) { const s = this.createSegments(t, e.segments, n, i); let r = {}; return Nd(e.children, (e, s) => { r[s] = this.createSegmentGroup(t, e, n, i) }), new $d(s, r) } createSegments(t, e, n, i) { return e.map(e => e.path.startsWith(":") ? this.findPosParam(t, e, i) : this.findOrReturn(e, n)) } findPosParam(t, e, n) { const i = n[e.path.substring(1)]; if (!i) throw new Error(`Cannot redirect to '${t}'. Cannot find '${e.path}'.`); return i } findOrReturn(t, e) { let n = 0; for (const i of e) { if (i.path === t.path) return e.splice(n), i; n++ } return t } } function uf(t) { const e = {}; for (const n of Object.keys(t.children)) { const i = uf(t.children[n]); (i.segments.length > 0 || i.hasChildren()) && (e[n] = i) } return function (t) { if (1 === t.numberOfChildren && t.children.primary) { const e = t.children.primary; return new $d(t.segments.concat(e.segments), e.children) } return t }(new $d(t.segments, e)) } class df { constructor(t) { this.path = t, this.route = this.path[this.path.length - 1] } } class pf { constructor(t, e) { this.component = t, this.route = e } } function ff(t, e, n) { const i = t._root; return gf(i, e ? e._root : null, n, [i.value]) } function mf(t, e, n) { const i = function (t) { if (!t) return null; for (let e = t.parent; e; e = e.parent) { const t = e.routeConfig; if (t && t._loadedConfig) return t._loadedConfig } return null }(e); return (i ? i.module.injector : n).get(t) } function gf(t, e, n, i, s = { canDeactivateChecks: [], canActivateChecks: [] }) { const r = pp(e); return t.children.forEach(t => { !function (t, e, n, i, s = { canDeactivateChecks: [], canActivateChecks: [] }) { const r = t.value, o = e ? e.value : null, a = n ? n.getContext(t.value.outlet) : null; if (o && r.routeConfig === o.routeConfig) { const l = function (t, e, n) { if ("function" == typeof n) return n(t, e); switch (n) { case "pathParamsChange": return !Wd(t.url, e.url); case "pathParamsOrQueryParamsChange": return !Wd(t.url, e.url) || !Id(t.queryParams, e.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !kp(t, e) || !Id(t.queryParams, e.queryParams); case "paramsChange": default: return !kp(t, e) } }(o, r, r.routeConfig.runGuardsAndResolvers); l ? s.canActivateChecks.push(new df(i)) : (r.data = o.data, r._resolvedData = o._resolvedData), gf(t, e, r.component ? a ? a.children : null : n, i, s), l && a && a.outlet && a.outlet.isActivated && s.canDeactivateChecks.push(new pf(a.outlet.component, o)) } else o && _f(e, a, s), s.canActivateChecks.push(new df(i)), gf(t, null, r.component ? a ? a.children : null : n, i, s) }(t, r[t.value.outlet], n, i.concat([t.value]), s), delete r[t.value.outlet] }), Nd(r, (t, e) => _f(t, n.getContext(e), s)), s } function _f(t, e, n) { const i = pp(t), s = t.value; Nd(i, (t, i) => { _f(t, s.component ? e ? e.children.getContext(i) : null : e, n) }), n.canDeactivateChecks.push(new pf(s.component && e && e.outlet && e.outlet.isActivated ? e.outlet.component : null, s)) } class yf { } function bf(t) { return new y(e => e.error(t)) } class vf { constructor(t, e, n, i, s, r) { this.rootComponentType = t, this.config = e, this.urlTree = n, this.url = i, this.paramsInheritanceStrategy = s, this.relativeLinkResolution = r } recognize() { const t = tf(this.urlTree.root, [], [], this.config.filter(t => void 0 === t.redirectTo), this.relativeLinkResolution).segmentGroup, e = this.processSegmentGroup(this.config, t, Ed); if (null === e) return null; const n = new yp([], Object.freeze({}), Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, {}, Ed, this.rootComponentType, null, this.urlTree.root, -1, {}), i = new dp(n, e), s = new bp(this.url, i); return this.inheritParamsAndData(s._root), s } inheritParamsAndData(t) { const e = t.value, n = _p(e, this.paramsInheritanceStrategy); e.params = Object.freeze(n.params), e.data = Object.freeze(n.data), t.children.forEach(t => this.inheritParamsAndData(t)) } processSegmentGroup(t, e, n) { return 0 === e.segments.length && e.hasChildren() ? this.processChildren(t, e) : this.processSegment(t, e, e.segments, n) } processChildren(t, e) { const n = []; for (const s of Object.keys(e.children)) { const i = e.children[s], r = Qp(t, s), o = this.processSegmentGroup(r, i, s); if (null === o) return null; n.push(...o) } const i = Cf(n); return i.sort((t, e) => t.value.outlet === Ed ? -1 : e.value.outlet === Ed ? 1 : t.value.outlet.localeCompare(e.value.outlet)), i } processSegment(t, e, n, i) { for (const s of t) { const t = this.processSegmentAgainstRoute(s, e, n, i); if (null !== t) return t } return sf(e, n, i) ? [] : null } processSegmentAgainstRoute(t, e, n, i) { if (t.redirectTo || !nf(t, e, n, i)) return null; let s, r = [], o = []; if ("**" === t.path) { const i = n.length > 0 ? Md(n).parameters : {}; s = new yp(n, i, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, Sf(t), Gp(t), t.component, t, kf(e), xf(e) + n.length, Ef(t)) } else { const i = Jp(e, t, n); if (!i.matched) return null; r = i.consumedSegments, o = n.slice(i.lastChild), s = new yp(r, i.parameters, Object.freeze(Object.assign({}, this.urlTree.queryParams)), this.urlTree.fragment, Sf(t), Gp(t), t.component, t, kf(e), xf(e) + r.length, Ef(t)) } const a = function (t) { return t.children ? t.children : t.loadChildren ? t._loadedConfig.routes : [] }(t), { segmentGroup: l, slicedSegments: c } = tf(e, r, o, a.filter(t => void 0 === t.redirectTo), this.relativeLinkResolution); if (0 === c.length && l.hasChildren()) { const t = this.processChildren(a, l); return null === t ? null : [new dp(s, t)] } if (0 === a.length && 0 === c.length) return [new dp(s, [])]; const h = Gp(t) === i, u = this.processSegment(a, l, c, h ? Ed : i); return null === u ? null : [new dp(s, u)] } } function wf(t) { const e = t.value.routeConfig; return e && "" === e.path && void 0 === e.redirectTo } function Cf(t) { const e = [], n = new Set; for (const i of t) { if (!wf(i)) { e.push(i); continue } const t = e.find(t => i.value.routeConfig === t.value.routeConfig); void 0 !== t ? (t.children.push(...i.children), n.add(t)) : e.push(i) } for (const i of n) { const t = Cf(i.children); e.push(new dp(i.value, t)) } return e.filter(t => !n.has(t)) } function kf(t) { let e = t; for (; e._sourceSegment;)e = e._sourceSegment; return e } function xf(t) { let e = t, n = e._segmentIndexShift ? e._segmentIndexShift : 0; for (; e._sourceSegment;)e = e._sourceSegment, n += e._segmentIndexShift ? e._segmentIndexShift : 0; return n - 1 } function Sf(t) { return t.data || {} } function Ef(t) { return t.resolve || {} } function Tf(t) { return Tu(e => { const n = t(e); return n ? F(n).pipe(E(() => e)) : pu(e) }) } class Rf extends class { shouldDetach(t) { return !1 } store(t, e) { } shouldAttach(t) { return !1 } retrieve(t) { return null } shouldReuseRoute(t, e) { return t.routeConfig === e.routeConfig } }{ } const Af = new $n("ROUTES"); class Of { constructor(t, e, n, i) { this.loader = t, this.compiler = e, this.onLoadStartListener = n, this.onLoadEndListener = i } load(t, e) { if (e._loader$) return e._loader$; this.onLoadStartListener && this.onLoadStartListener(e); const n = this.loadModuleFactory(e.loadChildren).pipe(E(n => { this.onLoadEndListener && this.onLoadEndListener(e); const i = n.create(t); return new Bp(Pd(i.injector.get(Af, void 0, wt.Self | wt.Optional)).map(Zp), i) }), Hu(t => { throw e._loader$ = void 0, t })); return e._loader$ = new Z(n, () => new k).pipe(W()), e._loader$ } loadModuleFactory(t) { return "string" == typeof t ? F(this.loader.load(t)) : Fd(t()).pipe(B(t => t instanceof gl ? pu(t) : F(this.compiler.compileModuleAsync(t)))) } } class If { constructor() { this.outlet = null, this.route = null, this.resolver = null, this.children = new Df, this.attachRef = null } } class Df { constructor() { this.contexts = new Map } onChildOutletCreated(t, e) { const n = this.getOrCreateContext(t); n.outlet = e, this.contexts.set(t, n) } onChildOutletDestroyed(t) { const e = this.getContext(t); e && (e.outlet = null) } onOutletDeactivated() { const t = this.contexts; return this.contexts = new Map, t } onOutletReAttached(t) { this.contexts = t } getOrCreateContext(t) { let e = this.getContext(t); return e || (e = new If, this.contexts.set(t, e)), e } getContext(t) { return this.contexts.get(t) || null } } class Pf { shouldProcessUrl(t) { return !0 } extract(t) { return t } merge(t, e) { return t } } function Mf(t) { throw t } function Nf(t, e, n) { return e.parse("/") } function Ff(t, e) { return pu(null) } const Lf = { paths: "exact", fragment: "ignored", matrixParams: "ignored", queryParams: "exact" }, Vf = { paths: "subset", fragment: "ignored", matrixParams: "ignored", queryParams: "subset" }; let jf = (() => { class t { constructor(t, e, n, i, s, r, o, a) { this.rootComponentType = t, this.urlSerializer = e, this.rootContexts = n, this.location = i, this.config = a, this.lastSuccessfulNavigation = null, this.currentNavigation = null, this.disposed = !1, this.lastLocationChangeInfo = null, this.navigationId = 0, this.isNgZoneEnabled = !1, this.events = new k, this.errorHandler = Mf, this.malformedUriErrorHandler = Nf, this.navigated = !1, this.lastSuccessfulId = -1, this.hooks = { beforePreactivation: Ff, afterPreactivation: Ff }, this.urlHandlingStrategy = new Pf, this.routeReuseStrategy = new Rf, this.onSameUrlNavigation = "ignore", this.paramsInheritanceStrategy = "emptyOnly", this.urlUpdateStrategy = "deferred", this.relativeLinkResolution = "corrected", this.ngModule = s.get(ml), this.console = s.get(ac); const l = s.get(vc); this.isNgZoneEnabled = l instanceof vc && vc.isInAngularZone(), this.resetConfig(a), this.currentUrlTree = new zd(new $d([], {}), {}, null), this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.configLoader = new Of(r, o, t => this.triggerEvent(new bd(t)), t => this.triggerEvent(new vd(t))), this.routerState = mp(this.currentUrlTree, this.rootComponentType), this.transitions = new fu({ id: 0, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree), urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree), rawUrl: this.currentUrlTree, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: "imperative", restoredState: null, currentSnapshot: this.routerState.snapshot, targetSnapshot: null, currentRouterState: this.routerState, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.navigations = this.setupNavigations(this.transitions), this.processNavigations() } setupNavigations(t) { const e = this.events; return t.pipe(Vu(t => 0 !== t.id), E(t => Object.assign(Object.assign({}, t), { extractedUrl: this.urlHandlingStrategy.extract(t.rawUrl) })), Tu(t => { let n = !1, i = !1; return pu(t).pipe(id(t => { this.currentNavigation = { id: t.id, initialUrl: t.currentRawUrl, extractedUrl: t.extractedUrl, trigger: t.source, extras: t.extras, previousNavigation: this.lastSuccessfulNavigation ? Object.assign(Object.assign({}, this.lastSuccessfulNavigation), { previousNavigation: null }) : null } }), Tu(t => { const n = !this.navigated || t.extractedUrl.toString() !== this.browserUrlTree.toString(); if (("reload" === this.onSameUrlNavigation || n) && this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)) return pu(t).pipe(Tu(t => { const n = this.transitions.getValue(); return e.next(new hd(t.id, this.serializeUrl(t.extractedUrl), t.source, t.restoredState)), n !== this.transitions.getValue() ? xu : Promise.resolve(t) }), function (t, e, n, i) { return Tu(s => function (t, e, n, i, s) { return new hf(t, e, n, i, s).apply() }(t, e, n, s.extractedUrl, i).pipe(E(t => Object.assign(Object.assign({}, s), { urlAfterRedirects: t })))) }(this.ngModule.injector, this.configLoader, this.urlSerializer, this.config), id(t => { this.currentNavigation = Object.assign(Object.assign({}, this.currentNavigation), { finalUrl: t.urlAfterRedirects }) }), function (t, e, n, i, s) { return B(r => function (t, e, n, i, s = "emptyOnly", r = "legacy") { try { const o = new vf(t, e, n, i, s, r).recognize(); return null === o ? bf(new yf) : pu(o) } catch (o) { return bf(o) } }(t, e, r.urlAfterRedirects, n(r.urlAfterRedirects), i, s).pipe(E(t => Object.assign(Object.assign({}, r), { targetSnapshot: t })))) }(this.rootComponentType, this.config, t => this.serializeUrl(t), this.paramsInheritanceStrategy, this.relativeLinkResolution), id(t => { "eager" === this.urlUpdateStrategy && (t.extras.skipLocationChange || this.setBrowserUrl(t.urlAfterRedirects, !!t.extras.replaceUrl, t.id, t.extras.state), this.browserUrlTree = t.urlAfterRedirects); const n = new fd(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); e.next(n) })); if (n && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) { const { id: n, extractedUrl: i, source: s, restoredState: r, extras: o } = t, a = new hd(n, this.serializeUrl(i), s, r); e.next(a); const l = mp(i, this.rootComponentType).snapshot; return pu(Object.assign(Object.assign({}, t), { targetSnapshot: l, urlAfterRedirects: i, extras: Object.assign(Object.assign({}, o), { skipLocationChange: !1, replaceUrl: !1 }) })) } return this.rawUrlTree = t.rawUrl, this.browserUrlTree = t.urlAfterRedirects, t.resolve(null), xu }), Tf(t => { const { targetSnapshot: e, id: n, extractedUrl: i, rawUrl: s, extras: { skipLocationChange: r, replaceUrl: o } } = t; return this.hooks.beforePreactivation(e, { navigationId: n, appliedUrlTree: i, rawUrlTree: s, skipLocationChange: !!r, replaceUrl: !!o }) }), id(t => { const e = new md(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) }), E(t => Object.assign(Object.assign({}, t), { guards: ff(t.targetSnapshot, t.currentSnapshot, this.rootContexts) })), function (t, e) { return B(n => { const { targetSnapshot: i, currentSnapshot: s, guards: { canActivateChecks: r, canDeactivateChecks: o } } = n; return 0 === o.length && 0 === r.length ? pu(Object.assign(Object.assign({}, n), { guardsResult: !0 })) : function (t, e, n, i) { return F(t).pipe(B(t => function (t, e, n, i, s) { const r = e && e.routeConfig ? e.routeConfig.canDeactivate : null; return r && 0 !== r.length ? pu(r.map(r => { const o = mf(r, e, s); let a; if (function (t) { return t && Hp(t.canDeactivate) }(o)) a = Fd(o.canDeactivate(t, e, n, i)); else { if (!Hp(o)) throw new Error("Invalid CanDeactivate guard"); a = Fd(o(t, e, n, i)) } return a.pipe(ed()) })).pipe($p()) : pu(!0) }(t.component, t.route, n, e, i)), ed(t => !0 !== t, !0)) }(o, i, s, t).pipe(B(n => n && "boolean" == typeof n ? function (t, e, n, i) { return F(e).pipe($u(e => ku(function (t, e) { return null !== t && e && e(new wd(t)), pu(!0) }(e.route.parent, i), function (t, e) { return null !== t && e && e(new kd(t)), pu(!0) }(e.route, i), function (t, e, n) { const i = e[e.length - 1], s = e.slice(0, e.length - 1).reverse().map(t => function (t) { const e = t.routeConfig ? t.routeConfig.canActivateChild : null; return e && 0 !== e.length ? { node: t, guards: e } : null }(t)).filter(t => null !== t).map(e => Eu(() => pu(e.guards.map(s => { const r = mf(s, e.node, n); let o; if (function (t) { return t && Hp(t.canActivateChild) }(r)) o = Fd(r.canActivateChild(i, t)); else { if (!Hp(r)) throw new Error("Invalid CanActivateChild guard"); o = Fd(r(i, t)) } return o.pipe(ed()) })).pipe($p()))); return pu(s).pipe($p()) }(t, e.path, n), function (t, e, n) { const i = e.routeConfig ? e.routeConfig.canActivate : null; return i && 0 !== i.length ? pu(i.map(i => Eu(() => { const s = mf(i, e, n); let r; if (function (t) { return t && Hp(t.canActivate) }(s)) r = Fd(s.canActivate(e, t)); else { if (!Hp(s)) throw new Error("Invalid CanActivate guard"); r = Fd(s(e, t)) } return r.pipe(ed()) }))).pipe($p()) : pu(!0) }(t, e.route, n))), ed(t => !0 !== t, !0)) }(i, r, t, e) : pu(n)), E(t => Object.assign(Object.assign({}, n), { guardsResult: t }))) }) }(this.ngModule.injector, t => this.triggerEvent(t)), id(t => { if (Up(t.guardsResult)) { const e = Ad(`Redirecting to "${this.serializeUrl(t.guardsResult)}"`); throw e.url = t.guardsResult, e } const e = new gd(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult); this.triggerEvent(e) }), Vu(t => { if (!t.guardsResult) { this.resetUrlToCurrentUrlTree(); const n = new dd(t.id, this.serializeUrl(t.extractedUrl), ""); return e.next(n), t.resolve(!1), !1 } return !0 }), Tf(t => { if (t.guards.canActivateChecks.length) return pu(t).pipe(id(t => { const e = new _d(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) }), Tu(t => { let n = !1; return pu(t).pipe((i = this.paramsInheritanceStrategy, s = this.ngModule.injector, B(t => { const { targetSnapshot: e, guards: { canActivateChecks: n } } = t; if (!n.length) return pu(t); let r = 0; return F(n).pipe($u(t => function (t, e, n, i) { return function (t, e, n, i) { const s = Object.keys(t); if (0 === s.length) return pu({}); const r = {}; return F(s).pipe(B(s => function (t, e, n, i) { const s = mf(t, e, i); return Fd(s.resolve ? s.resolve(e, n) : s(e, n)) }(t[s], e, n, i).pipe(id(t => { r[s] = t }))), qu(1), B(() => Object.keys(r).length === s.length ? pu(r) : xu)) }(t._resolve, t, e, i).pipe(E(e => (t._resolvedData = e, t.data = Object.assign(Object.assign({}, t.data), _p(t, n).resolve), null))) }(t.route, e, i, s)), id(() => r++), qu(1), B(e => r === n.length ? pu(t) : xu)) })), id({ next: () => n = !0, complete: () => { if (!n) { const n = new dd(t.id, this.serializeUrl(t.extractedUrl), "At least one route resolver didn't emit any value."); e.next(n), t.resolve(!1) } } })); var i, s }), id(t => { const e = new yd(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot); this.triggerEvent(e) })) }), Tf(t => { const { targetSnapshot: e, id: n, extractedUrl: i, rawUrl: s, extras: { skipLocationChange: r, replaceUrl: o } } = t; return this.hooks.afterPreactivation(e, { navigationId: n, appliedUrlTree: i, rawUrlTree: s, skipLocationChange: !!r, replaceUrl: !!o }) }), E(t => { const e = function (t, e, n) { const i = xp(t, e._root, n ? n._root : void 0); return new fp(i, e) }(this.routeReuseStrategy, t.targetSnapshot, t.currentRouterState); return Object.assign(Object.assign({}, t), { targetRouterState: e }) }), id(t => { this.currentUrlTree = t.urlAfterRedirects, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, t.rawUrl), this.routerState = t.targetRouterState, "deferred" === this.urlUpdateStrategy && (t.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, !!t.extras.replaceUrl, t.id, t.extras.state), this.browserUrlTree = t.urlAfterRedirects) }), (s = this.rootContexts, r = this.routeReuseStrategy, o = t => this.triggerEvent(t), E(t => (new Vp(r, t.targetRouterState, t.currentRouterState, o).activate(s), t))), id({ next() { n = !0 }, complete() { n = !0 } }), od(() => { if (!n && !i) { this.resetUrlToCurrentUrlTree(); const n = new dd(t.id, this.serializeUrl(t.extractedUrl), `Navigation ID ${t.id} is not equal to the current navigation id ${this.navigationId}`); e.next(n), t.resolve(!1) } this.currentNavigation = null }), Hu(n => { if (i = !0, (s = n) && s.ngNavigationCancelingError) { const i = Up(n.url); i || (this.navigated = !0, this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl)); const s = new dd(t.id, this.serializeUrl(t.extractedUrl), n.message); e.next(s), i ? setTimeout(() => { const e = this.urlHandlingStrategy.merge(n.url, this.rawUrlTree); this.scheduleNavigation(e, "imperative", null, { skipLocationChange: t.extras.skipLocationChange, replaceUrl: "eager" === this.urlUpdateStrategy }, { resolve: t.resolve, reject: t.reject, promise: t.promise }) }, 0) : t.resolve(!1) } else { this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl); const i = new pd(t.id, this.serializeUrl(t.extractedUrl), n); e.next(i); try { t.resolve(this.errorHandler(n)) } catch (r) { t.reject(r) } } var s; return xu })); var s, r, o })) } resetRootComponentType(t) { this.rootComponentType = t, this.routerState.root.component = this.rootComponentType } getTransition() { const t = this.transitions.value; return t.urlAfterRedirects = this.browserUrlTree, t } setTransition(t) { this.transitions.next(Object.assign(Object.assign({}, this.getTransition()), t)) } initialNavigation() { this.setUpLocationChangeListener(), 0 === this.navigationId && this.navigateByUrl(this.location.path(!0), { replaceUrl: !0 }) } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(t => { const e = this.extractLocationChangeInfoFromEvent(t); this.shouldScheduleNavigation(this.lastLocationChangeInfo, e) && setTimeout(() => { const { source: t, state: n, urlTree: i } = e, s = { replaceUrl: !0 }; if (n) { const t = Object.assign({}, n); delete t.navigationId, 0 !== Object.keys(t).length && (s.state = t) } this.scheduleNavigation(i, t, n, s) }, 0), this.lastLocationChangeInfo = e })) } extractLocationChangeInfoFromEvent(t) { var e; return { source: "popstate" === t.type ? "popstate" : "hashchange", urlTree: this.parseUrl(t.url), state: (null === (e = t.state) || void 0 === e ? void 0 : e.navigationId) ? t.state : null, transitionId: this.getTransition().id } } shouldScheduleNavigation(t, e) { if (!t) return !0; const n = e.urlTree.toString() === t.urlTree.toString(); return !(e.transitionId === t.transitionId && n && ("hashchange" === e.source && "popstate" === t.source || "popstate" === e.source && "hashchange" === t.source)) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.currentNavigation } triggerEvent(t) { this.events.next(t) } resetConfig(t) { Wp(t), this.config = t.map(Zp), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.transitions.complete(), this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = void 0), this.disposed = !0 } createUrlTree(t, e = {}) { const { relativeTo: n, queryParams: i, fragment: s, queryParamsHandling: r, preserveFragment: o } = e, a = n || this.routerState.root, l = o ? this.currentUrlTree.fragment : s; let c = null; switch (r) { case "merge": c = Object.assign(Object.assign({}, this.currentUrlTree.queryParams), i); break; case "preserve": c = this.currentUrlTree.queryParams; break; default: c = i || null }return null !== c && (c = this.removeEmptyProps(c)), function (t, e, n, i, s) { if (0 === n.length) return Rp(e.root, e.root, e, i, s); const r = function (t) { if ("string" == typeof t[0] && 1 === t.length && "/" === t[0]) return new Op(!0, 0, t); let e = 0, n = !1; const i = t.reduce((t, i, s) => { if ("object" == typeof i && null != i) { if (i.outlets) { const e = {}; return Nd(i.outlets, (t, n) => { e[n] = "string" == typeof t ? t.split("/") : t }), [...t, { outlets: e }] } if (i.segmentPath) return [...t, i.segmentPath] } return "string" != typeof i ? [...t, i] : 0 === s ? (i.split("/").forEach((i, s) => { 0 == s && "." === i || (0 == s && "" === i ? n = !0 : ".." === i ? e++ : "" != i && t.push(i)) }), t) : [...t, i] }, []); return new Op(n, e, i) }(n); if (r.toRoot()) return Rp(e.root, new $d([], {}), e, i, s); const o = function (t, e, n) { if (t.isAbsolute) return new Ip(e.root, !0, 0); if (-1 === n.snapshot._lastPathIndex) { const t = n.snapshot._urlSegment; return new Ip(t, t === e.root, 0) } const i = Ep(t.commands[0]) ? 0 : 1; return function (t, e, n) { let i = t, s = e, r = n; for (; r > s;) { if (r -= s, i = i.parent, !i) throw new Error("Invalid number of '../'"); s = i.segments.length } return new Ip(i, !1, s - r) }(n.snapshot._urlSegment, n.snapshot._lastPathIndex + i, t.numberOfDoubleDots) }(r, e, t), a = o.processChildren ? Pp(o.segmentGroup, o.index, r.commands) : Dp(o.segmentGroup, o.index, r.commands); return Rp(o.segmentGroup, a, e, i, s) }(a, this.currentUrlTree, t, c, null != l ? l : null) } navigateByUrl(t, e = { skipLocationChange: !1 }) { const n = Up(t) ? t : this.parseUrl(t), i = this.urlHandlingStrategy.merge(n, this.rawUrlTree); return this.scheduleNavigation(i, "imperative", null, e) } navigate(t, e = { skipLocationChange: !1 }) { return function (t) { for (let e = 0; e < t.length; e++) { const n = t[e]; if (null == n) throw new Error(`The requested path contains ${n} segment at index ${e}`) } }(t), this.navigateByUrl(this.createUrlTree(t, e), e) } serializeUrl(t) { return this.urlSerializer.serialize(t) } parseUrl(t) { let e; try { e = this.urlSerializer.parse(t) } catch (n) { e = this.malformedUriErrorHandler(n, this.urlSerializer, t) } return e } isActive(t, e) { let n; if (n = !0 === e ? Object.assign({}, Lf) : !1 === e ? Object.assign({}, Vf) : e, Up(t)) return jd(this.currentUrlTree, t, n); const i = this.parseUrl(t); return jd(this.currentUrlTree, i, n) } removeEmptyProps(t) { return Object.keys(t).reduce((e, n) => { const i = t[n]; return null != i && (e[n] = i), e }, {}) } processNavigations() { this.navigations.subscribe(t => { this.navigated = !0, this.lastSuccessfulId = t.id, this.events.next(new ud(t.id, this.serializeUrl(t.extractedUrl), this.serializeUrl(this.currentUrlTree))), this.lastSuccessfulNavigation = this.currentNavigation, t.resolve(!0) }, t => { this.console.warn("Unhandled Navigation Error: ") }) } scheduleNavigation(t, e, n, i, s) { if (this.disposed) return Promise.resolve(!1); const r = this.getTransition(), o = "imperative" !== e && "imperative" === (null == r ? void 0 : r.source), a = (this.lastSuccessfulId === r.id || this.currentNavigation ? r.rawUrl : r.urlAfterRedirects).toString() === t.toString(); if (o && a) return Promise.resolve(!0); let l, c, h; s ? (l = s.resolve, c = s.reject, h = s.promise) : h = new Promise((t, e) => { l = t, c = e }); const u = ++this.navigationId; return this.setTransition({ id: u, source: e, restoredState: n, currentUrlTree: this.currentUrlTree, currentRawUrl: this.rawUrlTree, rawUrl: t, extras: i, resolve: l, reject: c, promise: h, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), h.catch(t => Promise.reject(t)) } setBrowserUrl(t, e, n, i) { const s = this.urlSerializer.serialize(t); i = i || {}, this.location.isCurrentPathEqualTo(s) || e ? this.location.replaceState(s, "", Object.assign(Object.assign({}, i), { navigationId: n })) : this.location.go(s, "", Object.assign(Object.assign({}, i), { navigationId: n })) } resetStateAndUrl(t, e, n) { this.routerState = t, this.currentUrlTree = e, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, n), this.resetUrlToCurrentUrlTree() } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", { navigationId: this.lastSuccessfulId }) } } return t.\u0275fac = function (e) { return new (e || t)(li(Wn), li(Kd), li(Df), li(fh), li(no), li(zc), li(_c), li(void 0)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), Bf = (() => { class t { constructor(t, e, n, i, s) { this.router = t, this.route = e, this.commands = [], this.onChanges = new k, null == n && i.setAttribute(s.nativeElement, "tabindex", "0") } ngOnChanges(t) { this.onChanges.next(this) } set routerLink(t) { this.commands = null != t ? Array.isArray(t) ? t : [t] : [] } onClick() { const t = { skipLocationChange: Uf(this.skipLocationChange), replaceUrl: Uf(this.replaceUrl), state: this.state }; return this.router.navigateByUrl(this.urlTree, t), !0 } get urlTree() { return this.router.createUrlTree(this.commands, { relativeTo: void 0 !== this.relativeTo ? this.relativeTo : this.route, queryParams: this.queryParams, fragment: this.fragment, queryParamsHandling: this.queryParamsHandling, preserveFragment: Uf(this.preserveFragment) }) } } return t.\u0275fac = function (e) { return new (e || t)(bo(jf), bo(gp), Hn("tabindex"), bo(La), bo(Ma)) }, t.\u0275dir = Zt({ type: t, selectors: [["", "routerLink", "", 5, "a", 5, "area"]], hostBindings: function (t, e) { 1 & t && Io("click", function () { return e.onClick() }) }, inputs: { routerLink: "routerLink", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", state: "state", relativeTo: "relativeTo" }, features: [le] }), t })(), Hf = (() => { class t { constructor(t, e, n) { this.router = t, this.route = e, this.locationStrategy = n, this.commands = [], this.onChanges = new k, this.subscription = t.events.subscribe(t => { t instanceof ud && this.updateTargetUrlAndHref() }) } set routerLink(t) { this.commands = null != t ? Array.isArray(t) ? t : [t] : [] } ngOnChanges(t) { this.updateTargetUrlAndHref(), this.onChanges.next(this) } ngOnDestroy() { this.subscription.unsubscribe() } onClick(t, e, n, i, s) { if (0 !== t || e || n || i || s) return !0; if ("string" == typeof this.target && "_self" != this.target) return !0; const r = { skipLocationChange: Uf(this.skipLocationChange), replaceUrl: Uf(this.replaceUrl), state: this.state }; return this.router.navigateByUrl(this.urlTree, r), !1 } updateTargetUrlAndHref() { this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree)) } get urlTree() { return this.router.createUrlTree(this.commands, { relativeTo: void 0 !== this.relativeTo ? this.relativeTo : this.route, queryParams: this.queryParams, fragment: this.fragment, queryParamsHandling: this.queryParamsHandling, preserveFragment: Uf(this.preserveFragment) }) } } return t.\u0275fac = function (e) { return new (e || t)(bo(jf), bo(gp), bo(ch)) }, t.\u0275dir = Zt({ type: t, selectors: [["a", "routerLink", ""], ["area", "routerLink", ""]], hostVars: 2, hostBindings: function (t, e) { 1 & t && Io("click", function (t) { return e.onClick(t.button, t.ctrlKey, t.shiftKey, t.altKey, t.metaKey) }), 2 & t && (ha("href", e.href, Zi), mo("target", e.target)) }, inputs: { routerLink: "routerLink", target: "target", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", preserveFragment: "preserveFragment", skipLocationChange: "skipLocationChange", replaceUrl: "replaceUrl", state: "state", relativeTo: "relativeTo" }, features: [le] }), t })(); function Uf(t) { return "" === t || !!t } let zf = (() => { class t { constructor(t, e, n, i, s) { this.parentContexts = t, this.location = e, this.resolver = n, this.changeDetector = s, this.activated = null, this._activatedRoute = null, this.activateEvents = new Ml, this.deactivateEvents = new Ml, this.name = i || Ed, t.onChildOutletCreated(this.name, this) } ngOnDestroy() { this.parentContexts.onChildOutletDestroyed(this.name) } ngOnInit() { if (!this.activated) { const t = this.parentContexts.getContext(this.name); t && t.route && (t.attachRef ? this.attach(t.attachRef, t.route) : this.activateWith(t.route, t.resolver || null)) } } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new Error("Outlet is not activated"); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new Error("Outlet is not activated"); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new Error("Outlet is not activated"); this.location.detach(); const t = this.activated; return this.activated = null, this._activatedRoute = null, t } attach(t, e) { this.activated = t, this._activatedRoute = e, this.location.insert(t.hostView) } deactivate() { if (this.activated) { const t = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(t) } } activateWith(t, e) { if (this.isActivated) throw new Error("Cannot activate an already activated outlet"); this._activatedRoute = t; const n = (e = e || this.resolver).resolveComponentFactory(t._futureSnapshot.routeConfig.component), i = this.parentContexts.getOrCreateContext(this.name).children, s = new $f(t, i, this.location.injector); this.activated = this.location.createComponent(n, this.location.length, s), this.changeDetector.markForCheck(), this.activateEvents.emit(this.activated.instance) } } return t.\u0275fac = function (e) { return new (e || t)(bo(Df), bo(yl), bo(Oa), Hn("name"), bo(ol)) }, t.\u0275dir = Zt({ type: t, selectors: [["router-outlet"]], outputs: { activateEvents: "activate", deactivateEvents: "deactivate" }, exportAs: ["outlet"] }), t })(); class $f { constructor(t, e, n) { this.route = t, this.childContexts = e, this.parent = n } get(t, e) { return t === gp ? this.route : t === Df ? this.childContexts : this.parent.get(t, e) } } class qf { } class Wf { preload(t, e) { return pu(null) } } let Kf = (() => { class t { constructor(t, e, n, i, s) { this.router = t, this.injector = i, this.preloadingStrategy = s, this.loader = new Of(e, n, e => t.triggerEvent(new bd(e)), e => t.triggerEvent(new vd(e))) } setUpPreloading() { this.subscription = this.router.events.pipe(Vu(t => t instanceof ud), $u(() => this.preload())).subscribe(() => { }) } preload() { const t = this.injector.get(ml); return this.processRoutes(t, this.router.config) } ngOnDestroy() { this.subscription && this.subscription.unsubscribe() } processRoutes(t, e) { const n = []; for (const i of e) if (i.loadChildren && !i.canLoad && i._loadedConfig) { const t = i._loadedConfig; n.push(this.processRoutes(t.module, t.routes)) } else i.loadChildren && !i.canLoad ? n.push(this.preloadConfig(t, i)) : i.children && n.push(this.processRoutes(t, i.children)); return F(n).pipe(z(), E(t => { })) } preloadConfig(t, e) { return this.preloadingStrategy.preload(e, () => (e._loadedConfig ? pu(e._loadedConfig) : this.loader.load(t.injector, e)).pipe(B(t => (e._loadedConfig = t, this.processRoutes(t.module, t.routes))))) } } return t.\u0275fac = function (e) { return new (e || t)(li(jf), li(zc), li(_c), li(no), li(qf)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), Yf = (() => { class t { constructor(t, e, n = {}) { this.router = t, this.viewportScroller = e, this.options = n, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, n.scrollPositionRestoration = n.scrollPositionRestoration || "disabled", n.anchorScrolling = n.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.router.events.subscribe(t => { t instanceof hd ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = t.navigationTrigger, this.restoredId = t.restoredState ? t.restoredState.navigationId : 0) : t instanceof ud && (this.lastId = t.id, this.scheduleScrollEvent(t, this.router.parseUrl(t.urlAfterRedirects).fragment)) }) } consumeScrollEvents() { return this.router.events.subscribe(t => { t instanceof Sd && (t.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(t.position) : t.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(t.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(t, e) { this.router.triggerEvent(new Sd(t, "popstate" === this.lastSource ? this.store[this.restoredId] : null, e)) } ngOnDestroy() { this.routerEventsSubscription && this.routerEventsSubscription.unsubscribe(), this.scrollEventsSubscription && this.scrollEventsSubscription.unsubscribe() } } return t.\u0275fac = function (e) { return new (e || t)(li(jf), li(Oh), li(void 0)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const Zf = new $n("ROUTER_CONFIGURATION"), Gf = new $n("ROUTER_FORROOT_GUARD"), Qf = [fh, { provide: Kd, useClass: Yd }, { provide: jf, useFactory: function (t, e, n, i, s, r, o, a = {}, l, c) { const h = new jf(null, t, e, n, i, s, r, Pd(o)); return l && (h.urlHandlingStrategy = l), c && (h.routeReuseStrategy = c), function (t, e) { t.errorHandler && (e.errorHandler = t.errorHandler), t.malformedUriErrorHandler && (e.malformedUriErrorHandler = t.malformedUriErrorHandler), t.onSameUrlNavigation && (e.onSameUrlNavigation = t.onSameUrlNavigation), t.paramsInheritanceStrategy && (e.paramsInheritanceStrategy = t.paramsInheritanceStrategy), t.relativeLinkResolution && (e.relativeLinkResolution = t.relativeLinkResolution), t.urlUpdateStrategy && (e.urlUpdateStrategy = t.urlUpdateStrategy) }(a, h), a.enableTracing && h.events.subscribe(t => { var e, n; null === (e = console.group) || void 0 === e || e.call(console, `Router Event: ${t.constructor.name}`), console.log(t.toString()), console.log(t), null === (n = console.groupEnd) || void 0 === n || n.call(console) }), h }, deps: [Kd, Df, fh, no, zc, _c, Af, Zf, [class { }, new pi], [class { }, new pi]] }, Df, { provide: gp, useFactory: function (t) { return t.routerState.root }, deps: [jf] }, { provide: zc, useClass: Wc }, Kf, Wf, class { preload(t, e) { return e().pipe(Hu(() => pu(null))) } }, { provide: Zf, useValue: { enableTracing: !1 } }]; function Xf() { return new Fc("Router", jf) } let Jf = (() => { class t { constructor(t, e) { } static forRoot(e, n) { return { ngModule: t, providers: [Qf, im(e), { provide: Gf, useFactory: nm, deps: [[jf, new pi, new fi]] }, { provide: Zf, useValue: n || {} }, { provide: ch, useFactory: em, deps: [th, [new di(uh), new pi], Zf] }, { provide: Yf, useFactory: tm, deps: [jf, Oh, Zf] }, { provide: qf, useExisting: n && n.preloadingStrategy ? n.preloadingStrategy : Wf }, { provide: Fc, multi: !0, useFactory: Xf }, [sm, { provide: Jl, multi: !0, useFactory: rm, deps: [sm] }, { provide: am, useFactory: om, deps: [sm] }, { provide: oc, multi: !0, useExisting: am }]] } } static forChild(e) { return { ngModule: t, providers: [im(e)] } } } return t.\u0275fac = function (e) { return new (e || t)(li(Gf, 8), li(jf, 8)) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({}), t })(); function tm(t, e, n) { return n.scrollOffset && e.setOffset(n.scrollOffset), new Yf(t, e, n) } function em(t, e, n = {}) { return n.useHash ? new ph(t, e) : new dh(t, e) } function nm(t) { return "guarded" } function im(t) { return [{ provide: qn, multi: !0, useValue: t }, { provide: Af, multi: !0, useValue: t }] } let sm = (() => { class t { constructor(t) { this.injector = t, this.initNavigation = !1, this.resultOfPreactivationDone = new k } appInitializer() { return this.injector.get(nh, Promise.resolve(null)).then(() => { let t = null; const e = new Promise(e => t = e), n = this.injector.get(jf), i = this.injector.get(Zf); return "disabled" === i.initialNavigation ? (n.setUpLocationChangeListener(), t(!0)) : "enabled" === i.initialNavigation || "enabledBlocking" === i.initialNavigation ? (n.hooks.afterPreactivation = () => this.initNavigation ? pu(null) : (this.initNavigation = !0, t(!0), this.resultOfPreactivationDone), n.initialNavigation()) : t(!0), e }) } bootstrapListener(t) { const e = this.injector.get(Zf), n = this.injector.get(Kf), i = this.injector.get(Yf), s = this.injector.get(jf), r = this.injector.get(Hc); t === r.components[0] && ("enabledNonBlocking" !== e.initialNavigation && void 0 !== e.initialNavigation || s.initialNavigation(), n.setUpPreloading(), i.init(), s.resetRootComponentType(r.componentTypes[0]), this.resultOfPreactivationDone.next(null), this.resultOfPreactivationDone.complete()) } } return t.\u0275fac = function (e) { return new (e || t)(li(no)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); function rm(t) { return t.appInitializer.bind(t) } function om(t) { return t.bootstrapListener.bind(t) } const am = new $n("Router Initializer"); function lm(t) { return null != t && "false" != `${t}` } function cm(t, e = 0) { return hm(t) ? Number(t) : e } function hm(t) { return !isNaN(parseFloat(t)) && !isNaN(Number(t)) } function um(t) { return Array.isArray(t) ? t : [t] } function dm(t) { return null == t ? "" : "string" == typeof t ? t : `${t}px` } function pm(t) { return t instanceof Ma ? t.nativeElement : t } function fm(t) { return t && "function" == typeof t.connect } class mm { applyChanges(t, e, n, i, s) { t.forEachOperation((t, i, r) => { let o, a; if (null == t.previousIndex) { const s = n(t, i, r); o = e.createEmbeddedView(s.templateRef, s.context, s.index), a = 1 } else null == r ? (e.remove(i), a = 3) : (o = e.get(i), e.move(o, r), a = 2); s && s({ context: null == o ? void 0 : o.context, operation: a, record: t }) }) } detach() { } } class gm { constructor(t = !1, e, n = !0) { this._multiple = t, this._emitChanges = n, this._selection = new Set, this._deselectedToEmit = [], this._selectedToEmit = [], this.changed = new k, e && e.length && (t ? e.forEach(t => this._markSelected(t)) : this._markSelected(e[0]), this._selectedToEmit.length = 0) } get selected() { return this._selected || (this._selected = Array.from(this._selection.values())), this._selected } select(...t) { this._verifyValueAssignment(t), t.forEach(t => this._markSelected(t)), this._emitChangeEvent() } deselect(...t) { this._verifyValueAssignment(t), t.forEach(t => this._unmarkSelected(t)), this._emitChangeEvent() } toggle(t) { this.isSelected(t) ? this.deselect(t) : this.select(t) } clear() { this._unmarkAll(), this._emitChangeEvent() } isSelected(t) { return this._selection.has(t) } isEmpty() { return 0 === this._selection.size } hasValue() { return !this.isEmpty() } sort(t) { this._multiple && this.selected && this._selected.sort(t) } isMultipleSelection() { return this._multiple } _emitChangeEvent() { this._selected = null, (this._selectedToEmit.length || this._deselectedToEmit.length) && (this.changed.next({ source: this, added: this._selectedToEmit, removed: this._deselectedToEmit }), this._deselectedToEmit = [], this._selectedToEmit = []) } _markSelected(t) { this.isSelected(t) || (this._multiple || this._unmarkAll(), this._selection.add(t), this._emitChanges && this._selectedToEmit.push(t)) } _unmarkSelected(t) { this.isSelected(t) && (this._selection.delete(t), this._emitChanges && this._deselectedToEmit.push(t)) } _unmarkAll() { this.isEmpty() || this._selection.forEach(t => this._unmarkSelected(t)) } _verifyValueAssignment(t) { } } const _m = new $n("_ViewRepeater"), ym = new $n("cdk-dir-doc", { providedIn: "root", factory: function () { return ci(Jc) } }); let bm, vm = (() => { class t { constructor(t) { if (this.value = "ltr", this.change = new Ml, t) { const e = t.documentElement ? t.documentElement.dir : null, n = (t.body ? t.body.dir : null) || e; this.value = "ltr" === n || "rtl" === n ? n : "ltr" } } ngOnDestroy() { this.change.complete() } } return t.\u0275fac = function (e) { return new (e || t)(li(ym, 8)) }, t.\u0275prov = dt({ factory: function () { return new t(li(ym, 8)) }, token: t, providedIn: "root" }), t })(), wm = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({}), t })(); try { bm = "undefined" != typeof Intl && Intl.v8BreakIterator } catch (DA) { bm = !1 } let Cm, km = (() => { class t { constructor(t) { this._platformId = t, this.isBrowser = this._platformId ? "browser" === this._platformId : "object" == typeof document && !!document, this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent), this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent), this.BLINK = this.isBrowser && !(!window.chrome && !bm) && "undefined" != typeof CSS && !this.EDGE && !this.TRIDENT, this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT, this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window), this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent), this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT, this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT } } return t.\u0275fac = function (e) { return new (e || t)(li(rc)) }, t.\u0275prov = dt({ factory: function () { return new t(li(rc)) }, token: t, providedIn: "root" }), t })(), xm = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({}), t })(); const Sm = ["color", "button", "checkbox", "date", "datetime-local", "email", "file", "hidden", "image", "month", "number", "password", "radio", "range", "reset", "search", "submit", "tel", "text", "time", "url", "week"]; function Em() { if (Cm) return Cm; if ("object" != typeof document || !document) return Cm = new Set(Sm), Cm; let t = document.createElement("input"); return Cm = new Set(Sm.filter(e => (t.setAttribute("type", e), t.type === e))), Cm } let Tm, Rm, Am; function Om(t) { return function () { if (null == Tm && "undefined" != typeof window) try { window.addEventListener("test", null, Object.defineProperty({}, "passive", { get: () => Tm = !0 })) } finally { Tm = Tm || !1 } return Tm }() ? t : !!t.capture } function Im() { if (null == Rm) { if ("object" != typeof document || !document || "function" != typeof Element || !Element) return Rm = !1, Rm; if ("scrollBehavior" in document.documentElement.style) Rm = !0; else { const t = Element.prototype.scrollTo; Rm = !!t && !/\{\s*\[native code\]\s*\}/.test(t.toString()) } } return Rm } function Dm() { let t = "undefined" != typeof document && document ? document.activeElement : null; for (; t && t.shadowRoot;) { const e = t.shadowRoot.activeElement; if (e === t) break; t = e } return t } function Pm(t, e, n, s) { return i(n) && (s = n, n = void 0), s ? Pm(t, e, n).pipe(E(t => l(t) ? s(...t) : s(t))) : new y(i => { Mm(t, e, function (t) { i.next(arguments.length > 1 ? Array.prototype.slice.call(arguments) : t) }, i, n) }) } function Mm(t, e, n, i, s) { let r; if (function (t) { return t && "function" == typeof t.addEventListener && "function" == typeof t.removeEventListener }(t)) { const i = t; t.addEventListener(e, n, s), r = () => i.removeEventListener(e, n, s) } else if (function (t) { return t && "function" == typeof t.on && "function" == typeof t.off }(t)) { const i = t; t.on(e, n), r = () => i.off(e, n) } else if (function (t) { return t && "function" == typeof t.addListener && "function" == typeof t.removeListener }(t)) { const i = t; t.addListener(e, n), r = () => i.removeListener(e, n) } else { if (!t || !t.length) throw new TypeError("Invalid event target"); for (let r = 0, o = t.length; r < o; r++)Mm(t[r], e, n, i, s) } i.add(r) } class Nm extends u { constructor(t, e) { super() } schedule(t, e = 0) { return this } } class Fm extends Nm { constructor(t, e) { super(t, e), this.scheduler = t, this.work = e, this.pending = !1 } schedule(t, e = 0) { if (this.closed) return this; this.state = t; const n = this.id, i = this.scheduler; return null != n && (this.id = this.recycleAsyncId(i, n, e)), this.pending = !0, this.delay = e, this.id = this.id || this.requestAsyncId(i, this.id, e), this } requestAsyncId(t, e, n = 0) { return setInterval(t.flush.bind(t, this), n) } recycleAsyncId(t, e, n = 0) { if (null !== n && this.delay === n && !1 === this.pending) return e; clearInterval(e) } execute(t, e) { if (this.closed) return new Error("executing a cancelled action"); this.pending = !1; const n = this._execute(t, e); if (n) return n; !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null)) } _execute(t, e) { let n, i = !1; try { this.work(t) } catch (s) { i = !0, n = !!s && s || new Error(s) } if (i) return this.unsubscribe(), n } _unsubscribe() { const t = this.id, e = this.scheduler, n = e.actions, i = n.indexOf(this); this.work = null, this.state = null, this.pending = !1, this.scheduler = null, -1 !== i && n.splice(i, 1), null != t && (this.id = this.recycleAsyncId(e, t, null)), this.delay = null } } let Lm = (() => { class t { constructor(e, n = t.now) { this.SchedulerAction = e, this.now = n } schedule(t, e = 0, n) { return new this.SchedulerAction(this, t).schedule(n, e) } } return t.now = () => Date.now(), t })(); class Vm extends Lm { constructor(t, e = Lm.now) { super(t, () => Vm.delegate && Vm.delegate !== this ? Vm.delegate.now() : e()), this.actions = [], this.active = !1, this.scheduled = void 0 } schedule(t, e = 0, n) { return Vm.delegate && Vm.delegate !== this ? Vm.delegate.schedule(t, e, n) : super.schedule(t, e, n) } flush(t) { const { actions: e } = this; if (this.active) return void e.push(t); let n; this.active = !0; do { if (n = t.execute(t.state, t.delay)) break } while (t = e.shift()); if (this.active = !1, n) { for (; t = e.shift();)t.unsubscribe(); throw n } } } class jm { constructor(t, e) { this.compare = t, this.keySelector = e } call(t, e) { return e.subscribe(new Bm(t, this.compare, this.keySelector)) } } class Bm extends f { constructor(t, e, n) { super(t), this.keySelector = n, this.hasKey = !1, "function" == typeof e && (this.compare = e) } compare(t, e) { return t === e } _next(t) { let e; try { const { keySelector: n } = this; e = n ? n(t) : t } catch (i) { return this.destination.error(i) } let n = !1; if (this.hasKey) try { const { compare: t } = this; n = t(this.key, e) } catch (i) { return this.destination.error(i) } else this.hasKey = !0; n || (this.key = e, this.destination.next(t)) } } const Hm = new Vm(Fm); class Um { constructor(t) { this.durationSelector = t } call(t, e) { return e.subscribe(new zm(t, this.durationSelector)) } } class zm extends V { constructor(t, e) { super(t), this.durationSelector = e, this.hasValue = !1 } _next(t) { if (this.value = t, this.hasValue = !0, !this.throttled) { let n; try { const { durationSelector: e } = this; n = e(t) } catch (e) { return this.destination.error(e) } const i = j(n, new L(this)); !i || i.closed ? this.clearThrottle() : this.add(this.throttled = i) } } clearThrottle() { const { value: t, hasValue: e, throttled: n } = this; n && (this.remove(n), this.throttled = void 0, n.unsubscribe()), e && (this.value = void 0, this.hasValue = !1, this.destination.next(t)) } notifyNext() { this.clearThrottle() } notifyComplete() { this.clearThrottle() } } function $m(t) { return !l(t) && t - parseFloat(t) + 1 >= 0 } function qm(t) { const { index: e, period: n, subscriber: i } = t; if (i.next(e), !i.closed) { if (-1 === n) return i.complete(); t.index = e + 1, this.schedule(t, n) } } function Wm(t, e = Hm) { return n = () => function (t = 0, e, n) { let i = -1; return $m(e) ? i = Number(e) < 1 ? 1 : Number(e) : S(e) && (n = e), S(n) || (n = Hm), new y(e => { const s = $m(t) ? t : +t - n.now(); return n.schedule(qm, s, { index: 0, period: i, subscriber: e }) }) }(t, e), function (t) { return t.lift(new Um(n)) }; var n } function Km(t) { return e => e.lift(new Ym(t)) } class Ym { constructor(t) { this.notifier = t } call(t, e) { const n = new Zm(t), i = j(this.notifier, new L(n)); return i && !n.seenValue ? (n.add(i), e.subscribe(n)) : n } } class Zm extends V { constructor(t) { super(t), this.seenValue = !1 } notifyNext() { this.seenValue = !0, this.complete() } notifyComplete() { } } let Gm = (() => { class t { constructor(t, e, n) { this._ngZone = t, this._platform = e, this._scrolled = new k, this._globalSubscription = null, this._scrolledCount = 0, this.scrollContainers = new Map, this._document = n } register(t) { this.scrollContainers.has(t) || this.scrollContainers.set(t, t.elementScrolled().subscribe(() => this._scrolled.next(t))) } deregister(t) { const e = this.scrollContainers.get(t); e && (e.unsubscribe(), this.scrollContainers.delete(t)) } scrolled(t = 20) { return this._platform.isBrowser ? new y(e => { this._globalSubscription || this._addGlobalListener(); const n = t > 0 ? this._scrolled.pipe(Wm(t)).subscribe(e) : this._scrolled.subscribe(e); return this._scrolledCount++, () => { n.unsubscribe(), this._scrolledCount--, this._scrolledCount || this._removeGlobalListener() } }) : pu() } ngOnDestroy() { this._removeGlobalListener(), this.scrollContainers.forEach((t, e) => this.deregister(e)), this._scrolled.complete() } ancestorScrolled(t, e) { const n = this.getAncestorScrollContainers(t); return this.scrolled(e).pipe(Vu(t => !t || n.indexOf(t) > -1)) } getAncestorScrollContainers(t) { const e = []; return this.scrollContainers.forEach((n, i) => { this._scrollableContainsElement(i, t) && e.push(i) }), e } _getWindow() { return this._document.defaultView || window } _scrollableContainsElement(t, e) { let n = pm(e), i = t.getElementRef().nativeElement; do { if (n == i) return !0 } while (n = n.parentElement); return !1 } _addGlobalListener() { this._globalSubscription = this._ngZone.runOutsideAngular(() => Pm(this._getWindow().document, "scroll").subscribe(() => this._scrolled.next())) } _removeGlobalListener() { this._globalSubscription && (this._globalSubscription.unsubscribe(), this._globalSubscription = null) } } return t.\u0275fac = function (e) { return new (e || t)(li(vc), li(km), li(Jc, 8)) }, t.\u0275prov = dt({ factory: function () { return new t(li(vc), li(km), li(Jc, 8)) }, token: t, providedIn: "root" }), t })(), Qm = (() => { class t { constructor(t, e, n) { this._platform = t, this._change = new k, this._changeListener = t => { this._change.next(t) }, this._document = n, e.runOutsideAngular(() => { if (t.isBrowser) { const t = this._getWindow(); t.addEventListener("resize", this._changeListener), t.addEventListener("orientationchange", this._changeListener) } this.change().subscribe(() => this._updateViewportSize()) }) } ngOnDestroy() { if (this._platform.isBrowser) { const t = this._getWindow(); t.removeEventListener("resize", this._changeListener), t.removeEventListener("orientationchange", this._changeListener) } this._change.complete() } getViewportSize() { this._viewportSize || this._updateViewportSize(); const t = { width: this._viewportSize.width, height: this._viewportSize.height }; return this._platform.isBrowser || (this._viewportSize = null), t } getViewportRect() { const t = this.getViewportScrollPosition(), { width: e, height: n } = this.getViewportSize(); return { top: t.top, left: t.left, bottom: t.top + n, right: t.left + e, height: n, width: e } } getViewportScrollPosition() { if (!this._platform.isBrowser) return { top: 0, left: 0 }; const t = this._document, e = this._getWindow(), n = t.documentElement, i = n.getBoundingClientRect(); return { top: -i.top || t.body.scrollTop || e.scrollY || n.scrollTop || 0, left: -i.left || t.body.scrollLeft || e.scrollX || n.scrollLeft || 0 } } change(t = 20) { return t > 0 ? this._change.pipe(Wm(t)) : this._change } _getWindow() { return this._document.defaultView || window } _updateViewportSize() { const t = this._getWindow(); this._viewportSize = this._platform.isBrowser ? { width: t.innerWidth, height: t.innerHeight } : { width: 0, height: 0 } } } return t.\u0275fac = function (e) { return new (e || t)(li(km), li(vc), li(Jc, 8)) }, t.\u0275prov = dt({ factory: function () { return new t(li(km), li(vc), li(Jc, 8)) }, token: t, providedIn: "root" }), t })(), Xm = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({}), t })(), Jm = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ imports: [[wm, xm, Xm], wm, Xm] }), t })(); const tg = [[["caption"]], [["colgroup"], ["col"]]], eg = ["caption", "colgroup, col"]; function ng(t) { return class extends t { constructor(...t) { super(...t), this._sticky = !1, this._hasStickyChanged = !1 } get sticky() { return this._sticky } set sticky(t) { const e = this._sticky; this._sticky = lm(t), this._hasStickyChanged = e !== this._sticky } hasStickyChanged() { const t = this._hasStickyChanged; return this._hasStickyChanged = !1, t } resetStickyChanged() { this._hasStickyChanged = !1 } } } const ig = new $n("CDK_TABLE"); let sg = (() => { class t { constructor(t) { this.template = t } } return t.\u0275fac = function (e) { return new (e || t)(bo(ul)) }, t.\u0275dir = Zt({ type: t, selectors: [["", "cdkCellDef", ""]] }), t })(), rg = (() => { class t { constructor(t) { this.template = t } } return t.\u0275fac = function (e) { return new (e || t)(bo(ul)) }, t.\u0275dir = Zt({ type: t, selectors: [["", "cdkHeaderCellDef", ""]] }), t })(), og = (() => { class t { constructor(t) { this.template = t } } return t.\u0275fac = function (e) { return new (e || t)(bo(ul)) }, t.\u0275dir = Zt({ type: t, selectors: [["", "cdkFooterCellDef", ""]] }), t })(); class ag { } const lg = ng(ag); let cg = (() => { class t extends lg { constructor(t) { super(), this._table = t, this._stickyEnd = !1 } get name() { return this._name } set name(t) { this._setNameInput(t) } get stickyEnd() { return this._stickyEnd } set stickyEnd(t) { const e = this._stickyEnd; this._stickyEnd = lm(t), this._hasStickyChanged = e !== this._stickyEnd } _updateColumnCssClassName() { this._columnCssClassName = [`cdk-column-${this.cssClassFriendlyName}`] } _setNameInput(t) { t && (this._name = t, this.cssClassFriendlyName = t.replace(/[^a-z0-9_-]/gi, "-"), this._updateColumnCssClassName()) } } return t.\u0275fac = function (e) { return new (e || t)(bo(ig, 8)) }, t.\u0275dir = Zt({ type: t, selectors: [["", "cdkColumnDef", ""]], contentQueries: function (t, e, n) { if (1 & t && (Yl(n, sg, 5), Yl(n, rg, 5), Yl(n, og, 5)), 2 & t) { let t; Wl(t = Zl()) && (e.cell = t.first), Wl(t = Zl()) && (e.headerCell = t.first), Wl(t = Zl()) && (e.footerCell = t.first) } }, inputs: { sticky: "sticky", name: ["cdkColumnDef", "name"], stickyEnd: "stickyEnd" }, features: [Ta([{ provide: "MAT_SORT_HEADER_COLUMN_DEF", useExisting: t }]), so] }), t })(); class hg { constructor(t, e) { const n = e.nativeElement.classList; for (const i of t._columnCssClassName) n.add(i) } } let ug = (() => { class t extends hg { constructor(t, e) { super(t, e) } } return t.\u0275fac = function (e) { return new (e || t)(bo(cg), bo(Ma)) }, t.\u0275dir = Zt({ type: t, selectors: [["cdk-header-cell"], ["th", "cdk-header-cell", ""]], hostAttrs: ["role", "columnheader", 1, "cdk-header-cell"], features: [so] }), t })(), dg = (() => { class t extends hg { constructor(t, e) { super(t, e) } } return t.\u0275fac = function (e) { return new (e || t)(bo(cg), bo(Ma)) }, t.\u0275dir = Zt({ type: t, selectors: [["cdk-cell"], ["td", "cdk-cell", ""]], hostAttrs: ["role", "gridcell", 1, "cdk-cell"], features: [so] }), t })(); class pg { constructor() { this.tasks = [], this.endTasks = [] } } const fg = new $n("_COALESCED_STYLE_SCHEDULER"); let mg = (() => { class t { constructor(t) { this._ngZone = t, this._currentSchedule = null, this._destroyed = new k } schedule(t) { this._createScheduleIfNeeded(), this._currentSchedule.tasks.push(t) } scheduleEnd(t) { this._createScheduleIfNeeded(), this._currentSchedule.endTasks.push(t) } ngOnDestroy() { this._destroyed.next(), this._destroyed.complete() } _createScheduleIfNeeded() { this._currentSchedule || (this._currentSchedule = new pg, this._getScheduleObservable().pipe(Km(this._destroyed)).subscribe(() => { for (; this._currentSchedule.tasks.length || this._currentSchedule.endTasks.length;) { const t = this._currentSchedule; this._currentSchedule = new pg; for (const e of t.tasks) e(); for (const e of t.endTasks) e() } this._currentSchedule = null })) } _getScheduleObservable() { return this._ngZone.isStable ? F(Promise.resolve(void 0)) : this._ngZone.onStable.pipe(Iu(1)) } } return t.\u0275fac = function (e) { return new (e || t)(li(vc)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), gg = (() => { class t { constructor(t, e) { this.template = t, this._differs = e } ngOnChanges(t) { if (!this._columnsDiffer) { const e = t.columns && t.columns.currentValue || []; this._columnsDiffer = this._differs.find(e).create(), this._columnsDiffer.diff(e) } } getColumnsDiff() { return this._columnsDiffer.diff(this.columns) } extractCellTemplate(t) { return this instanceof bg ? t.headerCell.template : this instanceof Cg ? t.footerCell.template : t.cell.template } } return t.\u0275fac = function (e) { return new (e || t)(bo(ul), bo(Ja)) }, t.\u0275dir = Zt({ type: t, features: [le] }), t })(); class _g extends gg { } const yg = ng(_g); let bg = (() => { class t extends yg { constructor(t, e, n) { super(t, e), this._table = n } ngOnChanges(t) { super.ngOnChanges(t) } } return t.\u0275fac = function (e) { return new (e || t)(bo(ul), bo(Ja), bo(ig, 8)) }, t.\u0275dir = Zt({ type: t, selectors: [["", "cdkHeaderRowDef", ""]], inputs: { columns: ["cdkHeaderRowDef", "columns"], sticky: ["cdkHeaderRowDefSticky", "sticky"] }, features: [so, le] }), t })(); class vg extends gg { } const wg = ng(vg); let Cg = (() => { class t extends wg { constructor(t, e, n) { super(t, e), this._table = n } ngOnChanges(t) { super.ngOnChanges(t) } } return t.\u0275fac = function (e) { return new (e || t)(bo(ul), bo(Ja), bo(ig, 8)) }, t.\u0275dir = Zt({ type: t, selectors: [["", "cdkFooterRowDef", ""]], inputs: { columns: ["cdkFooterRowDef", "columns"], sticky: ["cdkFooterRowDefSticky", "sticky"] }, features: [so, le] }), t })(), kg = (() => { class t extends gg { constructor(t, e, n) { super(t, e), this._table = n } } return t.\u0275fac = function (e) { return new (e || t)(bo(ul), bo(Ja), bo(ig, 8)) }, t.\u0275dir = Zt({ type: t, selectors: [["", "cdkRowDef", ""]], inputs: { columns: ["cdkRowDefColumns", "columns"], when: ["cdkRowDefWhen", "when"] }, features: [so] }), t })(), xg = (() => { class t { constructor(e) { this._viewContainer = e, t.mostRecentCellOutlet = this } ngOnDestroy() { t.mostRecentCellOutlet === this && (t.mostRecentCellOutlet = null) } } return t.\u0275fac = function (e) { return new (e || t)(bo(yl)) }, t.\u0275dir = Zt({ type: t, selectors: [["", "cdkCellOutlet", ""]] }), t.mostRecentCellOutlet = null, t })(), Sg = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = zt({ type: t, selectors: [["cdk-header-row"], ["tr", "cdk-header-row", ""]], hostAttrs: ["role", "row", 1, "cdk-header-row"], decls: 1, vars: 0, consts: [["cdkCellOutlet", ""]], template: function (t, e) { 1 & t && To(0, 0) }, directives: [xg], encapsulation: 2 }), t })(), Eg = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = zt({ type: t, selectors: [["cdk-row"], ["tr", "cdk-row", ""]], hostAttrs: ["role", "row", 1, "cdk-row"], decls: 1, vars: 0, consts: [["cdkCellOutlet", ""]], template: function (t, e) { 1 & t && To(0, 0) }, directives: [xg], encapsulation: 2 }), t })(), Tg = (() => { class t { constructor(t) { this.templateRef = t } } return t.\u0275fac = function (e) { return new (e || t)(bo(ul)) }, t.\u0275dir = Zt({ type: t, selectors: [["ng-template", "cdkNoDataRow", ""]] }), t })(); const Rg = ["top", "bottom", "left", "right"]; class Ag { constructor(t, e, n, i, s = !0, r = !0, o) { this._isNativeHtmlTable = t, this._stickCellCss = e, this.direction = n, this._coalescedStyleScheduler = i, this._isBrowser = s, this._needsPositionStickyOnElement = r, this._positionListener = o, this._cachedCellWidths = [], this._borderCellCss = { top: `${e}-border-elem-top`, bottom: `${e}-border-elem-bottom`, left: `${e}-border-elem-left`, right: `${e}-border-elem-right` } } clearStickyPositioning(t, e) { const n = []; for (const i of t) if (i.nodeType === i.ELEMENT_NODE) { n.push(i); for (let t = 0; t < i.children.length; t++)n.push(i.children[t]) } this._coalescedStyleScheduler.schedule(() => { for (const t of n) this._removeStickyStyle(t, e) }) } updateStickyColumns(t, e, n, i = !0) { if (!t.length || !this._isBrowser || !e.some(t => t) && !n.some(t => t)) return void (this._positionListener && (this._positionListener.stickyColumnsUpdated({ sizes: [] }), this._positionListener.stickyEndColumnsUpdated({ sizes: [] }))); const s = t[0], r = s.children.length, o = this._getCellWidths(s, i), a = this._getStickyStartColumnPositions(o, e), l = this._getStickyEndColumnPositions(o, n), c = e.lastIndexOf(!0), h = n.indexOf(!0); this._coalescedStyleScheduler.schedule(() => { const i = "rtl" === this.direction, s = i ? "right" : "left", u = i ? "left" : "right"; for (const o of t) for (let t = 0; t < r; t++) { const i = o.children[t]; e[t] && this._addStickyStyle(i, s, a[t], t === c), n[t] && this._addStickyStyle(i, u, l[t], t === h) } this._positionListener && (this._positionListener.stickyColumnsUpdated({ sizes: -1 === c ? [] : o.slice(0, c + 1).map((t, n) => e[n] ? t : null) }), this._positionListener.stickyEndColumnsUpdated({ sizes: -1 === h ? [] : o.slice(h).map((t, e) => n[e + h] ? t : null).reverse() })) }) } stickRows(t, e, n) { if (!this._isBrowser) return; const i = "bottom" === n ? t.slice().reverse() : t, s = "bottom" === n ? e.slice().reverse() : e, r = [], o = [], a = []; for (let c = 0, h = 0; c < i.length; c++) { if (!s[c]) continue; r[c] = h; const t = i[c]; a[c] = this._isNativeHtmlTable ? Array.from(t.children) : [t]; const e = t.getBoundingClientRect().height; h += e, o[c] = e } const l = s.lastIndexOf(!0); this._coalescedStyleScheduler.schedule(() => { var t, e; for (let o = 0; o < i.length; o++) { if (!s[o]) continue; const t = r[o], e = o === l; for (const i of a[o]) this._addStickyStyle(i, n, t, e) } "top" === n ? null === (t = this._positionListener) || void 0 === t || t.stickyHeaderRowsUpdated({ sizes: o, offsets: r, elements: a }) : null === (e = this._positionListener) || void 0 === e || e.stickyFooterRowsUpdated({ sizes: o, offsets: r, elements: a }) }) } updateStickyFooterContainer(t, e) { if (!this._isNativeHtmlTable) return; const n = t.querySelector("tfoot"); this._coalescedStyleScheduler.schedule(() => { e.some(t => !t) ? this._removeStickyStyle(n, ["bottom"]) : this._addStickyStyle(n, "bottom", 0, !1) }) } _removeStickyStyle(t, e) { for (const n of e) t.style[n] = "", t.classList.remove(this._borderCellCss[n]); Rg.some(n => -1 === e.indexOf(n) && t.style[n]) ? t.style.zIndex = this._getCalculatedZIndex(t) : (t.style.zIndex = "", this._needsPositionStickyOnElement && (t.style.position = ""), t.classList.remove(this._stickCellCss)) } _addStickyStyle(t, e, n, i) { t.classList.add(this._stickCellCss), i && t.classList.add(this._borderCellCss[e]), t.style[e] = `${n}px`, t.style.zIndex = this._getCalculatedZIndex(t), this._needsPositionStickyOnElement && (t.style.cssText += "position: -webkit-sticky; position: sticky; ") } _getCalculatedZIndex(t) { const e = { top: 100, bottom: 10, left: 1, right: 1 }; let n = 0; for (const i of Rg) t.style[i] && (n += e[i]); return n ? `${n}` : "" } _getCellWidths(t, e = !0) { if (!e && this._cachedCellWidths.length) return this._cachedCellWidths; const n = [], i = t.children; for (let s = 0; s < i.length; s++)n.push(i[s].getBoundingClientRect().width); return this._cachedCellWidths = n, n } _getStickyStartColumnPositions(t, e) { const n = []; let i = 0; for (let s = 0; s < t.length; s++)e[s] && (n[s] = i, i += t[s]); return n } _getStickyEndColumnPositions(t, e) { const n = []; let i = 0; for (let s = t.length; s > 0; s--)e[s] && (n[s] = i, i += t[s]); return n } } const Og = new $n("CDK_SPL"); let Ig = (() => { class t { constructor(t, e) { this.viewContainer = t, this.elementRef = e } } return t.\u0275fac = function (e) { return new (e || t)(bo(yl), bo(Ma)) }, t.\u0275dir = Zt({ type: t, selectors: [["", "rowOutlet", ""]] }), t })(), Dg = (() => { class t { constructor(t, e) { this.viewContainer = t, this.elementRef = e } } return t.\u0275fac = function (e) { return new (e || t)(bo(yl), bo(Ma)) }, t.\u0275dir = Zt({ type: t, selectors: [["", "headerRowOutlet", ""]] }), t })(), Pg = (() => { class t { constructor(t, e) { this.viewContainer = t, this.elementRef = e } } return t.\u0275fac = function (e) { return new (e || t)(bo(yl), bo(Ma)) }, t.\u0275dir = Zt({ type: t, selectors: [["", "footerRowOutlet", ""]] }), t })(), Mg = (() => { class t { constructor(t, e) { this.viewContainer = t, this.elementRef = e } } return t.\u0275fac = function (e) { return new (e || t)(bo(yl), bo(Ma)) }, t.\u0275dir = Zt({ type: t, selectors: [["", "noDataRowOutlet", ""]] }), t })(), Ng = (() => { class t { constructor(t, e, n, i, s, r, o, a, l, c, h) { this._differs = t, this._changeDetectorRef = e, this._elementRef = n, this._dir = s, this._platform = o, this._viewRepeater = a, this._coalescedStyleScheduler = l, this._viewportRuler = c, this._stickyPositioningListener = h, this._onDestroy = new k, this._columnDefsByName = new Map, this._customColumnDefs = new Set, this._customRowDefs = new Set, this._customHeaderRowDefs = new Set, this._customFooterRowDefs = new Set, this._headerRowDefChanged = !0, this._footerRowDefChanged = !0, this._stickyColumnStylesNeedReset = !0, this._forceRecalculateCellWidths = !0, this._cachedRenderRowsMap = new Map, this.stickyCssClass = "cdk-table-sticky", this.needsPositionStickyOnElement = !0, this._isShowingNoDataRow = !1, this._multiTemplateDataRows = !1, this._fixedLayout = !1, this.viewChange = new fu({ start: 0, end: Number.MAX_VALUE }), i || this._elementRef.nativeElement.setAttribute("role", "grid"), this._document = r, this._isNativeHtmlTable = "TABLE" === this._elementRef.nativeElement.nodeName } get trackBy() { return this._trackByFn } set trackBy(t) { this._trackByFn = t } get dataSource() { return this._dataSource } set dataSource(t) { this._dataSource !== t && this._switchDataSource(t) } get multiTemplateDataRows() { return this._multiTemplateDataRows } set multiTemplateDataRows(t) { this._multiTemplateDataRows = lm(t), this._rowOutlet && this._rowOutlet.viewContainer.length && (this._forceRenderDataRows(), this.updateStickyColumnStyles()) } get fixedLayout() { return this._fixedLayout } set fixedLayout(t) { this._fixedLayout = lm(t), this._forceRecalculateCellWidths = !0, this._stickyColumnStylesNeedReset = !0 } ngOnInit() { this._setupStickyStyler(), this._isNativeHtmlTable && this._applyNativeTableSections(), this._dataDiffer = this._differs.find([]).create((t, e) => this.trackBy ? this.trackBy(e.dataIndex, e.data) : e), this._viewportRuler.change().pipe(Km(this._onDestroy)).subscribe(() => { this._forceRecalculateCellWidths = !0 }) } ngAfterContentChecked() { this._cacheRowDefs(), this._cacheColumnDefs(); const t = this._renderUpdatedColumns() || this._headerRowDefChanged || this._footerRowDefChanged; this._stickyColumnStylesNeedReset = this._stickyColumnStylesNeedReset || t, this._forceRecalculateCellWidths = t, this._headerRowDefChanged && (this._forceRenderHeaderRows(), this._headerRowDefChanged = !1), this._footerRowDefChanged && (this._forceRenderFooterRows(), this._footerRowDefChanged = !1), this.dataSource && this._rowDefs.length > 0 && !this._renderChangeSubscription ? this._observeRenderChanges() : this._stickyColumnStylesNeedReset && this.updateStickyColumnStyles(), this._checkStickyStates() } ngOnDestroy() { this._rowOutlet.viewContainer.clear(), this._noDataRowOutlet.viewContainer.clear(), this._headerRowOutlet.viewContainer.clear(), this._footerRowOutlet.viewContainer.clear(), this._cachedRenderRowsMap.clear(), this._onDestroy.next(), this._onDestroy.complete(), fm(this.dataSource) && this.dataSource.disconnect(this) } renderRows() { this._renderRows = this._getAllRenderRows(); const t = this._dataDiffer.diff(this._renderRows); if (!t) return void this._updateNoDataRow(); const e = this._rowOutlet.viewContainer; this._viewRepeater.applyChanges(t, e, (t, e, n) => this._getEmbeddedViewArgs(t.item, n), t => t.item.data, t => { 1 === t.operation && t.context && this._renderCellTemplateForItem(t.record.item.rowDef, t.context) }), this._updateRowIndexContext(), t.forEachIdentityChange(t => { e.get(t.currentIndex).context.$implicit = t.item.data }), this._updateNoDataRow(), this.updateStickyColumnStyles() } addColumnDef(t) { this._customColumnDefs.add(t) } removeColumnDef(t) { this._customColumnDefs.delete(t) } addRowDef(t) { this._customRowDefs.add(t) } removeRowDef(t) { this._customRowDefs.delete(t) } addHeaderRowDef(t) { this._customHeaderRowDefs.add(t), this._headerRowDefChanged = !0 } removeHeaderRowDef(t) { this._customHeaderRowDefs.delete(t), this._headerRowDefChanged = !0 } addFooterRowDef(t) { this._customFooterRowDefs.add(t), this._footerRowDefChanged = !0 } removeFooterRowDef(t) { this._customFooterRowDefs.delete(t), this._footerRowDefChanged = !0 } setNoDataRow(t) { this._customNoDataRow = t } updateStickyHeaderRowStyles() { const t = this._getRenderedRows(this._headerRowOutlet), e = this._elementRef.nativeElement.querySelector("thead"); e && (e.style.display = t.length ? "" : "none"); const n = this._headerRowDefs.map(t => t.sticky); this._stickyStyler.clearStickyPositioning(t, ["top"]), this._stickyStyler.stickRows(t, n, "top"), this._headerRowDefs.forEach(t => t.resetStickyChanged()) } updateStickyFooterRowStyles() { const t = this._getRenderedRows(this._footerRowOutlet), e = this._elementRef.nativeElement.querySelector("tfoot"); e && (e.style.display = t.length ? "" : "none"); const n = this._footerRowDefs.map(t => t.sticky); this._stickyStyler.clearStickyPositioning(t, ["bottom"]), this._stickyStyler.stickRows(t, n, "bottom"), this._stickyStyler.updateStickyFooterContainer(this._elementRef.nativeElement, n), this._footerRowDefs.forEach(t => t.resetStickyChanged()) } updateStickyColumnStyles() { const t = this._getRenderedRows(this._headerRowOutlet), e = this._getRenderedRows(this._rowOutlet), n = this._getRenderedRows(this._footerRowOutlet); (this._isNativeHtmlTable && !this._fixedLayout || this._stickyColumnStylesNeedReset) && (this._stickyStyler.clearStickyPositioning([...t, ...e, ...n], ["left", "right"]), this._stickyColumnStylesNeedReset = !1), t.forEach((t, e) => { this._addStickyColumnStyles([t], this._headerRowDefs[e]) }), this._rowDefs.forEach(t => { const n = []; for (let i = 0; i < e.length; i++)this._renderRows[i].rowDef === t && n.push(e[i]); this._addStickyColumnStyles(n, t) }), n.forEach((t, e) => { this._addStickyColumnStyles([t], this._footerRowDefs[e]) }), Array.from(this._columnDefsByName.values()).forEach(t => t.resetStickyChanged()) } _getAllRenderRows() { const t = [], e = this._cachedRenderRowsMap; this._cachedRenderRowsMap = new Map; for (let n = 0; n < this._data.length; n++) { let i = this._data[n]; const s = this._getRenderRowsForData(i, n, e.get(i)); this._cachedRenderRowsMap.has(i) || this._cachedRenderRowsMap.set(i, new WeakMap); for (let e = 0; e < s.length; e++) { let n = s[e]; const i = this._cachedRenderRowsMap.get(n.data); i.has(n.rowDef) ? i.get(n.rowDef).push(n) : i.set(n.rowDef, [n]), t.push(n) } } return t } _getRenderRowsForData(t, e, n) { return this._getRowDefs(t, e).map(i => { const s = n && n.has(i) ? n.get(i) : []; if (s.length) { const t = s.shift(); return t.dataIndex = e, t } return { data: t, rowDef: i, dataIndex: e } }) } _cacheColumnDefs() { this._columnDefsByName.clear(), Fg(this._getOwnDefs(this._contentColumnDefs), this._customColumnDefs).forEach(t => { this._columnDefsByName.has(t.name), this._columnDefsByName.set(t.name, t) }) } _cacheRowDefs() { this._headerRowDefs = Fg(this._getOwnDefs(this._contentHeaderRowDefs), this._customHeaderRowDefs), this._footerRowDefs = Fg(this._getOwnDefs(this._contentFooterRowDefs), this._customFooterRowDefs), this._rowDefs = Fg(this._getOwnDefs(this._contentRowDefs), this._customRowDefs); const t = this._rowDefs.filter(t => !t.when); this._defaultRowDef = t[0] } _renderUpdatedColumns() { const t = (t, e) => t || !!e.getColumnsDiff(), e = this._rowDefs.reduce(t, !1); e && this._forceRenderDataRows(); const n = this._headerRowDefs.reduce(t, !1); n && this._forceRenderHeaderRows(); const i = this._footerRowDefs.reduce(t, !1); return i && this._forceRenderFooterRows(), e || n || i } _switchDataSource(t) { this._data = [], fm(this.dataSource) && this.dataSource.disconnect(this), this._renderChangeSubscription && (this._renderChangeSubscription.unsubscribe(), this._renderChangeSubscription = null), t || (this._dataDiffer && this._dataDiffer.diff([]), this._rowOutlet.viewContainer.clear()), this._dataSource = t } _observeRenderChanges() { if (!this.dataSource) return; let t; var e; fm(this.dataSource) ? t = this.dataSource.connect(this) : (e = this.dataSource) && (e instanceof y || "function" == typeof e.lift && "function" == typeof e.subscribe) ? t = this.dataSource : Array.isArray(this.dataSource) && (t = pu(this.dataSource)), this._renderChangeSubscription = t.pipe(Km(this._onDestroy)).subscribe(t => { this._data = t || [], this.renderRows() }) } _forceRenderHeaderRows() { this._headerRowOutlet.viewContainer.length > 0 && this._headerRowOutlet.viewContainer.clear(), this._headerRowDefs.forEach((t, e) => this._renderRow(this._headerRowOutlet, t, e)), this.updateStickyHeaderRowStyles() } _forceRenderFooterRows() { this._footerRowOutlet.viewContainer.length > 0 && this._footerRowOutlet.viewContainer.clear(), this._footerRowDefs.forEach((t, e) => this._renderRow(this._footerRowOutlet, t, e)), this.updateStickyFooterRowStyles() } _addStickyColumnStyles(t, e) { const n = Array.from(e.columns || []).map(t => this._columnDefsByName.get(t)), i = n.map(t => t.sticky), s = n.map(t => t.stickyEnd); this._stickyStyler.updateStickyColumns(t, i, s, !this._fixedLayout || this._forceRecalculateCellWidths) } _getRenderedRows(t) { const e = []; for (let n = 0; n < t.viewContainer.length; n++) { const i = t.viewContainer.get(n); e.push(i.rootNodes[0]) } return e } _getRowDefs(t, e) { if (1 == this._rowDefs.length) return [this._rowDefs[0]]; let n = []; if (this.multiTemplateDataRows) n = this._rowDefs.filter(n => !n.when || n.when(e, t)); else { let i = this._rowDefs.find(n => n.when && n.when(e, t)) || this._defaultRowDef; i && n.push(i) } return n } _getEmbeddedViewArgs(t, e) { return { templateRef: t.rowDef.template, context: { $implicit: t.data }, index: e } } _renderRow(t, e, n, i = {}) { const s = t.viewContainer.createEmbeddedView(e.template, i, n); return this._renderCellTemplateForItem(e, i), s } _renderCellTemplateForItem(t, e) { for (let n of this._getCellTemplates(t)) xg.mostRecentCellOutlet && xg.mostRecentCellOutlet._viewContainer.createEmbeddedView(n, e); this._changeDetectorRef.markForCheck() } _updateRowIndexContext() { const t = this._rowOutlet.viewContainer; for (let e = 0, n = t.length; e < n; e++) { const i = t.get(e).context; i.count = n, i.first = 0 === e, i.last = e === n - 1, i.even = e % 2 == 0, i.odd = !i.even, this.multiTemplateDataRows ? (i.dataIndex = this._renderRows[e].dataIndex, i.renderIndex = e) : i.index = this._renderRows[e].dataIndex } } _getCellTemplates(t) { return t && t.columns ? Array.from(t.columns, e => { const n = this._columnDefsByName.get(e); return t.extractCellTemplate(n) }) : [] } _applyNativeTableSections() { const t = this._document.createDocumentFragment(), e = [{ tag: "thead", outlets: [this._headerRowOutlet] }, { tag: "tbody", outlets: [this._rowOutlet, this._noDataRowOutlet] }, { tag: "tfoot", outlets: [this._footerRowOutlet] }]; for (const n of e) { const e = this._document.createElement(n.tag); e.setAttribute("role", "rowgroup"); for (const t of n.outlets) e.appendChild(t.elementRef.nativeElement); t.appendChild(e) } this._elementRef.nativeElement.appendChild(t) } _forceRenderDataRows() { this._dataDiffer.diff([]), this._rowOutlet.viewContainer.clear(), this.renderRows() } _checkStickyStates() { const t = (t, e) => t || e.hasStickyChanged(); this._headerRowDefs.reduce(t, !1) && this.updateStickyHeaderRowStyles(), this._footerRowDefs.reduce(t, !1) && this.updateStickyFooterRowStyles(), Array.from(this._columnDefsByName.values()).reduce(t, !1) && (this._stickyColumnStylesNeedReset = !0, this.updateStickyColumnStyles()) } _setupStickyStyler() { this._stickyStyler = new Ag(this._isNativeHtmlTable, this.stickyCssClass, this._dir ? this._dir.value : "ltr", this._coalescedStyleScheduler, this._platform.isBrowser, this.needsPositionStickyOnElement, this._stickyPositioningListener), (this._dir ? this._dir.change : pu()).pipe(Km(this._onDestroy)).subscribe(t => { this._stickyStyler.direction = t, this.updateStickyColumnStyles() }) } _getOwnDefs(t) { return t.filter(t => !t._table || t._table === this) } _updateNoDataRow() { const t = this._customNoDataRow || this._noDataRow; if (t) { const e = 0 === this._rowOutlet.viewContainer.length; if (e !== this._isShowingNoDataRow) { const n = this._noDataRowOutlet.viewContainer; e ? n.createEmbeddedView(t.templateRef) : n.clear(), this._isShowingNoDataRow = e } } } } return t.\u0275fac = function (e) { return new (e || t)(bo(Ja), bo(ol), bo(Ma), Hn("role"), bo(vm, 8), bo(Jc), bo(km), bo(_m), bo(fg), bo(Qm), bo(Og, 12)) }, t.\u0275cmp = zt({ type: t, selectors: [["cdk-table"], ["table", "cdk-table", ""]], contentQueries: function (t, e, n) { if (1 & t && (Yl(n, Tg, 5), Yl(n, cg, 5), Yl(n, kg, 5), Yl(n, bg, 5), Yl(n, Cg, 5)), 2 & t) { let t; Wl(t = Zl()) && (e._noDataRow = t.first), Wl(t = Zl()) && (e._contentColumnDefs = t), Wl(t = Zl()) && (e._contentRowDefs = t), Wl(t = Zl()) && (e._contentHeaderRowDefs = t), Wl(t = Zl()) && (e._contentFooterRowDefs = t) } }, viewQuery: function (t, e) { if (1 & t && (Kl(Ig, 7), Kl(Dg, 7), Kl(Pg, 7), Kl(Mg, 7)), 2 & t) { let t; Wl(t = Zl()) && (e._rowOutlet = t.first), Wl(t = Zl()) && (e._headerRowOutlet = t.first), Wl(t = Zl()) && (e._footerRowOutlet = t.first), Wl(t = Zl()) && (e._noDataRowOutlet = t.first) } }, hostAttrs: [1, "cdk-table"], hostVars: 2, hostBindings: function (t, e) { 2 & t && Ko("cdk-table-fixed-layout", e.fixedLayout) }, inputs: { trackBy: "trackBy", dataSource: "dataSource", multiTemplateDataRows: "multiTemplateDataRows", fixedLayout: "fixedLayout" }, exportAs: ["cdkTable"], features: [Ta([{ provide: ig, useExisting: t }, { provide: _m, useClass: mm }, { provide: fg, useClass: mg }, { provide: Og, useValue: null }])], ngContentSelectors: eg, decls: 6, vars: 0, consts: [["headerRowOutlet", ""], ["rowOutlet", ""], ["noDataRowOutlet", ""], ["footerRowOutlet", ""]], template: function (t, e) { 1 & t && (Vo(tg), jo(0), jo(1, 1), To(2, 0), To(3, 1), To(4, 2), To(5, 3)) }, directives: [Dg, Ig, Mg, Pg], styles: [".cdk-table-fixed-layout{table-layout:fixed}\n"], encapsulation: 2 }), t })(); function Fg(t, e) { return t.concat(Array.from(e)) } let Lg = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ imports: [[Jm]] }), t })(); function Vg(t, ...e) { return e.length ? e.some(e => t[e]) : t.altKey || t.shiftKey || t.ctrlKey || t.metaKey } function jg(t, e = Hm) { return n => n.lift(new Bg(t, e)) } class Bg { constructor(t, e) { this.dueTime = t, this.scheduler = e } call(t, e) { return e.subscribe(new Hg(t, this.dueTime, this.scheduler)) } } class Hg extends f { constructor(t, e, n) { super(t), this.dueTime = e, this.scheduler = n, this.debouncedSubscription = null, this.lastValue = null, this.hasValue = !1 } _next(t) { this.clearDebounce(), this.lastValue = t, this.hasValue = !0, this.add(this.debouncedSubscription = this.scheduler.schedule(Ug, this.dueTime, this)) } _complete() { this.debouncedNext(), this.destination.complete() } debouncedNext() { if (this.clearDebounce(), this.hasValue) { const { lastValue: t } = this; this.lastValue = null, this.hasValue = !1, this.destination.next(t) } } clearDebounce() { const t = this.debouncedSubscription; null !== t && (this.remove(t), t.unsubscribe(), this.debouncedSubscription = null) } } function Ug(t) { t.debouncedNext() } let zg = (() => { class t { create(t) { return "undefined" == typeof MutationObserver ? null : new MutationObserver(t) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ factory: function () { return new t }, token: t, providedIn: "root" }), t })(), $g = (() => { class t { constructor(t) { this._mutationObserverFactory = t, this._observedElements = new Map } ngOnDestroy() { this._observedElements.forEach((t, e) => this._cleanupObserver(e)) } observe(t) { const e = pm(t); return new y(t => { const n = this._observeElement(e).subscribe(t); return () => { n.unsubscribe(), this._unobserveElement(e) } }) } _observeElement(t) { if (this._observedElements.has(t)) this._observedElements.get(t).count++; else { const e = new k, n = this._mutationObserverFactory.create(t => e.next(t)); n && n.observe(t, { characterData: !0, childList: !0, subtree: !0 }), this._observedElements.set(t, { observer: n, stream: e, count: 1 }) } return this._observedElements.get(t).stream } _unobserveElement(t) { this._observedElements.has(t) && (this._observedElements.get(t).count--, this._observedElements.get(t).count || this._cleanupObserver(t)) } _cleanupObserver(t) { if (this._observedElements.has(t)) { const { observer: e, stream: n } = this._observedElements.get(t); e && e.disconnect(), n.complete(), this._observedElements.delete(t) } } } return t.\u0275fac = function (e) { return new (e || t)(li(zg)) }, t.\u0275prov = dt({ factory: function () { return new t(li(zg)) }, token: t, providedIn: "root" }), t })(), qg = (() => { class t { constructor(t, e, n) { this._contentObserver = t, this._elementRef = e, this._ngZone = n, this.event = new Ml, this._disabled = !1, this._currentSubscription = null } get disabled() { return this._disabled } set disabled(t) { this._disabled = lm(t), this._disabled ? this._unsubscribe() : this._subscribe() } get debounce() { return this._debounce } set debounce(t) { this._debounce = cm(t), this._subscribe() } ngAfterContentInit() { this._currentSubscription || this.disabled || this._subscribe() } ngOnDestroy() { this._unsubscribe() } _subscribe() { this._unsubscribe(); const t = this._contentObserver.observe(this._elementRef); this._ngZone.runOutsideAngular(() => { this._currentSubscription = (this.debounce ? t.pipe(jg(this.debounce)) : t).subscribe(this.event) }) } _unsubscribe() { var t; null === (t = this._currentSubscription) || void 0 === t || t.unsubscribe() } } return t.\u0275fac = function (e) { return new (e || t)(bo($g), bo(Ma), bo(vc)) }, t.\u0275dir = Zt({ type: t, selectors: [["", "cdkObserveContent", ""]], inputs: { disabled: ["cdkObserveContentDisabled", "disabled"], debounce: "debounce" }, outputs: { event: "cdkObserveContent" }, exportAs: ["cdkObserveContent"] }), t })(), Wg = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ providers: [zg] }), t })(); class Kg extends class { constructor(t) { this._items = t, this._activeItemIndex = -1, this._activeItem = null, this._wrap = !1, this._letterKeyStream = new k, this._typeaheadSubscription = u.EMPTY, this._vertical = !0, this._allowedModifierKeys = [], this._homeAndEnd = !1, this._skipPredicateFn = t => t.disabled, this._pressedLetters = [], this.tabOut = new k, this.change = new k, t instanceof Fl && t.changes.subscribe(t => { if (this._activeItem) { const e = t.toArray().indexOf(this._activeItem); e > -1 && e !== this._activeItemIndex && (this._activeItemIndex = e) } }) } skipPredicate(t) { return this._skipPredicateFn = t, this } withWrap(t = !0) { return this._wrap = t, this } withVerticalOrientation(t = !0) { return this._vertical = t, this } withHorizontalOrientation(t) { return this._horizontal = t, this } withAllowedModifierKeys(t) { return this._allowedModifierKeys = t, this } withTypeAhead(t = 200) { return this._typeaheadSubscription.unsubscribe(), this._typeaheadSubscription = this._letterKeyStream.pipe(id(t => this._pressedLetters.push(t)), jg(t), Vu(() => this._pressedLetters.length > 0), E(() => this._pressedLetters.join(""))).subscribe(t => { const e = this._getItemsArray(); for (let n = 1; n < e.length + 1; n++) { const i = (this._activeItemIndex + n) % e.length, s = e[i]; if (!this._skipPredicateFn(s) && 0 === s.getLabel().toUpperCase().trim().indexOf(t)) { this.setActiveItem(i); break } } this._pressedLetters = [] }), this } withHomeAndEnd(t = !0) { return this._homeAndEnd = t, this } setActiveItem(t) { const e = this._activeItem; this.updateActiveItem(t), this._activeItem !== e && this.change.next(this._activeItemIndex) } onKeydown(t) { const e = t.keyCode, n = ["altKey", "ctrlKey", "metaKey", "shiftKey"].every(e => !t[e] || this._allowedModifierKeys.indexOf(e) > -1); switch (e) { case 9: return void this.tabOut.next(); case 40: if (this._vertical && n) { this.setNextItemActive(); break } return; case 38: if (this._vertical && n) { this.setPreviousItemActive(); break } return; case 39: if (this._horizontal && n) { "rtl" === this._horizontal ? this.setPreviousItemActive() : this.setNextItemActive(); break } return; case 37: if (this._horizontal && n) { "rtl" === this._horizontal ? this.setNextItemActive() : this.setPreviousItemActive(); break } return; case 36: if (this._homeAndEnd && n) { this.setFirstItemActive(); break } return; case 35: if (this._homeAndEnd && n) { this.setLastItemActive(); break } return; default: return void ((n || Vg(t, "shiftKey")) && (t.key && 1 === t.key.length ? this._letterKeyStream.next(t.key.toLocaleUpperCase()) : (e >= 65 && e <= 90 || e >= 48 && e <= 57) && this._letterKeyStream.next(String.fromCharCode(e)))) }this._pressedLetters = [], t.preventDefault() } get activeItemIndex() { return this._activeItemIndex } get activeItem() { return this._activeItem } isTyping() { return this._pressedLetters.length > 0 } setFirstItemActive() { this._setActiveItemByIndex(0, 1) } setLastItemActive() { this._setActiveItemByIndex(this._items.length - 1, -1) } setNextItemActive() { this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1) } setPreviousItemActive() { this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive() : this._setActiveItemByDelta(-1) } updateActiveItem(t) { const e = this._getItemsArray(), n = "number" == typeof t ? t : e.indexOf(t), i = e[n]; this._activeItem = null == i ? null : i, this._activeItemIndex = n } _setActiveItemByDelta(t) { this._wrap ? this._setActiveInWrapMode(t) : this._setActiveInDefaultMode(t) } _setActiveInWrapMode(t) { const e = this._getItemsArray(); for (let n = 1; n <= e.length; n++) { const i = (this._activeItemIndex + t * n + e.length) % e.length; if (!this._skipPredicateFn(e[i])) return void this.setActiveItem(i) } } _setActiveInDefaultMode(t) { this._setActiveItemByIndex(this._activeItemIndex + t, t) } _setActiveItemByIndex(t, e) { const n = this._getItemsArray(); if (n[t]) { for (; this._skipPredicateFn(n[t]);)if (!n[t += e]) return; this.setActiveItem(t) } } _getItemsArray() { return this._items instanceof Fl ? this._items.toArray() : this._items } }{ setActiveItem(t) { this.activeItem && this.activeItem.setInactiveStyles(), super.setActiveItem(t), this.activeItem && this.activeItem.setActiveStyles() } } let Yg = (() => { class t { constructor(t) { this._platform = t } isDisabled(t) { return t.hasAttribute("disabled") } isVisible(t) { return function (t) { return !!(t.offsetWidth || t.offsetHeight || "function" == typeof t.getClientRects && t.getClientRects().length) }(t) && "visible" === getComputedStyle(t).visibility } isTabbable(t) { if (!this._platform.isBrowser) return !1; const e = function (t) { try { return t.frameElement } catch (DA) { return null } }((n = t).ownerDocument && n.ownerDocument.defaultView || window); var n; if (e) { if (-1 === Gg(e)) return !1; if (!this.isVisible(e)) return !1 } let i = t.nodeName.toLowerCase(), s = Gg(t); return t.hasAttribute("contenteditable") ? -1 !== s : "iframe" !== i && "object" !== i && !(this._platform.WEBKIT && this._platform.IOS && !function (t) { let e = t.nodeName.toLowerCase(), n = "input" === e && t.type; return "text" === n || "password" === n || "select" === e || "textarea" === e }(t)) && ("audio" === i ? !!t.hasAttribute("controls") && -1 !== s : "video" === i ? -1 !== s && (null !== s || this._platform.FIREFOX || t.hasAttribute("controls")) : t.tabIndex >= 0) } isFocusable(t, e) { return function (t) { return !function (t) { return function (t) { return "input" == t.nodeName.toLowerCase() }(t) && "hidden" == t.type }(t) && (function (t) { let e = t.nodeName.toLowerCase(); return "input" === e || "select" === e || "button" === e || "textarea" === e }(t) || function (t) { return function (t) { return "a" == t.nodeName.toLowerCase() }(t) && t.hasAttribute("href") }(t) || t.hasAttribute("contenteditable") || Zg(t)) }(t) && !this.isDisabled(t) && ((null == e ? void 0 : e.ignoreVisibility) || this.isVisible(t)) } } return t.\u0275fac = function (e) { return new (e || t)(li(km)) }, t.\u0275prov = dt({ factory: function () { return new t(li(km)) }, token: t, providedIn: "root" }), t })(); function Zg(t) { if (!t.hasAttribute("tabindex") || void 0 === t.tabIndex) return !1; let e = t.getAttribute("tabindex"); return "-32768" != e && !(!e || isNaN(parseInt(e, 10))) } function Gg(t) { if (!Zg(t)) return null; const e = parseInt(t.getAttribute("tabindex") || "", 10); return isNaN(e) ? -1 : e } class Qg { constructor(t, e, n, i, s = !1) { this._element = t, this._checker = e, this._ngZone = n, this._document = i, this._hasAttached = !1, this.startAnchorListener = () => this.focusLastTabbableElement(), this.endAnchorListener = () => this.focusFirstTabbableElement(), this._enabled = !0, s || this.attachAnchors() } get enabled() { return this._enabled } set enabled(t) { this._enabled = t, this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(t, this._startAnchor), this._toggleAnchorTabIndex(t, this._endAnchor)) } destroy() { const t = this._startAnchor, e = this._endAnchor; t && (t.removeEventListener("focus", this.startAnchorListener), t.parentNode && t.parentNode.removeChild(t)), e && (e.removeEventListener("focus", this.endAnchorListener), e.parentNode && e.parentNode.removeChild(e)), this._startAnchor = this._endAnchor = null, this._hasAttached = !1 } attachAnchors() { return !!this._hasAttached || (this._ngZone.runOutsideAngular(() => { this._startAnchor || (this._startAnchor = this._createAnchor(), this._startAnchor.addEventListener("focus", this.startAnchorListener)), this._endAnchor || (this._endAnchor = this._createAnchor(), this._endAnchor.addEventListener("focus", this.endAnchorListener)) }), this._element.parentNode && (this._element.parentNode.insertBefore(this._startAnchor, this._element), this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling), this._hasAttached = !0), this._hasAttached) } focusInitialElementWhenReady(t) { return new Promise(e => { this._executeOnStable(() => e(this.focusInitialElement(t))) }) } focusFirstTabbableElementWhenReady(t) { return new Promise(e => { this._executeOnStable(() => e(this.focusFirstTabbableElement(t))) }) } focusLastTabbableElementWhenReady(t) { return new Promise(e => { this._executeOnStable(() => e(this.focusLastTabbableElement(t))) }) } _getRegionBoundary(t) { let e = this._element.querySelectorAll(`[cdk-focus-region-${t}], [cdkFocusRegion${t}], [cdk-focus-${t}]`); for (let n = 0; n < e.length; n++)e[n].hasAttribute(`cdk-focus-${t}`) ? console.warn(`Found use of deprecated attribute 'cdk-focus-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`, e[n]) : e[n].hasAttribute(`cdk-focus-region-${t}`) && console.warn(`Found use of deprecated attribute 'cdk-focus-region-${t}', use 'cdkFocusRegion${t}' instead. The deprecated attribute will be removed in 8.0.0.`, e[n]); return "start" == t ? e.length ? e[0] : this._getFirstTabbableElement(this._element) : e.length ? e[e.length - 1] : this._getLastTabbableElement(this._element) } focusInitialElement(t) { const e = this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]"); if (e) { if (e.hasAttribute("cdk-focus-initial") && console.warn("Found use of deprecated attribute 'cdk-focus-initial', use 'cdkFocusInitial' instead. The deprecated attribute will be removed in 8.0.0", e), !this._checker.isFocusable(e)) { const n = this._getFirstTabbableElement(e); return null == n || n.focus(t), !!n } return e.focus(t), !0 } return this.focusFirstTabbableElement(t) } focusFirstTabbableElement(t) { const e = this._getRegionBoundary("start"); return e && e.focus(t), !!e } focusLastTabbableElement(t) { const e = this._getRegionBoundary("end"); return e && e.focus(t), !!e } hasAttached() { return this._hasAttached } _getFirstTabbableElement(t) { if (this._checker.isFocusable(t) && this._checker.isTabbable(t)) return t; let e = t.children || t.childNodes; for (let n = 0; n < e.length; n++) { let t = e[n].nodeType === this._document.ELEMENT_NODE ? this._getFirstTabbableElement(e[n]) : null; if (t) return t } return null } _getLastTabbableElement(t) { if (this._checker.isFocusable(t) && this._checker.isTabbable(t)) return t; let e = t.children || t.childNodes; for (let n = e.length - 1; n >= 0; n--) { let t = e[n].nodeType === this._document.ELEMENT_NODE ? this._getLastTabbableElement(e[n]) : null; if (t) return t } return null } _createAnchor() { const t = this._document.createElement("div"); return this._toggleAnchorTabIndex(this._enabled, t), t.classList.add("cdk-visually-hidden"), t.classList.add("cdk-focus-trap-anchor"), t.setAttribute("aria-hidden", "true"), t } _toggleAnchorTabIndex(t, e) { t ? e.setAttribute("tabindex", "0") : e.removeAttribute("tabindex") } toggleAnchors(t) { this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(t, this._startAnchor), this._toggleAnchorTabIndex(t, this._endAnchor)) } _executeOnStable(t) { this._ngZone.isStable ? t() : this._ngZone.onStable.pipe(Iu(1)).subscribe(t) } } let Xg = (() => { class t { constructor(t, e, n) { this._checker = t, this._ngZone = e, this._document = n } create(t, e = !1) { return new Qg(t, this._checker, this._ngZone, this._document, e) } } return t.\u0275fac = function (e) { return new (e || t)(li(Yg), li(vc), li(Jc)) }, t.\u0275prov = dt({ factory: function () { return new t(li(Yg), li(vc), li(Jc)) }, token: t, providedIn: "root" }), t })(); "undefined" != typeof Element && Element; const Jg = new $n("liveAnnouncerElement", { providedIn: "root", factory: function () { return null } }), t_ = new $n("LIVE_ANNOUNCER_DEFAULT_OPTIONS"); let e_ = (() => { class t { constructor(t, e, n, i) { this._ngZone = e, this._defaultOptions = i, this._document = n, this._liveElement = t || this._createLiveElement() } announce(t, ...e) { const n = this._defaultOptions; let i, s; return 1 === e.length && "number" == typeof e[0] ? s = e[0] : [i, s] = e, this.clear(), clearTimeout(this._previousTimeout), i || (i = n && n.politeness ? n.politeness : "polite"), null == s && n && (s = n.duration), this._liveElement.setAttribute("aria-live", i), this._ngZone.runOutsideAngular(() => new Promise(e => { clearTimeout(this._previousTimeout), this._previousTimeout = setTimeout(() => { this._liveElement.textContent = t, e(), "number" == typeof s && (this._previousTimeout = setTimeout(() => this.clear(), s)) }, 100) })) } clear() { this._liveElement && (this._liveElement.textContent = "") } ngOnDestroy() { clearTimeout(this._previousTimeout), this._liveElement && this._liveElement.parentNode && (this._liveElement.parentNode.removeChild(this._liveElement), this._liveElement = null) } _createLiveElement() { const t = "cdk-live-announcer-element", e = this._document.getElementsByClassName(t), n = this._document.createElement("div"); for (let i = 0; i < e.length; i++)e[i].parentNode.removeChild(e[i]); return n.classList.add(t), n.classList.add("cdk-visually-hidden"), n.setAttribute("aria-atomic", "true"), n.setAttribute("aria-live", "polite"), this._document.body.appendChild(n), n } } return t.\u0275fac = function (e) { return new (e || t)(li(Jg, 8), li(vc), li(Jc), li(t_, 8)) }, t.\u0275prov = dt({ factory: function () { return new t(li(Jg, 8), li(vc), li(Jc), li(t_, 8)) }, token: t, providedIn: "root" }), t })(); function n_(t) { return 0 === t.buttons } function i_(t) { const e = t.touches && t.touches[0] || t.changedTouches && t.changedTouches[0]; return !(!e || -1 !== e.identifier || null != e.radiusX && 1 !== e.radiusX || null != e.radiusY && 1 !== e.radiusY) } const s_ = new $n("cdk-focus-monitor-default-options"), r_ = Om({ passive: !0, capture: !0 }); let o_ = (() => { class t { constructor(t, e, n, i) { this._ngZone = t, this._platform = e, this._origin = null, this._windowFocused = !1, this._elementInfo = new Map, this._monitoredElementCount = 0, this._rootNodeFocusListenerCount = new Map, this._documentKeydownListener = () => { this._lastTouchTarget = null, this._setOriginForCurrentEventQueue("keyboard") }, this._documentMousedownListener = t => { if (!this._lastTouchTarget) { const e = n_(t) ? "keyboard" : "mouse"; this._setOriginForCurrentEventQueue(e) } }, this._documentTouchstartListener = t => { i_(t) ? this._lastTouchTarget || this._setOriginForCurrentEventQueue("keyboard") : (null != this._touchTimeoutId && clearTimeout(this._touchTimeoutId), this._lastTouchTarget = a_(t), this._touchTimeoutId = setTimeout(() => this._lastTouchTarget = null, 650)) }, this._windowFocusListener = () => { this._windowFocused = !0, this._windowFocusTimeoutId = setTimeout(() => this._windowFocused = !1) }, this._rootNodeFocusAndBlurListener = t => { const e = a_(t), n = "focus" === t.type ? this._onFocus : this._onBlur; for (let i = e; i; i = i.parentElement)n.call(this, t, i) }, this._document = n, this._detectionMode = (null == i ? void 0 : i.detectionMode) || 0 } monitor(t, e = !1) { const n = pm(t); if (!this._platform.isBrowser || 1 !== n.nodeType) return pu(null); const i = function (t) { if (function () { if (null == Am) { const t = "undefined" != typeof document ? document.head : null; Am = !(!t || !t.createShadowRoot && !t.attachShadow) } return Am }()) { const e = t.getRootNode ? t.getRootNode() : null; if ("undefined" != typeof ShadowRoot && ShadowRoot && e instanceof ShadowRoot) return e } return null }(n) || this._getDocument(), s = this._elementInfo.get(n); if (s) return e && (s.checkChildren = !0), s.subject; const r = { checkChildren: e, subject: new k, rootNode: i }; return this._elementInfo.set(n, r), this._registerGlobalListeners(r), r.subject } stopMonitoring(t) { const e = pm(t), n = this._elementInfo.get(e); n && (n.subject.complete(), this._setClasses(e), this._elementInfo.delete(e), this._removeGlobalListeners(n)) } focusVia(t, e, n) { const i = pm(t); i === this._getDocument().activeElement ? this._getClosestElementsInfo(i).forEach(([t, n]) => this._originChanged(t, e, n)) : (this._setOriginForCurrentEventQueue(e), "function" == typeof i.focus && i.focus(n)) } ngOnDestroy() { this._elementInfo.forEach((t, e) => this.stopMonitoring(e)) } _getDocument() { return this._document || document } _getWindow() { return this._getDocument().defaultView || window } _toggleClass(t, e, n) { n ? t.classList.add(e) : t.classList.remove(e) } _getFocusOrigin(t) { return this._origin ? this._origin : this._windowFocused && this._lastFocusOrigin ? this._lastFocusOrigin : this._wasCausedByTouch(t) ? "touch" : "program" } _setClasses(t, e) { this._toggleClass(t, "cdk-focused", !!e), this._toggleClass(t, "cdk-touch-focused", "touch" === e), this._toggleClass(t, "cdk-keyboard-focused", "keyboard" === e), this._toggleClass(t, "cdk-mouse-focused", "mouse" === e), this._toggleClass(t, "cdk-program-focused", "program" === e) } _setOriginForCurrentEventQueue(t) { this._ngZone.runOutsideAngular(() => { this._origin = t, 0 === this._detectionMode && (this._originTimeoutId = setTimeout(() => this._origin = null, 1)) }) } _wasCausedByTouch(t) { const e = a_(t); return this._lastTouchTarget instanceof Node && e instanceof Node && (e === this._lastTouchTarget || e.contains(this._lastTouchTarget)) } _onFocus(t, e) { const n = this._elementInfo.get(e); n && (n.checkChildren || e === a_(t)) && this._originChanged(e, this._getFocusOrigin(t), n) } _onBlur(t, e) { const n = this._elementInfo.get(e); !n || n.checkChildren && t.relatedTarget instanceof Node && e.contains(t.relatedTarget) || (this._setClasses(e), this._emitOrigin(n.subject, null)) } _emitOrigin(t, e) { this._ngZone.run(() => t.next(e)) } _registerGlobalListeners(t) { if (!this._platform.isBrowser) return; const e = t.rootNode, n = this._rootNodeFocusListenerCount.get(e) || 0; n || this._ngZone.runOutsideAngular(() => { e.addEventListener("focus", this._rootNodeFocusAndBlurListener, r_), e.addEventListener("blur", this._rootNodeFocusAndBlurListener, r_) }), this._rootNodeFocusListenerCount.set(e, n + 1), 1 == ++this._monitoredElementCount && this._ngZone.runOutsideAngular(() => { const t = this._getDocument(), e = this._getWindow(); t.addEventListener("keydown", this._documentKeydownListener, r_), t.addEventListener("mousedown", this._documentMousedownListener, r_), t.addEventListener("touchstart", this._documentTouchstartListener, r_), e.addEventListener("focus", this._windowFocusListener) }) } _removeGlobalListeners(t) { const e = t.rootNode; if (this._rootNodeFocusListenerCount.has(e)) { const t = this._rootNodeFocusListenerCount.get(e); t > 1 ? this._rootNodeFocusListenerCount.set(e, t - 1) : (e.removeEventListener("focus", this._rootNodeFocusAndBlurListener, r_), e.removeEventListener("blur", this._rootNodeFocusAndBlurListener, r_), this._rootNodeFocusListenerCount.delete(e)) } if (!--this._monitoredElementCount) { const t = this._getDocument(), e = this._getWindow(); t.removeEventListener("keydown", this._documentKeydownListener, r_), t.removeEventListener("mousedown", this._documentMousedownListener, r_), t.removeEventListener("touchstart", this._documentTouchstartListener, r_), e.removeEventListener("focus", this._windowFocusListener), clearTimeout(this._windowFocusTimeoutId), clearTimeout(this._touchTimeoutId), clearTimeout(this._originTimeoutId) } } _originChanged(t, e, n) { this._setClasses(t, e), this._emitOrigin(n.subject, e), this._lastFocusOrigin = e } _getClosestElementsInfo(t) { const e = []; return this._elementInfo.forEach((n, i) => { (i === t || n.checkChildren && i.contains(t)) && e.push([i, n]) }), e } } return t.\u0275fac = function (e) { return new (e || t)(li(vc), li(km), li(Jc, 8), li(s_, 8)) }, t.\u0275prov = dt({ factory: function () { return new t(li(vc), li(km), li(Jc, 8), li(s_, 8)) }, token: t, providedIn: "root" }), t })(); function a_(t) { return t.composedPath ? t.composedPath()[0] : t.target } const l_ = "cdk-high-contrast-black-on-white", c_ = "cdk-high-contrast-white-on-black", h_ = "cdk-high-contrast-active"; let u_ = (() => { class t { constructor(t, e) { this._platform = t, this._document = e } getHighContrastMode() { if (!this._platform.isBrowser) return 0; const t = this._document.createElement("div"); t.style.backgroundColor = "rgb(1,2,3)", t.style.position = "absolute", this._document.body.appendChild(t); const e = this._document.defaultView || window, n = e && e.getComputedStyle ? e.getComputedStyle(t) : null, i = (n && n.backgroundColor || "").replace(/ /g, ""); switch (this._document.body.removeChild(t), i) { case "rgb(0,0,0)": return 2; case "rgb(255,255,255)": return 1 }return 0 } _applyBodyHighContrastModeCssClasses() { if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) { const t = this._document.body.classList; t.remove(h_), t.remove(l_), t.remove(c_), this._hasCheckedHighContrastMode = !0; const e = this.getHighContrastMode(); 1 === e ? (t.add(h_), t.add(l_)) : 2 === e && (t.add(h_), t.add(c_)) } } } return t.\u0275fac = function (e) { return new (e || t)(li(km), li(Jc)) }, t.\u0275prov = dt({ factory: function () { return new t(li(km), li(Jc)) }, token: t, providedIn: "root" }), t })(), d_ = (() => { class t { constructor(t) { t._applyBodyHighContrastModeCssClasses() } } return t.\u0275fac = function (e) { return new (e || t)(li(u_)) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ imports: [[xm, Wg]] }), t })(); const p_ = new Ba("12.0.4"); class f_ { } const m_ = "*"; function g_(t, e) { return { type: 7, name: t, definitions: e, options: {} } } function __(t, e = null) { return { type: 4, styles: e, timings: t } } function y_(t, e = null) { return { type: 2, steps: t, options: e } } function b_(t) { return { type: 6, styles: t, offset: null } } function v_(t, e, n) { return { type: 0, name: t, styles: e, options: n } } function w_(t, e, n = null) { return { type: 1, expr: t, animation: e, options: n } } function C_(t = null) { return { type: 9, options: t } } function k_(t, e, n = null) { return { type: 11, selector: t, animation: e, options: n } } function x_(t) { Promise.resolve(null).then(t) } class S_ { constructor(t = 0, e = 0) { this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._started = !1, this._destroyed = !1, this._finished = !1, this._position = 0, this.parentPlayer = null, this.totalTime = t + e } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } hasStarted() { return this._started } init() { } play() { this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0 } triggerMicrotask() { x_(() => this._onFinish()) } _onStart() { this._onStartFns.forEach(t => t()), this._onStartFns = [] } pause() { } restart() { } finish() { this._onFinish() } destroy() { this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), this.finish(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } reset() { this._started = !1 } setPosition(t) { this._position = this.totalTime ? t * this.totalTime : 1 } getPosition() { return this.totalTime ? this._position / this.totalTime : 1 } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } } class E_ { constructor(t) { this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, this.players = t; let e = 0, n = 0, i = 0; const s = this.players.length; 0 == s ? x_(() => this._onFinish()) : this.players.forEach(t => { t.onDone(() => { ++e == s && this._onFinish() }), t.onDestroy(() => { ++n == s && this._onDestroy() }), t.onStart(() => { ++i == s && this._onStart() }) }), this.totalTime = this.players.reduce((t, e) => Math.max(t, e.totalTime), 0) } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } init() { this.players.forEach(t => t.init()) } onStart(t) { this._onStartFns.push(t) } _onStart() { this.hasStarted() || (this._started = !0, this._onStartFns.forEach(t => t()), this._onStartFns = []) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } hasStarted() { return this._started } play() { this.parentPlayer || this.init(), this._onStart(), this.players.forEach(t => t.play()) } pause() { this.players.forEach(t => t.pause()) } restart() { this.players.forEach(t => t.restart()) } finish() { this._onFinish(), this.players.forEach(t => t.finish()) } destroy() { this._onDestroy() } _onDestroy() { this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(t => t.destroy()), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } reset() { this.players.forEach(t => t.reset()), this._destroyed = !1, this._finished = !1, this._started = !1 } setPosition(t) { const e = t * this.totalTime; this.players.forEach(t => { const n = t.totalTime ? Math.min(1, e / t.totalTime) : 1; t.setPosition(n) }) } getPosition() { const t = this.players.reduce((t, e) => null === t || e.totalTime > t.totalTime ? e : t, null); return null != t ? t.getPosition() : 0 } beforeDestroy() { this.players.forEach(t => { t.beforeDestroy && t.beforeDestroy() }) } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } } function T_() { return "undefined" != typeof window && void 0 !== window.document } function R_() { return "undefined" != typeof process && "[object process]" === {}.toString.call(process) } function A_(t) { switch (t.length) { case 0: return new S_; case 1: return t[0]; default: return new E_(t) } } function O_(t, e, n, i, s = {}, r = {}) { const o = [], a = []; let l = -1, c = null; if (i.forEach(t => { const n = t.offset, i = n == l, h = i && c || {}; Object.keys(t).forEach(n => { let i = n, a = t[n]; if ("offset" !== n) switch (i = e.normalizePropertyName(i, o), a) { case "!": a = s[n]; break; case m_: a = r[n]; break; default: a = e.normalizeStyleValue(n, i, a, o) }h[i] = a }), i || a.push(h), c = h, l = n }), o.length) { const t = "\n - "; throw new Error(`Unable to animate due to the following errors:${t}${o.join(t)}`) } return a } function I_(t, e, n, i) { switch (e) { case "start": t.onStart(() => i(n && D_(n, "start", t))); break; case "done": t.onDone(() => i(n && D_(n, "done", t))); break; case "destroy": t.onDestroy(() => i(n && D_(n, "destroy", t))) } } function D_(t, e, n) { const i = n.totalTime, s = P_(t.element, t.triggerName, t.fromState, t.toState, e || t.phaseName, null == i ? t.totalTime : i, !!n.disabled), r = t._data; return null != r && (s._data = r), s } function P_(t, e, n, i, s = "", r = 0, o) { return { element: t, triggerName: e, fromState: n, toState: i, phaseName: s, totalTime: r, disabled: !!o } } function M_(t, e, n) { let i; return t instanceof Map ? (i = t.get(e), i || t.set(e, i = n)) : (i = t[e], i || (i = t[e] = n)), i } function N_(t) { const e = t.indexOf(":"); return [t.substring(1, e), t.substr(e + 1)] } let F_ = (t, e) => !1, L_ = (t, e) => !1, V_ = (t, e, n) => []; const j_ = R_(); (j_ || "undefined" != typeof Element) && (F_ = T_() ? (t, e) => { for (; e && e !== document.documentElement;) { if (e === t) return !0; e = e.parentNode || e.host } return !1 } : (t, e) => t.contains(e), L_ = (() => { if (j_ || Element.prototype.matches) return (t, e) => t.matches(e); { const t = Element.prototype, e = t.matchesSelector || t.mozMatchesSelector || t.msMatchesSelector || t.oMatchesSelector || t.webkitMatchesSelector; return e ? (t, n) => e.apply(t, [n]) : L_ } })(), V_ = (t, e, n) => { let i = []; if (n) { const n = t.querySelectorAll(e); for (let t = 0; t < n.length; t++)i.push(n[t]) } else { const n = t.querySelector(e); n && i.push(n) } return i }); let B_ = null, H_ = !1; function U_(t) { B_ || (B_ = ("undefined" != typeof document ? document.body : null) || {}, H_ = !!B_.style && "WebkitAppearance" in B_.style); let e = !0; return B_.style && !function (t) { return "ebkit" == t.substring(1, 6) }(t) && (e = t in B_.style, !e && H_) && (e = "Webkit" + t.charAt(0).toUpperCase() + t.substr(1) in B_.style), e } const z_ = L_, $_ = F_, q_ = V_; function W_(t) { const e = {}; return Object.keys(t).forEach(n => { const i = n.replace(/([a-z])([A-Z])/g, "$1-$2"); e[i] = t[n] }), e } let K_ = (() => { class t { validateStyleProperty(t) { return U_(t) } matchesElement(t, e) { return z_(t, e) } containsElement(t, e) { return $_(t, e) } query(t, e, n) { return q_(t, e, n) } computeStyle(t, e, n) { return n || "" } animate(t, e, n, i, s, r = [], o) { return new S_(n, i) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), Y_ = (() => { class t { } return t.NOOP = new K_, t })(); const Z_ = "ng-enter", G_ = "ng-leave", Q_ = "ng-trigger", X_ = ".ng-trigger", J_ = "ng-animating", ty = ".ng-animating"; function ey(t) { if ("number" == typeof t) return t; const e = t.match(/^(-?[\.\d]+)(m?s)/); return !e || e.length < 2 ? 0 : ny(parseFloat(e[1]), e[2]) } function ny(t, e) { switch (e) { case "s": return 1e3 * t; default: return t } } function iy(t, e, n) { return t.hasOwnProperty("duration") ? t : function (t, e, n) { let i, s = 0, r = ""; if ("string" == typeof t) { const n = t.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i); if (null === n) return e.push(`The provided timing value "${t}" is invalid.`), { duration: 0, delay: 0, easing: "" }; i = ny(parseFloat(n[1]), n[2]); const o = n[3]; null != o && (s = ny(parseFloat(o), n[4])); const a = n[5]; a && (r = a) } else i = t; if (!n) { let n = !1, r = e.length; i < 0 && (e.push("Duration values below 0 are not allowed for this animation step."), n = !0), s < 0 && (e.push("Delay values below 0 are not allowed for this animation step."), n = !0), n && e.splice(r, 0, `The provided timing value "${t}" is invalid.`) } return { duration: i, delay: s, easing: r } }(t, e, n) } function sy(t, e = {}) { return Object.keys(t).forEach(n => { e[n] = t[n] }), e } function ry(t, e, n = {}) { if (e) for (let i in t) n[i] = t[i]; else sy(t, n); return n } function oy(t, e, n) { return n ? e + ":" + n + ";" : "" } function ay(t) { let e = ""; for (let n = 0; n < t.style.length; n++) { const i = t.style.item(n); e += oy(0, i, t.style.getPropertyValue(i)) } for (const n in t.style) t.style.hasOwnProperty(n) && !n.startsWith("_") && (e += oy(0, n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), t.style[n])); t.setAttribute("style", e) } function ly(t, e, n) { t.style && (Object.keys(e).forEach(i => { const s = gy(i); n && !n.hasOwnProperty(i) && (n[i] = t.style[s]), t.style[s] = e[i] }), R_() && ay(t)) } function cy(t, e) { t.style && (Object.keys(e).forEach(e => { const n = gy(e); t.style[n] = "" }), R_() && ay(t)) } function hy(t) { return Array.isArray(t) ? 1 == t.length ? t[0] : y_(t) : t } const uy = new RegExp("{{\\s*(.+?)\\s*}}", "g"); function dy(t) { let e = []; if ("string" == typeof t) { let n; for (; n = uy.exec(t);)e.push(n[1]); uy.lastIndex = 0 } return e } function py(t, e, n) { const i = t.toString(), s = i.replace(uy, (t, i) => { let s = e[i]; return e.hasOwnProperty(i) || (n.push(`Please provide a value for the animation param ${i}`), s = ""), s.toString() }); return s == i ? t : s } function fy(t) { const e = []; let n = t.next(); for (; !n.done;)e.push(n.value), n = t.next(); return e } const my = /-+([a-z0-9])/g; function gy(t) { return t.replace(my, (...t) => t[1].toUpperCase()) } function _y(t, e) { return 0 === t || 0 === e } function yy(t, e, n) { const i = Object.keys(n); if (i.length && e.length) { let r = e[0], o = []; if (i.forEach(t => { r.hasOwnProperty(t) || o.push(t), r[t] = n[t] }), o.length) for (var s = 1; s < e.length; s++) { let n = e[s]; o.forEach(function (e) { n[e] = vy(t, e) }) } } return e } function by(t, e, n) { switch (e.type) { case 7: return t.visitTrigger(e, n); case 0: return t.visitState(e, n); case 1: return t.visitTransition(e, n); case 2: return t.visitSequence(e, n); case 3: return t.visitGroup(e, n); case 4: return t.visitAnimate(e, n); case 5: return t.visitKeyframes(e, n); case 6: return t.visitStyle(e, n); case 8: return t.visitReference(e, n); case 9: return t.visitAnimateChild(e, n); case 10: return t.visitAnimateRef(e, n); case 11: return t.visitQuery(e, n); case 12: return t.visitStagger(e, n); default: throw new Error(`Unable to resolve animation metadata node #${e.type}`) } } function vy(t, e) { return window.getComputedStyle(t)[e] } const wy = "*"; function Cy(t, e) { const n = []; return "string" == typeof t ? t.split(/\s*,\s*/).forEach(t => function (t, e, n) { if (":" == t[0]) { const i = function (t, e) { switch (t) { case ":enter": return "void => *"; case ":leave": return "* => void"; case ":increment": return (t, e) => parseFloat(e) > parseFloat(t); case ":decrement": return (t, e) => parseFloat(e) < parseFloat(t); default: return e.push(`The transition alias value "${t}" is not supported`), "* => *" } }(t, n); if ("function" == typeof i) return void e.push(i); t = i } const i = t.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/); if (null == i || i.length < 4) return n.push(`The provided transition expression "${t}" is not supported`), e; const s = i[1], r = i[2], o = i[3]; e.push(Sy(s, o)), "<" != r[0] || s == wy && o == wy || e.push(Sy(o, s)) }(t, n, e)) : n.push(t), n } const ky = new Set(["true", "1"]), xy = new Set(["false", "0"]); function Sy(t, e) { const n = ky.has(t) || xy.has(t), i = ky.has(e) || xy.has(e); return (s, r) => { let o = t == wy || t == s, a = e == wy || e == r; return !o && n && "boolean" == typeof s && (o = s ? ky.has(t) : xy.has(t)), !a && i && "boolean" == typeof r && (a = r ? ky.has(e) : xy.has(e)), o && a } } const Ey = new RegExp("s*:selfs*,?", "g"); function Ty(t, e, n) { return new Ry(t).build(e, n) } class Ry { constructor(t) { this._driver = t } build(t, e) { const n = new Ay(e); return this._resetContextStyleTimingState(n), by(this, hy(t), n) } _resetContextStyleTimingState(t) { t.currentQuerySelector = "", t.collectedStyles = {}, t.collectedStyles[""] = {}, t.currentTime = 0 } visitTrigger(t, e) { let n = e.queryCount = 0, i = e.depCount = 0; const s = [], r = []; return "@" == t.name.charAt(0) && e.errors.push("animation triggers cannot be prefixed with an `@` sign (e.g. trigger('@foo', [...]))"), t.definitions.forEach(t => { if (this._resetContextStyleTimingState(e), 0 == t.type) { const n = t, i = n.name; i.toString().split(/\s*,\s*/).forEach(t => { n.name = t, s.push(this.visitState(n, e)) }), n.name = i } else if (1 == t.type) { const s = this.visitTransition(t, e); n += s.queryCount, i += s.depCount, r.push(s) } else e.errors.push("only state() and transition() definitions can sit inside of a trigger()") }), { type: 7, name: t.name, states: s, transitions: r, queryCount: n, depCount: i, options: null } } visitState(t, e) { const n = this.visitStyle(t.styles, e), i = t.options && t.options.params || null; if (n.containsDynamicStyles) { const s = new Set, r = i || {}; if (n.styles.forEach(t => { if (Oy(t)) { const e = t; Object.keys(e).forEach(t => { dy(e[t]).forEach(t => { r.hasOwnProperty(t) || s.add(t) }) }) } }), s.size) { const n = fy(s.values()); e.errors.push(`state("${t.name}", ...) must define default values for all the following style substitutions: ${n.join(", ")}`) } } return { type: 0, name: t.name, style: n, options: i ? { params: i } : null } } visitTransition(t, e) { e.queryCount = 0, e.depCount = 0; const n = by(this, hy(t.animation), e); return { type: 1, matchers: Cy(t.expr, e.errors), animation: n, queryCount: e.queryCount, depCount: e.depCount, options: Iy(t.options) } } visitSequence(t, e) { return { type: 2, steps: t.steps.map(t => by(this, t, e)), options: Iy(t.options) } } visitGroup(t, e) { const n = e.currentTime; let i = 0; const s = t.steps.map(t => { e.currentTime = n; const s = by(this, t, e); return i = Math.max(i, e.currentTime), s }); return e.currentTime = i, { type: 3, steps: s, options: Iy(t.options) } } visitAnimate(t, e) { const n = function (t, e) { let n = null; if (t.hasOwnProperty("duration")) n = t; else if ("number" == typeof t) return Dy(iy(t, e).duration, 0, ""); const i = t; if (i.split(/\s+/).some(t => "{" == t.charAt(0) && "{" == t.charAt(1))) { const t = Dy(0, 0, ""); return t.dynamic = !0, t.strValue = i, t } return n = n || iy(i, e), Dy(n.duration, n.delay, n.easing) }(t.timings, e.errors); let i; e.currentAnimateTimings = n; let s = t.styles ? t.styles : b_({}); if (5 == s.type) i = this.visitKeyframes(s, e); else { let s = t.styles, r = !1; if (!s) { r = !0; const t = {}; n.easing && (t.easing = n.easing), s = b_(t) } e.currentTime += n.duration + n.delay; const o = this.visitStyle(s, e); o.isEmptyStep = r, i = o } return e.currentAnimateTimings = null, { type: 4, timings: n, style: i, options: null } } visitStyle(t, e) { const n = this._makeStyleAst(t, e); return this._validateStyleAst(n, e), n } _makeStyleAst(t, e) { const n = []; Array.isArray(t.styles) ? t.styles.forEach(t => { "string" == typeof t ? t == m_ ? n.push(t) : e.errors.push(`The provided style string value ${t} is not allowed.`) : n.push(t) }) : n.push(t.styles); let i = !1, s = null; return n.forEach(t => { if (Oy(t)) { const e = t, n = e.easing; if (n && (s = n, delete e.easing), !i) for (let t in e) if (e[t].toString().indexOf("{{") >= 0) { i = !0; break } } }), { type: 6, styles: n, easing: s, offset: t.offset, containsDynamicStyles: i, options: null } } _validateStyleAst(t, e) { const n = e.currentAnimateTimings; let i = e.currentTime, s = e.currentTime; n && s > 0 && (s -= n.duration + n.delay), t.styles.forEach(t => { "string" != typeof t && Object.keys(t).forEach(n => { if (!this._driver.validateStyleProperty(n)) return void e.errors.push(`The provided animation property "${n}" is not a supported CSS property for animations`); const r = e.collectedStyles[e.currentQuerySelector], o = r[n]; let a = !0; o && (s != i && s >= o.startTime && i <= o.endTime && (e.errors.push(`The CSS property "${n}" that exists between the times of "${o.startTime}ms" and "${o.endTime}ms" is also being animated in a parallel animation between the times of "${s}ms" and "${i}ms"`), a = !1), s = o.startTime), a && (r[n] = { startTime: s, endTime: i }), e.options && function (t, e, n) { const i = e.params || {}, s = dy(t); s.length && s.forEach(t => { i.hasOwnProperty(t) || n.push(`Unable to resolve the local animation param ${t} in the given list of values`) }) }(t[n], e.options, e.errors) }) }) } visitKeyframes(t, e) { const n = { type: 5, styles: [], options: null }; if (!e.currentAnimateTimings) return e.errors.push("keyframes() must be placed inside of a call to animate()"), n; let i = 0; const s = []; let r = !1, o = !1, a = 0; const l = t.steps.map(t => { const n = this._makeStyleAst(t, e); let l = null != n.offset ? n.offset : function (t) { if ("string" == typeof t) return null; let e = null; if (Array.isArray(t)) t.forEach(t => { if (Oy(t) && t.hasOwnProperty("offset")) { const n = t; e = parseFloat(n.offset), delete n.offset } }); else if (Oy(t) && t.hasOwnProperty("offset")) { const n = t; e = parseFloat(n.offset), delete n.offset } return e }(n.styles), c = 0; return null != l && (i++, c = n.offset = l), o = o || c < 0 || c > 1, r = r || c < a, a = c, s.push(c), n }); o && e.errors.push("Please ensure that all keyframe offsets are between 0 and 1"), r && e.errors.push("Please ensure that all keyframe offsets are in order"); const c = t.steps.length; let h = 0; i > 0 && i < c ? e.errors.push("Not all style() steps within the declared keyframes() contain offsets") : 0 == i && (h = 1 / (c - 1)); const u = c - 1, d = e.currentTime, p = e.currentAnimateTimings, f = p.duration; return l.forEach((t, i) => { const r = h > 0 ? i == u ? 1 : h * i : s[i], o = r * f; e.currentTime = d + p.delay + o, p.duration = o, this._validateStyleAst(t, e), t.offset = r, n.styles.push(t) }), n } visitReference(t, e) { return { type: 8, animation: by(this, hy(t.animation), e), options: Iy(t.options) } } visitAnimateChild(t, e) { return e.depCount++, { type: 9, options: Iy(t.options) } } visitAnimateRef(t, e) { return { type: 10, animation: this.visitReference(t.animation, e), options: Iy(t.options) } } visitQuery(t, e) { const n = e.currentQuerySelector, i = t.options || {}; e.queryCount++, e.currentQuery = t; const [s, r] = function (t) { const e = !!t.split(/\s*,\s*/).find(t => ":self" == t); return e && (t = t.replace(Ey, "")), [t = t.replace(/@\*/g, X_).replace(/@\w+/g, t => ".ng-trigger-" + t.substr(1)).replace(/:animating/g, ty), e] }(t.selector); e.currentQuerySelector = n.length ? n + " " + s : s, M_(e.collectedStyles, e.currentQuerySelector, {}); const o = by(this, hy(t.animation), e); return e.currentQuery = null, e.currentQuerySelector = n, { type: 11, selector: s, limit: i.limit || 0, optional: !!i.optional, includeSelf: r, animation: o, originalSelector: t.selector, options: Iy(t.options) } } visitStagger(t, e) { e.currentQuery || e.errors.push("stagger() can only be used inside of query()"); const n = "full" === t.timings ? { duration: 0, delay: 0, easing: "full" } : iy(t.timings, e.errors, !0); return { type: 12, animation: by(this, hy(t.animation), e), timings: n, options: null } } } class Ay { constructor(t) { this.errors = t, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, this.currentTime = 0, this.collectedStyles = {}, this.options = null } } function Oy(t) { return !Array.isArray(t) && "object" == typeof t } function Iy(t) { var e; return t ? (t = sy(t)).params && (t.params = (e = t.params) ? sy(e) : null) : t = {}, t } function Dy(t, e, n) { return { duration: t, delay: e, easing: n } } function Py(t, e, n, i, s, r, o = null, a = !1) { return { type: 1, element: t, keyframes: e, preStyleProps: n, postStyleProps: i, duration: s, delay: r, totalTime: s + r, easing: o, subTimeline: a } } class My { constructor() { this._map = new Map } consume(t) { let e = this._map.get(t); return e ? this._map.delete(t) : e = [], e } append(t, e) { let n = this._map.get(t); n || this._map.set(t, n = []), n.push(...e) } has(t) { return this._map.has(t) } clear() { this._map.clear() } } const Ny = new RegExp(":enter", "g"), Fy = new RegExp(":leave", "g"); function Ly(t, e, n, i, s, r = {}, o = {}, a, l, c = []) { return (new Vy).buildKeyframes(t, e, n, i, s, r, o, a, l, c) } class Vy { buildKeyframes(t, e, n, i, s, r, o, a, l, c = []) { l = l || new My; const h = new By(t, e, l, i, s, c, []); h.options = a, h.currentTimeline.setStyles([r], null, h.errors, a), by(this, n, h); const u = h.timelines.filter(t => t.containsAnimation()); if (u.length && Object.keys(o).length) { const t = u[u.length - 1]; t.allowOnlyTimelineStyles() || t.setStyles([o], null, h.errors, a) } return u.length ? u.map(t => t.buildKeyframes()) : [Py(e, [], [], [], 0, 0, "", !1)] } visitTrigger(t, e) { } visitState(t, e) { } visitTransition(t, e) { } visitAnimateChild(t, e) { const n = e.subInstructions.consume(e.element); if (n) { const i = e.createSubContext(t.options), s = e.currentTimeline.currentTime, r = this._visitSubInstructions(n, i, i.options); s != r && e.transformIntoNewTimeline(r) } e.previousNode = t } visitAnimateRef(t, e) { const n = e.createSubContext(t.options); n.transformIntoNewTimeline(), this.visitReference(t.animation, n), e.transformIntoNewTimeline(n.currentTimeline.currentTime), e.previousNode = t } _visitSubInstructions(t, e, n) { let i = e.currentTimeline.currentTime; const s = null != n.duration ? ey(n.duration) : null, r = null != n.delay ? ey(n.delay) : null; return 0 !== s && t.forEach(t => { const n = e.appendInstructionToTimeline(t, s, r); i = Math.max(i, n.duration + n.delay) }), i } visitReference(t, e) { e.updateOptions(t.options, !0), by(this, t.animation, e), e.previousNode = t } visitSequence(t, e) { const n = e.subContextCount; let i = e; const s = t.options; if (s && (s.params || s.delay) && (i = e.createSubContext(s), i.transformIntoNewTimeline(), null != s.delay)) { 6 == i.previousNode.type && (i.currentTimeline.snapshotCurrentStyles(), i.previousNode = jy); const t = ey(s.delay); i.delayNextStep(t) } t.steps.length && (t.steps.forEach(t => by(this, t, i)), i.currentTimeline.applyStylesToKeyframe(), i.subContextCount > n && i.transformIntoNewTimeline()), e.previousNode = t } visitGroup(t, e) { const n = []; let i = e.currentTimeline.currentTime; const s = t.options && t.options.delay ? ey(t.options.delay) : 0; t.steps.forEach(r => { const o = e.createSubContext(t.options); s && o.delayNextStep(s), by(this, r, o), i = Math.max(i, o.currentTimeline.currentTime), n.push(o.currentTimeline) }), n.forEach(t => e.currentTimeline.mergeTimelineCollectedStyles(t)), e.transformIntoNewTimeline(i), e.previousNode = t } _visitTiming(t, e) { if (t.dynamic) { const n = t.strValue; return iy(e.params ? py(n, e.params, e.errors) : n, e.errors) } return { duration: t.duration, delay: t.delay, easing: t.easing } } visitAnimate(t, e) { const n = e.currentAnimateTimings = this._visitTiming(t.timings, e), i = e.currentTimeline; n.delay && (e.incrementTime(n.delay), i.snapshotCurrentStyles()); const s = t.style; 5 == s.type ? this.visitKeyframes(s, e) : (e.incrementTime(n.duration), this.visitStyle(s, e), i.applyStylesToKeyframe()), e.currentAnimateTimings = null, e.previousNode = t } visitStyle(t, e) { const n = e.currentTimeline, i = e.currentAnimateTimings; !i && n.getCurrentStyleProperties().length && n.forwardFrame(); const s = i && i.easing || t.easing; t.isEmptyStep ? n.applyEmptyStep(s) : n.setStyles(t.styles, s, e.errors, e.options), e.previousNode = t } visitKeyframes(t, e) { const n = e.currentAnimateTimings, i = e.currentTimeline.duration, s = n.duration, r = e.createSubContext().currentTimeline; r.easing = n.easing, t.styles.forEach(t => { r.forwardTime((t.offset || 0) * s), r.setStyles(t.styles, t.easing, e.errors, e.options), r.applyStylesToKeyframe() }), e.currentTimeline.mergeTimelineCollectedStyles(r), e.transformIntoNewTimeline(i + s), e.previousNode = t } visitQuery(t, e) { const n = e.currentTimeline.currentTime, i = t.options || {}, s = i.delay ? ey(i.delay) : 0; s && (6 === e.previousNode.type || 0 == n && e.currentTimeline.getCurrentStyleProperties().length) && (e.currentTimeline.snapshotCurrentStyles(), e.previousNode = jy); let r = n; const o = e.invokeQuery(t.selector, t.originalSelector, t.limit, t.includeSelf, !!i.optional, e.errors); e.currentQueryTotal = o.length; let a = null; o.forEach((n, i) => { e.currentQueryIndex = i; const o = e.createSubContext(t.options, n); s && o.delayNextStep(s), n === e.element && (a = o.currentTimeline), by(this, t.animation, o), o.currentTimeline.applyStylesToKeyframe(), r = Math.max(r, o.currentTimeline.currentTime) }), e.currentQueryIndex = 0, e.currentQueryTotal = 0, e.transformIntoNewTimeline(r), a && (e.currentTimeline.mergeTimelineCollectedStyles(a), e.currentTimeline.snapshotCurrentStyles()), e.previousNode = t } visitStagger(t, e) { const n = e.parentContext, i = e.currentTimeline, s = t.timings, r = Math.abs(s.duration), o = r * (e.currentQueryTotal - 1); let a = r * e.currentQueryIndex; switch (s.duration < 0 ? "reverse" : s.easing) { case "reverse": a = o - a; break; case "full": a = n.currentStaggerTime }const l = e.currentTimeline; a && l.delayNextStep(a); const c = l.currentTime; by(this, t.animation, e), e.previousNode = t, n.currentStaggerTime = i.currentTime - c + (i.startTime - n.currentTimeline.startTime) } } const jy = {}; class By { constructor(t, e, n, i, s, r, o, a) { this._driver = t, this.element = e, this.subInstructions = n, this._enterClassName = i, this._leaveClassName = s, this.errors = r, this.timelines = o, this.parentContext = null, this.currentAnimateTimings = null, this.previousNode = jy, this.subContextCount = 0, this.options = {}, this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, this.currentTimeline = a || new Hy(this._driver, e, 0), o.push(this.currentTimeline) } get params() { return this.options.params } updateOptions(t, e) { if (!t) return; const n = t; let i = this.options; null != n.duration && (i.duration = ey(n.duration)), null != n.delay && (i.delay = ey(n.delay)); const s = n.params; if (s) { let t = i.params; t || (t = this.options.params = {}), Object.keys(s).forEach(n => { e && t.hasOwnProperty(n) || (t[n] = py(s[n], t, this.errors)) }) } } _copyOptions() { const t = {}; if (this.options) { const e = this.options.params; if (e) { const n = t.params = {}; Object.keys(e).forEach(t => { n[t] = e[t] }) } } return t } createSubContext(t = null, e, n) { const i = e || this.element, s = new By(this._driver, i, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(i, n || 0)); return s.previousNode = this.previousNode, s.currentAnimateTimings = this.currentAnimateTimings, s.options = this._copyOptions(), s.updateOptions(t), s.currentQueryIndex = this.currentQueryIndex, s.currentQueryTotal = this.currentQueryTotal, s.parentContext = this, this.subContextCount++, s } transformIntoNewTimeline(t) { return this.previousNode = jy, this.currentTimeline = this.currentTimeline.fork(this.element, t), this.timelines.push(this.currentTimeline), this.currentTimeline } appendInstructionToTimeline(t, e, n) { const i = { duration: null != e ? e : t.duration, delay: this.currentTimeline.currentTime + (null != n ? n : 0) + t.delay, easing: "" }, s = new Uy(this._driver, t.element, t.keyframes, t.preStyleProps, t.postStyleProps, i, t.stretchStartingKeyframe); return this.timelines.push(s), i } incrementTime(t) { this.currentTimeline.forwardTime(this.currentTimeline.duration + t) } delayNextStep(t) { t > 0 && this.currentTimeline.delayNextStep(t) } invokeQuery(t, e, n, i, s, r) { let o = []; if (i && o.push(this.element), t.length > 0) { t = (t = t.replace(Ny, "." + this._enterClassName)).replace(Fy, "." + this._leaveClassName); let e = this._driver.query(this.element, t, 1 != n); 0 !== n && (e = n < 0 ? e.slice(e.length + n, e.length) : e.slice(0, n)), o.push(...e) } return s || 0 != o.length || r.push(`\`query("${e}")\` returned zero elements. (Use \`query("${e}", { optional: true })\` if you wish to allow this.)`), o } } class Hy { constructor(t, e, n, i) { this._driver = t, this.element = e, this.startTime = n, this._elementTimelineStylesLookup = i, this.duration = 0, this._previousKeyframe = {}, this._currentKeyframe = {}, this._keyframes = new Map, this._styleSummary = {}, this._pendingStyles = {}, this._backFill = {}, this._currentEmptyStepKeyframe = null, this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map), this._localTimelineStyles = Object.create(this._backFill, {}), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(e), this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, this._elementTimelineStylesLookup.set(e, this._localTimelineStyles)), this._loadKeyframe() } containsAnimation() { switch (this._keyframes.size) { case 0: return !1; case 1: return this.getCurrentStyleProperties().length > 0; default: return !0 } } getCurrentStyleProperties() { return Object.keys(this._currentKeyframe) } get currentTime() { return this.startTime + this.duration } delayNextStep(t) { const e = 1 == this._keyframes.size && Object.keys(this._pendingStyles).length; this.duration || e ? (this.forwardTime(this.currentTime + t), e && this.snapshotCurrentStyles()) : this.startTime += t } fork(t, e) { return this.applyStylesToKeyframe(), new Hy(this._driver, t, e || this.currentTime, this._elementTimelineStylesLookup) } _loadKeyframe() { this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), this._currentKeyframe || (this._currentKeyframe = Object.create(this._backFill, {}), this._keyframes.set(this.duration, this._currentKeyframe)) } forwardFrame() { this.duration += 1, this._loadKeyframe() } forwardTime(t) { this.applyStylesToKeyframe(), this.duration = t, this._loadKeyframe() } _updateStyle(t, e) { this._localTimelineStyles[t] = e, this._globalTimelineStyles[t] = e, this._styleSummary[t] = { time: this.currentTime, value: e } } allowOnlyTimelineStyles() { return this._currentEmptyStepKeyframe !== this._currentKeyframe } applyEmptyStep(t) { t && (this._previousKeyframe.easing = t), Object.keys(this._globalTimelineStyles).forEach(t => { this._backFill[t] = this._globalTimelineStyles[t] || m_, this._currentKeyframe[t] = m_ }), this._currentEmptyStepKeyframe = this._currentKeyframe } setStyles(t, e, n, i) { e && (this._previousKeyframe.easing = e); const s = i && i.params || {}, r = function (t, e) { const n = {}; let i; return t.forEach(t => { "*" === t ? (i = i || Object.keys(e), i.forEach(t => { n[t] = m_ })) : ry(t, !1, n) }), n }(t, this._globalTimelineStyles); Object.keys(r).forEach(t => { const e = py(r[t], s, n); this._pendingStyles[t] = e, this._localTimelineStyles.hasOwnProperty(t) || (this._backFill[t] = this._globalTimelineStyles.hasOwnProperty(t) ? this._globalTimelineStyles[t] : m_), this._updateStyle(t, e) }) } applyStylesToKeyframe() { const t = this._pendingStyles, e = Object.keys(t); 0 != e.length && (this._pendingStyles = {}, e.forEach(e => { this._currentKeyframe[e] = t[e] }), Object.keys(this._localTimelineStyles).forEach(t => { this._currentKeyframe.hasOwnProperty(t) || (this._currentKeyframe[t] = this._localTimelineStyles[t]) })) } snapshotCurrentStyles() { Object.keys(this._localTimelineStyles).forEach(t => { const e = this._localTimelineStyles[t]; this._pendingStyles[t] = e, this._updateStyle(t, e) }) } getFinalKeyframe() { return this._keyframes.get(this.duration) } get properties() { const t = []; for (let e in this._currentKeyframe) t.push(e); return t } mergeTimelineCollectedStyles(t) { Object.keys(t._styleSummary).forEach(e => { const n = this._styleSummary[e], i = t._styleSummary[e]; (!n || i.time > n.time) && this._updateStyle(e, i.value) }) } buildKeyframes() { this.applyStylesToKeyframe(); const t = new Set, e = new Set, n = 1 === this._keyframes.size && 0 === this.duration; let i = []; this._keyframes.forEach((s, r) => { const o = ry(s, !0); Object.keys(o).forEach(n => { const i = o[n]; "!" == i ? t.add(n) : i == m_ && e.add(n) }), n || (o.offset = r / this.duration), i.push(o) }); const s = t.size ? fy(t.values()) : [], r = e.size ? fy(e.values()) : []; if (n) { const t = i[0], e = sy(t); t.offset = 0, e.offset = 1, i = [t, e] } return Py(this.element, i, s, r, this.duration, this.startTime, this.easing, !1) } } class Uy extends Hy { constructor(t, e, n, i, s, r, o = !1) { super(t, e, r.delay), this.element = e, this.keyframes = n, this.preStyleProps = i, this.postStyleProps = s, this._stretchStartingKeyframe = o, this.timings = { duration: r.duration, delay: r.delay, easing: r.easing } } containsAnimation() { return this.keyframes.length > 1 } buildKeyframes() { let t = this.keyframes, { delay: e, duration: n, easing: i } = this.timings; if (this._stretchStartingKeyframe && e) { const s = [], r = n + e, o = e / r, a = ry(t[0], !1); a.offset = 0, s.push(a); const l = ry(t[0], !1); l.offset = zy(o), s.push(l); const c = t.length - 1; for (let i = 1; i <= c; i++) { let o = ry(t[i], !1); o.offset = zy((e + o.offset * n) / r), s.push(o) } n = r, e = 0, i = "", t = s } return Py(this.element, t, this.preStyleProps, this.postStyleProps, n, e, i, !0) } } function zy(t, e = 3) { const n = Math.pow(10, e - 1); return Math.round(t * n) / n } class $y { } class qy extends $y { normalizePropertyName(t, e) { return gy(t) } normalizeStyleValue(t, e, n, i) { let s = ""; const r = n.toString().trim(); if (Wy[e] && 0 !== n && "0" !== n) if ("number" == typeof n) s = "px"; else { const e = n.match(/^[+-]?[\d\.]+([a-z]*)$/); e && 0 == e[1].length && i.push(`Please provide a CSS unit value for ${t}:${n}`) } return r + s } } const Wy = (() => function (t) { const e = {}; return t.forEach(t => e[t] = !0), e }("width,height,minWidth,minHeight,maxWidth,maxHeight,left,top,bottom,right,fontSize,outlineWidth,outlineOffset,paddingTop,paddingLeft,paddingBottom,paddingRight,marginTop,marginLeft,marginBottom,marginRight,borderRadius,borderWidth,borderTopWidth,borderLeftWidth,borderRightWidth,borderBottomWidth,textIndent,perspective".split(",")))(); function Ky(t, e, n, i, s, r, o, a, l, c, h, u, d) { return { type: 0, element: t, triggerName: e, isRemovalTransition: s, fromState: n, fromStyles: r, toState: i, toStyles: o, timelines: a, queriedElements: l, preStyleProps: c, postStyleProps: h, totalTime: u, errors: d } } const Yy = {}; class Zy { constructor(t, e, n) { this._triggerName = t, this.ast = e, this._stateStyles = n } match(t, e, n, i) { return function (t, e, n, i, s) { return t.some(t => t(e, n, i, s)) }(this.ast.matchers, t, e, n, i) } buildStyles(t, e, n) { const i = this._stateStyles["*"], s = this._stateStyles[t], r = i ? i.buildStyles(e, n) : {}; return s ? s.buildStyles(e, n) : r } build(t, e, n, i, s, r, o, a, l, c) { const h = [], u = this.ast.options && this.ast.options.params || Yy, d = this.buildStyles(n, o && o.params || Yy, h), p = a && a.params || Yy, f = this.buildStyles(i, p, h), m = new Set, g = new Map, _ = new Map, y = "void" === i, b = { params: Object.assign(Object.assign({}, u), p) }, v = c ? [] : Ly(t, e, this.ast.animation, s, r, d, f, b, l, h); let w = 0; if (v.forEach(t => { w = Math.max(t.duration + t.delay, w) }), h.length) return Ky(e, this._triggerName, n, i, y, d, f, [], [], g, _, w, h); v.forEach(t => { const n = t.element, i = M_(g, n, {}); t.preStyleProps.forEach(t => i[t] = !0); const s = M_(_, n, {}); t.postStyleProps.forEach(t => s[t] = !0), n !== e && m.add(n) }); const C = fy(m.values()); return Ky(e, this._triggerName, n, i, y, d, f, v, C, g, _, w) } } class Gy { constructor(t, e) { this.styles = t, this.defaultParams = e } buildStyles(t, e) { const n = {}, i = sy(this.defaultParams); return Object.keys(t).forEach(e => { const n = t[e]; null != n && (i[e] = n) }), this.styles.styles.forEach(t => { if ("string" != typeof t) { const s = t; Object.keys(s).forEach(t => { let r = s[t]; r.length > 1 && (r = py(r, i, e)), n[t] = r }) } }), n } } class Qy { constructor(t, e) { this.name = t, this.ast = e, this.transitionFactories = [], this.states = {}, e.states.forEach(t => { this.states[t.name] = new Gy(t.style, t.options && t.options.params || {}) }), Xy(this.states, "true", "1"), Xy(this.states, "false", "0"), e.transitions.forEach(e => { this.transitionFactories.push(new Zy(t, e, this.states)) }), this.fallbackTransition = new Zy(t, { type: 1, animation: { type: 2, steps: [], options: null }, matchers: [(t, e) => !0], options: null, queryCount: 0, depCount: 0 }, this.states) } get containsQueries() { return this.ast.queryCount > 0 } matchTransition(t, e, n, i) { return this.transitionFactories.find(s => s.match(t, e, n, i)) || null } matchStyles(t, e, n) { return this.fallbackTransition.buildStyles(t, e, n) } } function Xy(t, e, n) { t.hasOwnProperty(e) ? t.hasOwnProperty(n) || (t[n] = t[e]) : t.hasOwnProperty(n) && (t[e] = t[n]) } const Jy = new My; class tb { constructor(t, e, n) { this.bodyNode = t, this._driver = e, this._normalizer = n, this._animations = {}, this._playersById = {}, this.players = [] } register(t, e) { const n = [], i = Ty(this._driver, e, n); if (n.length) throw new Error(`Unable to build the animation due to the following errors: ${n.join("\n")}`); this._animations[t] = i } _buildPlayer(t, e, n) { const i = t.element, s = O_(0, this._normalizer, 0, t.keyframes, e, n); return this._driver.animate(i, s, t.duration, t.delay, t.easing, [], !0) } create(t, e, n = {}) { const i = [], s = this._animations[t]; let r; const o = new Map; if (s ? (r = Ly(this._driver, e, s, Z_, G_, {}, {}, n, Jy, i), r.forEach(t => { const e = M_(o, t.element, {}); t.postStyleProps.forEach(t => e[t] = null) })) : (i.push("The requested animation doesn't exist or has already been destroyed"), r = []), i.length) throw new Error(`Unable to create the animation due to the following errors: ${i.join("\n")}`); o.forEach((t, e) => { Object.keys(t).forEach(n => { t[n] = this._driver.computeStyle(e, n, m_) }) }); const a = A_(r.map(t => { const e = o.get(t.element); return this._buildPlayer(t, {}, e) })); return this._playersById[t] = a, a.onDestroy(() => this.destroy(t)), this.players.push(a), a } destroy(t) { const e = this._getPlayer(t); e.destroy(), delete this._playersById[t]; const n = this.players.indexOf(e); n >= 0 && this.players.splice(n, 1) } _getPlayer(t) { const e = this._playersById[t]; if (!e) throw new Error(`Unable to find the timeline player referenced by ${t}`); return e } listen(t, e, n, i) { const s = P_(e, "", "", ""); return I_(this._getPlayer(t), n, s, i), () => { } } command(t, e, n, i) { if ("register" == n) return void this.register(t, i[0]); if ("create" == n) return void this.create(t, e, i[0] || {}); const s = this._getPlayer(t); switch (n) { case "play": s.play(); break; case "pause": s.pause(); break; case "reset": s.reset(); break; case "restart": s.restart(); break; case "finish": s.finish(); break; case "init": s.init(); break; case "setPosition": s.setPosition(parseFloat(i[0])); break; case "destroy": this.destroy(t) } } } const eb = "ng-animate-queued", nb = "ng-animate-disabled", ib = ".ng-animate-disabled", sb = [], rb = { namespaceId: "", setForRemoval: !1, setForMove: !1, hasAnimation: !1, removedBeforeQueried: !1 }, ob = { namespaceId: "", setForMove: !1, setForRemoval: !1, hasAnimation: !1, removedBeforeQueried: !0 }; class ab { constructor(t, e = "") { this.namespaceId = e; const n = t && t.hasOwnProperty("value"); if (this.value = null != (i = n ? t.value : t) ? i : null, n) { const e = sy(t); delete e.value, this.options = e } else this.options = {}; var i; this.options.params || (this.options.params = {}) } get params() { return this.options.params } absorbOptions(t) { const e = t.params; if (e) { const t = this.options.params; Object.keys(e).forEach(n => { null == t[n] && (t[n] = e[n]) }) } } } const lb = "void", cb = new ab(lb); class hb { constructor(t, e, n) { this.id = t, this.hostElement = e, this._engine = n, this.players = [], this._triggers = {}, this._queue = [], this._elementListeners = new Map, this._hostClassName = "ng-tns-" + t, _b(e, this._hostClassName) } listen(t, e, n, i) { if (!this._triggers.hasOwnProperty(e)) throw new Error(`Unable to listen on the animation trigger event "${n}" because the animation trigger "${e}" doesn't exist!`); if (null == n || 0 == n.length) throw new Error(`Unable to listen on the animation trigger "${e}" because the provided event is undefined!`); if ("start" != (s = n) && "done" != s) throw new Error(`The provided animation trigger event "${n}" for the animation trigger "${e}" is not supported!`); var s; const r = M_(this._elementListeners, t, []), o = { name: e, phase: n, callback: i }; r.push(o); const a = M_(this._engine.statesByElement, t, {}); return a.hasOwnProperty(e) || (_b(t, Q_), _b(t, "ng-trigger-" + e), a[e] = cb), () => { this._engine.afterFlush(() => { const t = r.indexOf(o); t >= 0 && r.splice(t, 1), this._triggers[e] || delete a[e] }) } } register(t, e) { return !this._triggers[t] && (this._triggers[t] = e, !0) } _getTrigger(t) { const e = this._triggers[t]; if (!e) throw new Error(`The provided animation trigger "${t}" has not been registered!`); return e } trigger(t, e, n, i = !0) { const s = this._getTrigger(e), r = new db(this.id, e, t); let o = this._engine.statesByElement.get(t); o || (_b(t, Q_), _b(t, "ng-trigger-" + e), this._engine.statesByElement.set(t, o = {})); let a = o[e]; const l = new ab(n, this.id); if (!(n && n.hasOwnProperty("value")) && a && l.absorbOptions(a.options), o[e] = l, a || (a = cb), l.value !== lb && a.value === l.value) { if (!function (t, e) { const n = Object.keys(t), i = Object.keys(e); if (n.length != i.length) return !1; for (let s = 0; s < n.length; s++) { const i = n[s]; if (!e.hasOwnProperty(i) || t[i] !== e[i]) return !1 } return !0 }(a.params, l.params)) { const e = [], n = s.matchStyles(a.value, a.params, e), i = s.matchStyles(l.value, l.params, e); e.length ? this._engine.reportError(e) : this._engine.afterFlush(() => { cy(t, n), ly(t, i) }) } return } const c = M_(this._engine.playersByElement, t, []); c.forEach(t => { t.namespaceId == this.id && t.triggerName == e && t.queued && t.destroy() }); let h = s.matchTransition(a.value, l.value, t, l.params), u = !1; if (!h) { if (!i) return; h = s.fallbackTransition, u = !0 } return this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: e, transition: h, fromState: a, toState: l, player: r, isFallbackTransition: u }), u || (_b(t, eb), r.onStart(() => { yb(t, eb) })), r.onDone(() => { let e = this.players.indexOf(r); e >= 0 && this.players.splice(e, 1); const n = this._engine.playersByElement.get(t); if (n) { let t = n.indexOf(r); t >= 0 && n.splice(t, 1) } }), this.players.push(r), c.push(r), r } deregister(t) { delete this._triggers[t], this._engine.statesByElement.forEach((e, n) => { delete e[t] }), this._elementListeners.forEach((e, n) => { this._elementListeners.set(n, e.filter(e => e.name != t)) }) } clearElementCache(t) { this._engine.statesByElement.delete(t), this._elementListeners.delete(t); const e = this._engine.playersByElement.get(t); e && (e.forEach(t => t.destroy()), this._engine.playersByElement.delete(t)) } _signalRemovalForInnerTriggers(t, e) { const n = this._engine.driver.query(t, X_, !0); n.forEach(t => { if (t.__ng_removed) return; const n = this._engine.fetchNamespacesByElement(t); n.size ? n.forEach(n => n.triggerLeaveAnimation(t, e, !1, !0)) : this.clearElementCache(t) }), this._engine.afterFlushAnimationsDone(() => n.forEach(t => this.clearElementCache(t))) } triggerLeaveAnimation(t, e, n, i) { const s = this._engine.statesByElement.get(t); if (s) { const r = []; if (Object.keys(s).forEach(e => { if (this._triggers[e]) { const n = this.trigger(t, e, lb, i); n && r.push(n) } }), r.length) return this._engine.markElementAsRemoved(this.id, t, !0, e), n && A_(r).onDone(() => this._engine.processLeaveNode(t)), !0 } return !1 } prepareLeaveAnimationListeners(t) { const e = this._elementListeners.get(t), n = this._engine.statesByElement.get(t); if (e && n) { const i = new Set; e.forEach(e => { const s = e.name; if (i.has(s)) return; i.add(s); const r = this._triggers[s].fallbackTransition, o = n[s] || cb, a = new ab(lb), l = new db(this.id, s, t); this._engine.totalQueuedPlayers++, this._queue.push({ element: t, triggerName: s, transition: r, fromState: o, toState: a, player: l, isFallbackTransition: !0 }) }) } } removeNode(t, e) { const n = this._engine; if (t.childElementCount && this._signalRemovalForInnerTriggers(t, e), this.triggerLeaveAnimation(t, e, !0)) return; let i = !1; if (n.totalAnimations) { const e = n.players.length ? n.playersByQueriedElement.get(t) : []; if (e && e.length) i = !0; else { let e = t; for (; e = e.parentNode;)if (n.statesByElement.get(e)) { i = !0; break } } } if (this.prepareLeaveAnimationListeners(t), i) n.markElementAsRemoved(this.id, t, !1, e); else { const i = t.__ng_removed; i && i !== rb || (n.afterFlush(() => this.clearElementCache(t)), n.destroyInnerAnimations(t), n._onRemovalComplete(t, e)) } } insertNode(t, e) { _b(t, this._hostClassName) } drainQueuedTransitions(t) { const e = []; return this._queue.forEach(n => { const i = n.player; if (i.destroyed) return; const s = n.element, r = this._elementListeners.get(s); r && r.forEach(e => { if (e.name == n.triggerName) { const i = P_(s, n.triggerName, n.fromState.value, n.toState.value); i._data = t, I_(n.player, e.phase, i, e.callback) } }), i.markedForDestroy ? this._engine.afterFlush(() => { i.destroy() }) : e.push(n) }), this._queue = [], e.sort((t, e) => { const n = t.transition.ast.depCount, i = e.transition.ast.depCount; return 0 == n || 0 == i ? n - i : this._engine.driver.containsElement(t.element, e.element) ? 1 : -1 }) } destroy(t) { this.players.forEach(t => t.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, t) } elementContainsData(t) { let e = !1; return this._elementListeners.has(t) && (e = !0), e = !!this._queue.find(e => e.element === t) || e, e } } class ub { constructor(t, e, n) { this.bodyNode = t, this.driver = e, this._normalizer = n, this.players = [], this.newHostElements = new Map, this.playersByElement = new Map, this.playersByQueriedElement = new Map, this.statesByElement = new Map, this.disabledNodes = new Set, this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map, this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = (t, e) => { } } _onRemovalComplete(t, e) { this.onRemovalComplete(t, e) } get queuedPlayers() { const t = []; return this._namespaceList.forEach(e => { e.players.forEach(e => { e.queued && t.push(e) }) }), t } createNamespace(t, e) { const n = new hb(t, e, this); return this.bodyNode && this.driver.containsElement(this.bodyNode, e) ? this._balanceNamespaceList(n, e) : (this.newHostElements.set(e, n), this.collectEnterElement(e)), this._namespaceLookup[t] = n } _balanceNamespaceList(t, e) { const n = this._namespaceList.length - 1; if (n >= 0) { let i = !1; for (let s = n; s >= 0; s--)if (this.driver.containsElement(this._namespaceList[s].hostElement, e)) { this._namespaceList.splice(s + 1, 0, t), i = !0; break } i || this._namespaceList.splice(0, 0, t) } else this._namespaceList.push(t); return this.namespacesByHostElement.set(e, t), t } register(t, e) { let n = this._namespaceLookup[t]; return n || (n = this.createNamespace(t, e)), n } registerTrigger(t, e, n) { let i = this._namespaceLookup[t]; i && i.register(e, n) && this.totalAnimations++ } destroy(t, e) { if (!t) return; const n = this._fetchNamespace(t); this.afterFlush(() => { this.namespacesByHostElement.delete(n.hostElement), delete this._namespaceLookup[t]; const e = this._namespaceList.indexOf(n); e >= 0 && this._namespaceList.splice(e, 1) }), this.afterFlushAnimationsDone(() => n.destroy(e)) } _fetchNamespace(t) { return this._namespaceLookup[t] } fetchNamespacesByElement(t) { const e = new Set, n = this.statesByElement.get(t); if (n) { const t = Object.keys(n); for (let i = 0; i < t.length; i++) { const s = n[t[i]].namespaceId; if (s) { const t = this._fetchNamespace(s); t && e.add(t) } } } return e } trigger(t, e, n, i) { if (pb(e)) { const s = this._fetchNamespace(t); if (s) return s.trigger(e, n, i), !0 } return !1 } insertNode(t, e, n, i) { if (!pb(e)) return; const s = e.__ng_removed; if (s && s.setForRemoval) { s.setForRemoval = !1, s.setForMove = !0; const t = this.collectedLeaveElements.indexOf(e); t >= 0 && this.collectedLeaveElements.splice(t, 1) } if (t) { const i = this._fetchNamespace(t); i && i.insertNode(e, n) } i && this.collectEnterElement(e) } collectEnterElement(t) { this.collectedEnterElements.push(t) } markElementAsDisabled(t, e) { e ? this.disabledNodes.has(t) || (this.disabledNodes.add(t), _b(t, nb)) : this.disabledNodes.has(t) && (this.disabledNodes.delete(t), yb(t, nb)) } removeNode(t, e, n, i) { if (pb(e)) { const s = t ? this._fetchNamespace(t) : null; if (s ? s.removeNode(e, i) : this.markElementAsRemoved(t, e, !1, i), n) { const n = this.namespacesByHostElement.get(e); n && n.id !== t && n.removeNode(e, i) } } else this._onRemovalComplete(e, i) } markElementAsRemoved(t, e, n, i) { this.collectedLeaveElements.push(e), e.__ng_removed = { namespaceId: t, setForRemoval: i, hasAnimation: n, removedBeforeQueried: !1 } } listen(t, e, n, i, s) { return pb(e) ? this._fetchNamespace(t).listen(e, n, i, s) : () => { } } _buildInstruction(t, e, n, i, s) { return t.transition.build(this.driver, t.element, t.fromState.value, t.toState.value, n, i, t.fromState.options, t.toState.options, e, s) } destroyInnerAnimations(t) { let e = this.driver.query(t, X_, !0); e.forEach(t => this.destroyActiveAnimationsForElement(t)), 0 != this.playersByQueriedElement.size && (e = this.driver.query(t, ty, !0), e.forEach(t => this.finishActiveQueriedAnimationOnElement(t))) } destroyActiveAnimationsForElement(t) { const e = this.playersByElement.get(t); e && e.forEach(t => { t.queued ? t.markedForDestroy = !0 : t.destroy() }) } finishActiveQueriedAnimationOnElement(t) { const e = this.playersByQueriedElement.get(t); e && e.forEach(t => t.finish()) } whenRenderingDone() { return new Promise(t => { if (this.players.length) return A_(this.players).onDone(() => t()); t() }) } processLeaveNode(t) { const e = t.__ng_removed; if (e && e.setForRemoval) { if (t.__ng_removed = rb, e.namespaceId) { this.destroyInnerAnimations(t); const n = this._fetchNamespace(e.namespaceId); n && n.clearElementCache(t) } this._onRemovalComplete(t, e.setForRemoval) } this.driver.matchesElement(t, ib) && this.markElementAsDisabled(t, !1), this.driver.query(t, ib, !0).forEach(t => { this.markElementAsDisabled(t, !1) }) } flush(t = -1) { let e = []; if (this.newHostElements.size && (this.newHostElements.forEach((t, e) => this._balanceNamespaceList(t, e)), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length) for (let n = 0; n < this.collectedEnterElements.length; n++)_b(this.collectedEnterElements[n], "ng-star-inserted"); if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) { const n = []; try { e = this._flushAnimations(n, t) } finally { for (let t = 0; t < n.length; t++)n[t]() } } else for (let n = 0; n < this.collectedLeaveElements.length; n++)this.processLeaveNode(this.collectedLeaveElements[n]); if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, this._flushFns.forEach(t => t()), this._flushFns = [], this._whenQuietFns.length) { const t = this._whenQuietFns; this._whenQuietFns = [], e.length ? A_(e).onDone(() => { t.forEach(t => t()) }) : t.forEach(t => t()) } } reportError(t) { throw new Error(`Unable to process animations due to the following failed trigger transitions\n ${t.join("\n")}`) } _flushAnimations(t, e) { const n = new My, i = [], s = new Map, r = [], o = new Map, a = new Map, l = new Map, c = new Set; this.disabledNodes.forEach(t => { c.add(t); const e = this.driver.query(t, ".ng-animate-queued", !0); for (let n = 0; n < e.length; n++)c.add(e[n]) }); const h = this.bodyNode, u = Array.from(this.statesByElement.keys()), d = gb(u, this.collectedEnterElements), p = new Map; let f = 0; d.forEach((t, e) => { const n = Z_ + f++; p.set(e, n), t.forEach(t => _b(t, n)) }); const m = [], g = new Set, _ = new Set; for (let O = 0; O < this.collectedLeaveElements.length; O++) { const t = this.collectedLeaveElements[O], e = t.__ng_removed; e && e.setForRemoval && (m.push(t), g.add(t), e.hasAnimation ? this.driver.query(t, ".ng-star-inserted", !0).forEach(t => g.add(t)) : _.add(t)) } const y = new Map, b = gb(u, Array.from(g)); b.forEach((t, e) => { const n = G_ + f++; y.set(e, n), t.forEach(t => _b(t, n)) }), t.push(() => { d.forEach((t, e) => { const n = p.get(e); t.forEach(t => yb(t, n)) }), b.forEach((t, e) => { const n = y.get(e); t.forEach(t => yb(t, n)) }), m.forEach(t => { this.processLeaveNode(t) }) }); const v = [], w = []; for (let O = this._namespaceList.length - 1; O >= 0; O--)this._namespaceList[O].drainQueuedTransitions(e).forEach(t => { const e = t.player, s = t.element; if (v.push(e), this.collectedEnterElements.length) { const t = s.__ng_removed; if (t && t.setForMove) return void e.destroy() } const c = !h || !this.driver.containsElement(h, s), u = y.get(s), d = p.get(s), f = this._buildInstruction(t, n, d, u, c); if (f.errors && f.errors.length) w.push(f); else { if (c) return e.onStart(() => cy(s, f.fromStyles)), e.onDestroy(() => ly(s, f.toStyles)), void i.push(e); if (t.isFallbackTransition) return e.onStart(() => cy(s, f.fromStyles)), e.onDestroy(() => ly(s, f.toStyles)), void i.push(e); f.timelines.forEach(t => t.stretchStartingKeyframe = !0), n.append(s, f.timelines), r.push({ instruction: f, player: e, element: s }), f.queriedElements.forEach(t => M_(o, t, []).push(e)), f.preStyleProps.forEach((t, e) => { const n = Object.keys(t); if (n.length) { let t = a.get(e); t || a.set(e, t = new Set), n.forEach(e => t.add(e)) } }), f.postStyleProps.forEach((t, e) => { const n = Object.keys(t); let i = l.get(e); i || l.set(e, i = new Set), n.forEach(t => i.add(t)) }) } }); if (w.length) { const t = []; w.forEach(e => { t.push(`@${e.triggerName} has failed due to:\n`), e.errors.forEach(e => t.push(`- ${e}\n`)) }), v.forEach(t => t.destroy()), this.reportError(t) } const C = new Map, k = new Map; r.forEach(t => { const e = t.element; n.has(e) && (k.set(e, e), this._beforeAnimationBuild(t.player.namespaceId, t.instruction, C)) }), i.forEach(t => { const e = t.element; this._getPreviousPlayers(e, !1, t.namespaceId, t.triggerName, null).forEach(t => { M_(C, e, []).push(t), t.destroy() }) }); const x = m.filter(t => wb(t, a, l)), S = new Map; mb(S, this.driver, _, l, m_).forEach(t => { wb(t, a, l) && x.push(t) }); const E = new Map; d.forEach((t, e) => { mb(E, this.driver, new Set(t), a, "!") }), x.forEach(t => { const e = S.get(t), n = E.get(t); S.set(t, Object.assign(Object.assign({}, e), n)) }); const T = [], R = [], A = {}; r.forEach(t => { const { element: e, player: r, instruction: o } = t; if (n.has(e)) { if (c.has(e)) return r.onDestroy(() => ly(e, o.toStyles)), r.disabled = !0, r.overrideTotalTime(o.totalTime), void i.push(r); let t = A; if (k.size > 1) { let n = e; const i = []; for (; n = n.parentNode;) { const e = k.get(n); if (e) { t = e; break } i.push(n) } i.forEach(e => k.set(e, t)) } const n = this._buildAnimation(r.namespaceId, o, C, s, E, S); if (r.setRealPlayer(n), t === A) T.push(r); else { const e = this.playersByElement.get(t); e && e.length && (r.parentPlayer = A_(e)), i.push(r) } } else cy(e, o.fromStyles), r.onDestroy(() => ly(e, o.toStyles)), R.push(r), c.has(e) && i.push(r) }), R.forEach(t => { const e = s.get(t.element); if (e && e.length) { const n = A_(e); t.setRealPlayer(n) } }), i.forEach(t => { t.parentPlayer ? t.syncPlayerEvents(t.parentPlayer) : t.destroy() }); for (let O = 0; O < m.length; O++) { const t = m[O], e = t.__ng_removed; if (yb(t, G_), e && e.hasAnimation) continue; let n = []; if (o.size) { let e = o.get(t); e && e.length && n.push(...e); let i = this.driver.query(t, ty, !0); for (let t = 0; t < i.length; t++) { let e = o.get(i[t]); e && e.length && n.push(...e) } } const i = n.filter(t => !t.destroyed); i.length ? bb(this, t, i) : this.processLeaveNode(t) } return m.length = 0, T.forEach(t => { this.players.push(t), t.onDone(() => { t.destroy(); const e = this.players.indexOf(t); this.players.splice(e, 1) }), t.play() }), T } elementContainsData(t, e) { let n = !1; const i = e.__ng_removed; return i && i.setForRemoval && (n = !0), this.playersByElement.has(e) && (n = !0), this.playersByQueriedElement.has(e) && (n = !0), this.statesByElement.has(e) && (n = !0), this._fetchNamespace(t).elementContainsData(e) || n } afterFlush(t) { this._flushFns.push(t) } afterFlushAnimationsDone(t) { this._whenQuietFns.push(t) } _getPreviousPlayers(t, e, n, i, s) { let r = []; if (e) { const e = this.playersByQueriedElement.get(t); e && (r = e) } else { const e = this.playersByElement.get(t); if (e) { const t = !s || s == lb; e.forEach(e => { e.queued || (t || e.triggerName == i) && r.push(e) }) } } return (n || i) && (r = r.filter(t => !(n && n != t.namespaceId || i && i != t.triggerName))), r } _beforeAnimationBuild(t, e, n) { const i = e.element, s = e.isRemovalTransition ? void 0 : t, r = e.isRemovalTransition ? void 0 : e.triggerName; for (const o of e.timelines) { const t = o.element, a = t !== i, l = M_(n, t, []); this._getPreviousPlayers(t, a, s, r, e.toState).forEach(t => { const e = t.getRealPlayer(); e.beforeDestroy && e.beforeDestroy(), t.destroy(), l.push(t) }) } cy(i, e.fromStyles) } _buildAnimation(t, e, n, i, s, r) { const o = e.triggerName, a = e.element, l = [], c = new Set, h = new Set, u = e.timelines.map(e => { const u = e.element; c.add(u); const d = u.__ng_removed; if (d && d.removedBeforeQueried) return new S_(e.duration, e.delay); const p = u !== a, f = function (t) { const e = []; return vb(t, e), e }((n.get(u) || sb).map(t => t.getRealPlayer())).filter(t => !!t.element && t.element === u), m = s.get(u), g = r.get(u), _ = O_(0, this._normalizer, 0, e.keyframes, m, g), y = this._buildPlayer(e, _, f); if (e.subTimeline && i && h.add(u), p) { const e = new db(t, o, u); e.setRealPlayer(y), l.push(e) } return y }); l.forEach(t => { M_(this.playersByQueriedElement, t.element, []).push(t), t.onDone(() => function (t, e, n) { let i; if (t instanceof Map) { if (i = t.get(e), i) { if (i.length) { const t = i.indexOf(n); i.splice(t, 1) } 0 == i.length && t.delete(e) } } else if (i = t[e], i) { if (i.length) { const t = i.indexOf(n); i.splice(t, 1) } 0 == i.length && delete t[e] } return i }(this.playersByQueriedElement, t.element, t)) }), c.forEach(t => _b(t, J_)); const d = A_(u); return d.onDestroy(() => { c.forEach(t => yb(t, J_)), ly(a, e.toStyles) }), h.forEach(t => { M_(i, t, []).push(d) }), d } _buildPlayer(t, e, n) { return e.length > 0 ? this.driver.animate(t.element, e, t.duration, t.delay, t.easing, n) : new S_(t.duration, t.delay) } } class db { constructor(t, e, n) { this.namespaceId = t, this.triggerName = e, this.element = n, this._player = new S_, this._containsRealPlayer = !1, this._queuedCallbacks = {}, this.destroyed = !1, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, this.totalTime = 0 } setRealPlayer(t) { this._containsRealPlayer || (this._player = t, Object.keys(this._queuedCallbacks).forEach(e => { this._queuedCallbacks[e].forEach(n => I_(t, e, void 0, n)) }), this._queuedCallbacks = {}, this._containsRealPlayer = !0, this.overrideTotalTime(t.totalTime), this.queued = !1) } getRealPlayer() { return this._player } overrideTotalTime(t) { this.totalTime = t } syncPlayerEvents(t) { const e = this._player; e.triggerCallback && t.onStart(() => e.triggerCallback("start")), t.onDone(() => this.finish()), t.onDestroy(() => this.destroy()) } _queueEvent(t, e) { M_(this._queuedCallbacks, t, []).push(e) } onDone(t) { this.queued && this._queueEvent("done", t), this._player.onDone(t) } onStart(t) { this.queued && this._queueEvent("start", t), this._player.onStart(t) } onDestroy(t) { this.queued && this._queueEvent("destroy", t), this._player.onDestroy(t) } init() { this._player.init() } hasStarted() { return !this.queued && this._player.hasStarted() } play() { !this.queued && this._player.play() } pause() { !this.queued && this._player.pause() } restart() { !this.queued && this._player.restart() } finish() { this._player.finish() } destroy() { this.destroyed = !0, this._player.destroy() } reset() { !this.queued && this._player.reset() } setPosition(t) { this.queued || this._player.setPosition(t) } getPosition() { return this.queued ? 0 : this._player.getPosition() } triggerCallback(t) { const e = this._player; e.triggerCallback && e.triggerCallback(t) } } function pb(t) { return t && 1 === t.nodeType } function fb(t, e) { const n = t.style.display; return t.style.display = null != e ? e : "none", n } function mb(t, e, n, i, s) { const r = []; n.forEach(t => r.push(fb(t))); const o = []; i.forEach((n, i) => { const r = {}; n.forEach(t => { const n = r[t] = e.computeStyle(i, t, s); n && 0 != n.length || (i.__ng_removed = ob, o.push(i)) }), t.set(i, r) }); let a = 0; return n.forEach(t => fb(t, r[a++])), o } function gb(t, e) { const n = new Map; if (t.forEach(t => n.set(t, [])), 0 == e.length) return n; const i = new Set(e), s = new Map; function r(t) { if (!t) return 1; let e = s.get(t); if (e) return e; const o = t.parentNode; return e = n.has(o) ? o : i.has(o) ? 1 : r(o), s.set(t, e), e } return e.forEach(t => { const e = r(t); 1 !== e && n.get(e).push(t) }), n } function _b(t, e) { if (t.classList) t.classList.add(e); else { let n = t.$$classes; n || (n = t.$$classes = {}), n[e] = !0 } } function yb(t, e) { if (t.classList) t.classList.remove(e); else { let n = t.$$classes; n && delete n[e] } } function bb(t, e, n) { A_(n).onDone(() => t.processLeaveNode(e)) } function vb(t, e) { for (let n = 0; n < t.length; n++) { const i = t[n]; i instanceof E_ ? vb(i.players, e) : e.push(i) } } function wb(t, e, n) { const i = n.get(t); if (!i) return !1; let s = e.get(t); return s ? i.forEach(t => s.add(t)) : e.set(t, i), n.delete(t), !0 } class Cb { constructor(t, e, n) { this.bodyNode = t, this._driver = e, this._triggerCache = {}, this.onRemovalComplete = (t, e) => { }, this._transitionEngine = new ub(t, e, n), this._timelineEngine = new tb(t, e, n), this._transitionEngine.onRemovalComplete = (t, e) => this.onRemovalComplete(t, e) } registerTrigger(t, e, n, i, s) { const r = t + "-" + i; let o = this._triggerCache[r]; if (!o) { const t = [], e = Ty(this._driver, s, t); if (t.length) throw new Error(`The animation trigger "${i}" has failed to build due to the following errors:\n - ${t.join("\n - ")}`); o = function (t, e) { return new Qy(t, e) }(i, e), this._triggerCache[r] = o } this._transitionEngine.registerTrigger(e, i, o) } register(t, e) { this._transitionEngine.register(t, e) } destroy(t, e) { this._transitionEngine.destroy(t, e) } onInsert(t, e, n, i) { this._transitionEngine.insertNode(t, e, n, i) } onRemove(t, e, n, i) { this._transitionEngine.removeNode(t, e, i || !1, n) } disableAnimations(t, e) { this._transitionEngine.markElementAsDisabled(t, e) } process(t, e, n, i) { if ("@" == n.charAt(0)) { const [t, s] = N_(n); this._timelineEngine.command(t, e, s, i) } else this._transitionEngine.trigger(t, e, n, i) } listen(t, e, n, i, s) { if ("@" == n.charAt(0)) { const [t, i] = N_(n); return this._timelineEngine.listen(t, e, i, s) } return this._transitionEngine.listen(t, e, n, i, s) } flush(t = -1) { this._transitionEngine.flush(t) } get players() { return this._transitionEngine.players.concat(this._timelineEngine.players) } whenRenderingDone() { return this._transitionEngine.whenRenderingDone() } } function kb(t, e) { let n = null, i = null; return Array.isArray(e) && e.length ? (n = Sb(e[0]), e.length > 1 && (i = Sb(e[e.length - 1]))) : e && (n = Sb(e)), n || i ? new xb(t, n, i) : null } let xb = (() => { class t { constructor(e, n, i) { this._element = e, this._startStyles = n, this._endStyles = i, this._state = 0; let s = t.initialStylesByElement.get(e); s || t.initialStylesByElement.set(e, s = {}), this._initialStyles = s } start() { this._state < 1 && (this._startStyles && ly(this._element, this._startStyles, this._initialStyles), this._state = 1) } finish() { this.start(), this._state < 2 && (ly(this._element, this._initialStyles), this._endStyles && (ly(this._element, this._endStyles), this._endStyles = null), this._state = 1) } destroy() { this.finish(), this._state < 3 && (t.initialStylesByElement.delete(this._element), this._startStyles && (cy(this._element, this._startStyles), this._endStyles = null), this._endStyles && (cy(this._element, this._endStyles), this._endStyles = null), ly(this._element, this._initialStyles), this._state = 3) } } return t.initialStylesByElement = new WeakMap, t })(); function Sb(t) { let e = null; const n = Object.keys(t); for (let i = 0; i < n.length; i++) { const s = n[i]; Eb(s) && (e = e || {}, e[s] = t[s]) } return e } function Eb(t) { return "display" === t || "position" === t } const Tb = "animation", Rb = "animationend"; class Ab { constructor(t, e, n, i, s, r, o) { this._element = t, this._name = e, this._duration = n, this._delay = i, this._easing = s, this._fillMode = r, this._onDoneFn = o, this._finished = !1, this._destroyed = !1, this._startTime = 0, this._position = 0, this._eventFn = t => this._handleCallback(t) } apply() { !function (t, e) { const n = Nb(t, "").trim(); n.length && (function (t, e) { let n = 0; for (let i = 0; i < t.length; i++)"," === t.charAt(i) && n++ }(n), e = `${n}, ${e}`), Mb(t, "", e) }(this._element, `${this._duration}ms ${this._easing} ${this._delay}ms 1 normal ${this._fillMode} ${this._name}`), Pb(this._element, this._eventFn, !1), this._startTime = Date.now() } pause() { Ob(this._element, this._name, "paused") } resume() { Ob(this._element, this._name, "running") } setPosition(t) { const e = Ib(this._element, this._name); this._position = t * this._duration, Mb(this._element, "Delay", `-${this._position}ms`, e) } getPosition() { return this._position } _handleCallback(t) { const e = t._ngTestManualTimestamp || Date.now(), n = 1e3 * parseFloat(t.elapsedTime.toFixed(3)); t.animationName == this._name && Math.max(e - this._startTime, 0) >= this._delay && n >= this._duration && this.finish() } finish() { this._finished || (this._finished = !0, this._onDoneFn(), Pb(this._element, this._eventFn, !0)) } destroy() { this._destroyed || (this._destroyed = !0, this.finish(), function (t, e) { const n = Nb(t, "").split(","), i = Db(n, e); i >= 0 && (n.splice(i, 1), Mb(t, "", n.join(","))) }(this._element, this._name)) } } function Ob(t, e, n) { Mb(t, "PlayState", n, Ib(t, e)) } function Ib(t, e) { const n = Nb(t, ""); return n.indexOf(",") > 0 ? Db(n.split(","), e) : Db([n], e) } function Db(t, e) { for (let n = 0; n < t.length; n++)if (t[n].indexOf(e) >= 0) return n; return -1 } function Pb(t, e, n) { n ? t.removeEventListener(Rb, e) : t.addEventListener(Rb, e) } function Mb(t, e, n, i) { const s = Tb + e; if (null != i) { const e = t.style[s]; if (e.length) { const t = e.split(","); t[i] = n, n = t.join(",") } } t.style[s] = n } function Nb(t, e) { return t.style[Tb + e] || "" } class Fb { constructor(t, e, n, i, s, r, o, a) { this.element = t, this.keyframes = e, this.animationName = n, this._duration = i, this._delay = s, this._finalStyles = o, this._specialStyles = a, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this.currentSnapshot = {}, this._state = 0, this.easing = r || "linear", this.totalTime = i + s, this._buildStyler() } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } destroy() { this.init(), this._state >= 4 || (this._state = 4, this._styler.destroy(), this._flushStartFns(), this._flushDoneFns(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } _flushDoneFns() { this._onDoneFns.forEach(t => t()), this._onDoneFns = [] } _flushStartFns() { this._onStartFns.forEach(t => t()), this._onStartFns = [] } finish() { this.init(), this._state >= 3 || (this._state = 3, this._styler.finish(), this._flushStartFns(), this._specialStyles && this._specialStyles.finish(), this._flushDoneFns()) } setPosition(t) { this._styler.setPosition(t) } getPosition() { return this._styler.getPosition() } hasStarted() { return this._state >= 2 } init() { this._state >= 1 || (this._state = 1, this._styler.apply(), this._delay && this._styler.pause()) } play() { this.init(), this.hasStarted() || (this._flushStartFns(), this._state = 2, this._specialStyles && this._specialStyles.start()), this._styler.resume() } pause() { this.init(), this._styler.pause() } restart() { this.reset(), this.play() } reset() { this._state = 0, this._styler.destroy(), this._buildStyler(), this._styler.apply() } _buildStyler() { this._styler = new Ab(this.element, this.animationName, this._duration, this._delay, this.easing, "forwards", () => this.finish()) } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } beforeDestroy() { this.init(); const t = {}; if (this.hasStarted()) { const e = this._state >= 3; Object.keys(this._finalStyles).forEach(n => { "offset" != n && (t[n] = e ? this._finalStyles[n] : vy(this.element, n)) }) } this.currentSnapshot = t } } class Lb extends S_ { constructor(t, e) { super(), this.element = t, this._startingStyles = {}, this.__initialized = !1, this._styles = W_(e) } init() { !this.__initialized && this._startingStyles && (this.__initialized = !0, Object.keys(this._styles).forEach(t => { this._startingStyles[t] = this.element.style[t] }), super.init()) } play() { this._startingStyles && (this.init(), Object.keys(this._styles).forEach(t => this.element.style.setProperty(t, this._styles[t])), super.play()) } destroy() { this._startingStyles && (Object.keys(this._startingStyles).forEach(t => { const e = this._startingStyles[t]; e ? this.element.style.setProperty(t, e) : this.element.style.removeProperty(t) }), this._startingStyles = null, super.destroy()) } } class Vb { constructor() { this._count = 0 } validateStyleProperty(t) { return U_(t) } matchesElement(t, e) { return z_(t, e) } containsElement(t, e) { return $_(t, e) } query(t, e, n) { return q_(t, e, n) } computeStyle(t, e, n) { return window.getComputedStyle(t)[e] } buildKeyframeElement(t, e, n) { n = n.map(t => W_(t)); let i = `@keyframes ${e} {\n`, s = ""; n.forEach(t => { s = " "; const e = parseFloat(t.offset); i += `${s}${100 * e}% {\n`, s += " ", Object.keys(t).forEach(e => { const n = t[e]; switch (e) { case "offset": return; case "easing": return void (n && (i += `${s}animation-timing-function: ${n};\n`)); default: return void (i += `${s}${e}: ${n};\n`) } }), i += `${s}}\n` }), i += "}\n"; const r = document.createElement("style"); return r.textContent = i, r } animate(t, e, n, i, s, r = [], o) { const a = r.filter(t => t instanceof Fb), l = {}; _y(n, i) && a.forEach(t => { let e = t.currentSnapshot; Object.keys(e).forEach(t => l[t] = e[t]) }); const c = function (t) { let e = {}; return t && (Array.isArray(t) ? t : [t]).forEach(t => { Object.keys(t).forEach(n => { "offset" != n && "easing" != n && (e[n] = t[n]) }) }), e }(e = yy(t, e, l)); if (0 == n) return new Lb(t, c); const h = "gen_css_kf_" + this._count++, u = this.buildKeyframeElement(t, h, e); (function (t) { var e; const n = null === (e = t.getRootNode) || void 0 === e ? void 0 : e.call(t); return "undefined" != typeof ShadowRoot && n instanceof ShadowRoot ? n : document.head })(t).appendChild(u); const d = kb(t, e), p = new Fb(t, e, h, n, i, s, c, d); return p.onDestroy(() => { var t; (t = u).parentNode.removeChild(t) }), p } } class jb { constructor(t, e, n, i) { this.element = t, this.keyframes = e, this.options = n, this._specialStyles = i, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, this._finished = !1, this._started = !1, this._destroyed = !1, this.time = 0, this.parentPlayer = null, this.currentSnapshot = {}, this._duration = n.duration, this._delay = n.delay || 0, this.time = this._duration + this._delay } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(t => t()), this._onDoneFns = []) } init() { this._buildPlayer(), this._preparePlayerBeforeStart() } _buildPlayer() { if (this._initialized) return; this._initialized = !0; const t = this.keyframes; this.domPlayer = this._triggerWebAnimation(this.element, t, this.options), this._finalKeyframe = t.length ? t[t.length - 1] : {}, this.domPlayer.addEventListener("finish", () => this._onFinish()) } _preparePlayerBeforeStart() { this._delay ? this._resetDomPlayerState() : this.domPlayer.pause() } _triggerWebAnimation(t, e, n) { return t.animate(e, n) } onStart(t) { this._onStartFns.push(t) } onDone(t) { this._onDoneFns.push(t) } onDestroy(t) { this._onDestroyFns.push(t) } play() { this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(t => t()), this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), this.domPlayer.play() } pause() { this.init(), this.domPlayer.pause() } finish() { this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), this.domPlayer.finish() } reset() { this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1 } _resetDomPlayerState() { this.domPlayer && this.domPlayer.cancel() } restart() { this.reset(), this.play() } hasStarted() { return this._started } destroy() { this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(t => t()), this._onDestroyFns = []) } setPosition(t) { void 0 === this.domPlayer && this.init(), this.domPlayer.currentTime = t * this.time } getPosition() { return this.domPlayer.currentTime / this.time } get totalTime() { return this._delay + this._duration } beforeDestroy() { const t = {}; this.hasStarted() && Object.keys(this._finalKeyframe).forEach(e => { "offset" != e && (t[e] = this._finished ? this._finalKeyframe[e] : vy(this.element, e)) }), this.currentSnapshot = t } triggerCallback(t) { const e = "start" == t ? this._onStartFns : this._onDoneFns; e.forEach(t => t()), e.length = 0 } } class Bb { constructor() { this._isNativeImpl = /\{\s*\[native\s+code\]\s*\}/.test(Hb().toString()), this._cssKeyframesDriver = new Vb } validateStyleProperty(t) { return U_(t) } matchesElement(t, e) { return z_(t, e) } containsElement(t, e) { return $_(t, e) } query(t, e, n) { return q_(t, e, n) } computeStyle(t, e, n) { return window.getComputedStyle(t)[e] } overrideWebAnimationsSupport(t) { this._isNativeImpl = t } animate(t, e, n, i, s, r = [], o) { if (!o && !this._isNativeImpl) return this._cssKeyframesDriver.animate(t, e, n, i, s, r); const a = { duration: n, delay: i, fill: 0 == i ? "both" : "forwards" }; s && (a.easing = s); const l = {}, c = r.filter(t => t instanceof jb); _y(n, i) && c.forEach(t => { let e = t.currentSnapshot; Object.keys(e).forEach(t => l[t] = e[t]) }); const h = kb(t, e = yy(t, e = e.map(t => ry(t, !1)), l)); return new jb(t, e, a, h) } } function Hb() { return T_() && Element.prototype.animate || {} } let Ub = (() => { class t extends f_ { constructor(t, e) { super(), this._nextAnimationId = 0, this._renderer = t.createRenderer(e.body, { id: "0", encapsulation: Tt.None, styles: [], data: { animation: [] } }) } build(t) { const e = this._nextAnimationId.toString(); this._nextAnimationId++; const n = Array.isArray(t) ? y_(t) : t; return qb(this._renderer, null, e, "register", [n]), new zb(e, this._renderer) } } return t.\u0275fac = function (e) { return new (e || t)(li(Fa), li(Jc)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); class zb extends class { }{ constructor(t, e) { super(), this._id = t, this._renderer = e } create(t, e) { return new $b(this._id, t, e || {}, this._renderer) } } class $b { constructor(t, e, n, i) { this.id = t, this.element = e, this._renderer = i, this.parentPlayer = null, this._started = !1, this.totalTime = 0, this._command("create", n) } _listen(t, e) { return this._renderer.listen(this.element, `@@${this.id}:${t}`, e) } _command(t, ...e) { return qb(this._renderer, this.element, this.id, t, e) } onDone(t) { this._listen("done", t) } onStart(t) { this._listen("start", t) } onDestroy(t) { this._listen("destroy", t) } init() { this._command("init") } hasStarted() { return this._started } play() { this._command("play"), this._started = !0 } pause() { this._command("pause") } restart() { this._command("restart") } finish() { this._command("finish") } destroy() { this._command("destroy") } reset() { this._command("reset"), this._started = !1 } setPosition(t) { this._command("setPosition", t) } getPosition() { var t, e; return null !== (e = null === (t = this._renderer.engine.players[+this.id]) || void 0 === t ? void 0 : t.getPosition()) && void 0 !== e ? e : 0 } } function qb(t, e, n, i, s) { return t.setProperty(e, `@@${n}:${i}`, s) } const Wb = "@", Kb = "@.disabled"; let Yb = (() => { class t { constructor(t, e, n) { this.delegate = t, this.engine = e, this._zone = n, this._currentId = 0, this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map, this._cdRecurDepth = 0, this.promise = Promise.resolve(0), e.onRemovalComplete = (t, e) => { e && e.parentNode(t) && e.removeChild(t.parentNode, t) } } createRenderer(t, e) { const n = this.delegate.createRenderer(t, e); if (!(t && e && e.data && e.data.animation)) { let t = this._rendererCache.get(n); return t || (t = new Zb("", n, this.engine), this._rendererCache.set(n, t)), t } const i = e.id, s = e.id + "-" + this._currentId; this._currentId++, this.engine.register(s, t); const r = e => { Array.isArray(e) ? e.forEach(r) : this.engine.registerTrigger(i, s, t, e.name, e) }; return e.data.animation.forEach(r), new Gb(this, s, n, this.engine) } begin() { this._cdRecurDepth++, this.delegate.begin && this.delegate.begin() } _scheduleCountTask() { this.promise.then(() => { this._microtaskId++ }) } scheduleListenerCallback(t, e, n) { t >= 0 && t < this._microtaskId ? this._zone.run(() => e(n)) : (0 == this._animationCallbacksBuffer.length && Promise.resolve(null).then(() => { this._zone.run(() => { this._animationCallbacksBuffer.forEach(t => { const [e, n] = t; e(n) }), this._animationCallbacksBuffer = [] }) }), this._animationCallbacksBuffer.push([e, n])) } end() { this._cdRecurDepth--, 0 == this._cdRecurDepth && this._zone.runOutsideAngular(() => { this._scheduleCountTask(), this.engine.flush(this._microtaskId) }), this.delegate.end && this.delegate.end() } whenRenderingDone() { return this.engine.whenRenderingDone() } } return t.\u0275fac = function (e) { return new (e || t)(li(Fa), li(Cb), li(vc)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); class Zb { constructor(t, e, n) { this.namespaceId = t, this.delegate = e, this.engine = n, this.destroyNode = this.delegate.destroyNode ? t => e.destroyNode(t) : null } get data() { return this.delegate.data } destroy() { this.engine.destroy(this.namespaceId, this.delegate), this.delegate.destroy() } createElement(t, e) { return this.delegate.createElement(t, e) } createComment(t) { return this.delegate.createComment(t) } createText(t) { return this.delegate.createText(t) } appendChild(t, e) { this.delegate.appendChild(t, e), this.engine.onInsert(this.namespaceId, e, t, !1) } insertBefore(t, e, n, i = !0) { this.delegate.insertBefore(t, e, n), this.engine.onInsert(this.namespaceId, e, t, i) } removeChild(t, e, n) { this.engine.onRemove(this.namespaceId, e, this.delegate, n) } selectRootElement(t, e) { return this.delegate.selectRootElement(t, e) } parentNode(t) { return this.delegate.parentNode(t) } nextSibling(t) { return this.delegate.nextSibling(t) } setAttribute(t, e, n, i) { this.delegate.setAttribute(t, e, n, i) } removeAttribute(t, e, n) { this.delegate.removeAttribute(t, e, n) } addClass(t, e) { this.delegate.addClass(t, e) } removeClass(t, e) { this.delegate.removeClass(t, e) } setStyle(t, e, n, i) { this.delegate.setStyle(t, e, n, i) } removeStyle(t, e, n) { this.delegate.removeStyle(t, e, n) } setProperty(t, e, n) { e.charAt(0) == Wb && e == Kb ? this.disableAnimations(t, !!n) : this.delegate.setProperty(t, e, n) } setValue(t, e) { this.delegate.setValue(t, e) } listen(t, e, n) { return this.delegate.listen(t, e, n) } disableAnimations(t, e) { this.engine.disableAnimations(t, e) } } class Gb extends Zb { constructor(t, e, n, i) { super(e, n, i), this.factory = t, this.namespaceId = e } setProperty(t, e, n) { e.charAt(0) == Wb ? "." == e.charAt(1) && e == Kb ? this.disableAnimations(t, n = void 0 === n || !!n) : this.engine.process(this.namespaceId, t, e.substr(1), n) : this.delegate.setProperty(t, e, n) } listen(t, e, n) { if (e.charAt(0) == Wb) { const i = function (t) { switch (t) { case "body": return document.body; case "document": return document; case "window": return window; default: return t } }(t); let s = e.substr(1), r = ""; return s.charAt(0) != Wb && ([s, r] = function (t) { const e = t.indexOf("."); return [t.substring(0, e), t.substr(e + 1)] }(s)), this.engine.listen(this.namespaceId, i, s, r, t => { this.factory.scheduleListenerCallback(t._data || -1, n, t) }) } return this.delegate.listen(t, e, n) } } let Qb = (() => { class t extends Cb { constructor(t, e, n) { super(t.body, e, n) } ngOnDestroy() { this.flush() } } return t.\u0275fac = function (e) { return new (e || t)(li(Jc), li(Y_), li($y)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const Xb = new $n("AnimationModuleType"), Jb = [{ provide: f_, useClass: Ub }, { provide: $y, useFactory: function () { return new qy } }, { provide: Cb, useClass: Qb }, { provide: Fa, useFactory: function (t, e, n) { return new Yb(t, e, n) }, deps: [Qh, Cb, vc] }], tv = [{ provide: Y_, useFactory: function () { return "function" == typeof Hb() ? new Bb : new Vb } }, { provide: Xb, useValue: "BrowserAnimations" }, ...Jb], ev = [{ provide: Y_, useClass: K_ }, { provide: Xb, useValue: "NoopAnimations" }, ...Jb]; let nv = (() => { class t { static withConfig(e) { return { ngModule: t, providers: e.disableAnimations ? ev : tv } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ providers: tv, imports: [du] }), t })(); function iv(t, e) { if (1 & t && xo(0, "mat-pseudo-checkbox", 4), 2 & t) { const t = Fo(); vo("state", t.selected ? "checked" : "unchecked")("disabled", t.disabled) } } function sv(t, e) { if (1 & t && (Co(0, "span", 5), ra(1), ko()), 2 & t) { const t = Fo(); qs(1), aa("(", t.group.label, ")") } } const rv = ["*"], ov = new Ba("12.0.4"), av = new $n("mat-sanity-checks", { providedIn: "root", factory: function () { return !0 } }); let lv = (() => { class t { constructor(t, e, n) { this._hasDoneGlobalChecks = !1, this._document = n, t._applyBodyHighContrastModeCssClasses(), this._sanityChecks = e, this._hasDoneGlobalChecks || (this._checkDoctypeIsDefined(), this._checkThemeIsPresent(), this._checkCdkVersionMatch(), this._hasDoneGlobalChecks = !0) } _getWindow() { const t = this._document.defaultView || window; return "object" == typeof t && t ? t : null } _checksAreEnabled() { return Mc() && !this._isTestEnv() } _isTestEnv() { const t = this._getWindow(); return t && (t.__karma__ || t.jasmine) } _checkDoctypeIsDefined() { this._checksAreEnabled() && (!0 === this._sanityChecks || this._sanityChecks.doctype) && !this._document.doctype && console.warn("Current document does not have a doctype. This may cause some Angular Material components not to behave as expected.") } _checkThemeIsPresent() { if (!this._checksAreEnabled() || !1 === this._sanityChecks || !this._sanityChecks.theme || !this._document.body || "function" != typeof getComputedStyle) return; const t = this._document.createElement("div"); t.classList.add("mat-theme-loaded-marker"), this._document.body.appendChild(t); const e = getComputedStyle(t); e && "none" !== e.display && console.warn("Could not find Angular Material core theme. Most Material components may not work as expected. For more info refer to the theming guide: https://material.angular.io/guide/theming"), this._document.body.removeChild(t) } _checkCdkVersionMatch() { this._checksAreEnabled() && (!0 === this._sanityChecks || this._sanityChecks.version) && ov.full !== p_.full && console.warn("The Angular Material version (" + ov.full + ") does not match the Angular CDK version (" + p_.full + ").\nPlease ensure the versions of these two packages exactly match.") } } return t.\u0275fac = function (e) { return new (e || t)(li(u_), li(av, 8), li(Jc)) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ imports: [[wm], wm] }), t })(); function cv(t) { return class extends t { constructor(...t) { super(...t), this._disabled = !1 } get disabled() { return this._disabled } set disabled(t) { this._disabled = lm(t) } } } function hv(t, e) { return class extends t { constructor(...t) { super(...t), this.defaultColor = e, this.color = e } get color() { return this._color } set color(t) { const e = t || this.defaultColor; e !== this._color && (this._color && this._elementRef.nativeElement.classList.remove(`mat-${this._color}`), e && this._elementRef.nativeElement.classList.add(`mat-${e}`), this._color = e) } } } function uv(t) { return class extends t { constructor(...t) { super(...t), this._disableRipple = !1 } get disableRipple() { return this._disableRipple } set disableRipple(t) { this._disableRipple = lm(t) } } } function dv(t, e = 0) { return class extends t { constructor(...t) { super(...t), this._tabIndex = e, this.defaultTabIndex = e } get tabIndex() { return this.disabled ? -1 : this._tabIndex } set tabIndex(t) { this._tabIndex = null != t ? cm(t) : this.defaultTabIndex } } } function pv(t) { return class extends t { constructor(...t) { super(...t), this.errorState = !1, this.stateChanges = new k } updateErrorState() { const t = this.errorState, e = (this.errorStateMatcher || this._defaultErrorStateMatcher).isErrorState(this.ngControl ? this.ngControl.control : null, this._parentFormGroup || this._parentForm); e !== t && (this.errorState = e, this.stateChanges.next()) } } } const fv = new $n("MAT_DATE_LOCALE", { providedIn: "root", factory: function () { return ci(lc) } }); class mv { constructor() { this._localeChanges = new k, this.localeChanges = this._localeChanges } getValidDateOrNull(t) { return this.isDateInstance(t) && this.isValid(t) ? t : null } deserialize(t) { return null == t || this.isDateInstance(t) && this.isValid(t) ? t : this.invalid() } setLocale(t) { this.locale = t, this._localeChanges.next() } compareDate(t, e) { return this.getYear(t) - this.getYear(e) || this.getMonth(t) - this.getMonth(e) || this.getDate(t) - this.getDate(e) } sameDate(t, e) { if (t && e) { let n = this.isValid(t), i = this.isValid(e); return n && i ? !this.compareDate(t, e) : n == i } return t == e } clampDate(t, e, n) { return e && this.compareDate(t, e) < 0 ? e : n && this.compareDate(t, n) > 0 ? n : t } } const gv = new $n("mat-date-formats"); let _v; try { _v = "undefined" != typeof Intl } catch (DA) { _v = !1 } const yv = { long: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], short: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"] }, bv = Cv(31, t => String(t + 1)), vv = { long: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], short: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], narrow: ["S", "M", "T", "W", "T", "F", "S"] }, wv = /^\d{4}-\d{2}-\d{2}(?:T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|(?:(?:\+|-)\d{2}:\d{2}))?)?$/; function Cv(t, e) { const n = Array(t); for (let i = 0; i < t; i++)n[i] = e(i); return n } let kv = (() => { class t extends mv { constructor(t, e) { super(), this.useUtcForDisplay = !0, super.setLocale(t), this.useUtcForDisplay = !e.TRIDENT, this._clampDate = e.TRIDENT || e.EDGE } getYear(t) { return t.getFullYear() } getMonth(t) { return t.getMonth() } getDate(t) { return t.getDate() } getDayOfWeek(t) { return t.getDay() } getMonthNames(t) { if (_v) { const e = new Intl.DateTimeFormat(this.locale, { month: t, timeZone: "utc" }); return Cv(12, t => this._stripDirectionalityCharacters(this._format(e, new Date(2017, t, 1)))) } return yv[t] } getDateNames() { if (_v) { const t = new Intl.DateTimeFormat(this.locale, { day: "numeric", timeZone: "utc" }); return Cv(31, e => this._stripDirectionalityCharacters(this._format(t, new Date(2017, 0, e + 1)))) } return bv } getDayOfWeekNames(t) { if (_v) { const e = new Intl.DateTimeFormat(this.locale, { weekday: t, timeZone: "utc" }); return Cv(7, t => this._stripDirectionalityCharacters(this._format(e, new Date(2017, 0, t + 1)))) } return vv[t] } getYearName(t) { if (_v) { const e = new Intl.DateTimeFormat(this.locale, { year: "numeric", timeZone: "utc" }); return this._stripDirectionalityCharacters(this._format(e, t)) } return String(this.getYear(t)) } getFirstDayOfWeek() { return 0 } getNumDaysInMonth(t) { return this.getDate(this._createDateWithOverflow(this.getYear(t), this.getMonth(t) + 1, 0)) } clone(t) { return new Date(t.getTime()) } createDate(t, e, n) { let i = this._createDateWithOverflow(t, e, n); return i.getMonth(), i } today() { return new Date } parse(t) { return "number" == typeof t ? new Date(t) : t ? new Date(Date.parse(t)) : null } format(t, e) { if (!this.isValid(t)) throw Error("NativeDateAdapter: Cannot format invalid date."); if (_v) { this._clampDate && (t.getFullYear() < 1 || t.getFullYear() > 9999) && (t = this.clone(t)).setFullYear(Math.max(1, Math.min(9999, t.getFullYear()))), e = Object.assign(Object.assign({}, e), { timeZone: "utc" }); const n = new Intl.DateTimeFormat(this.locale, e); return this._stripDirectionalityCharacters(this._format(n, t)) } return this._stripDirectionalityCharacters(t.toDateString()) } addCalendarYears(t, e) { return this.addCalendarMonths(t, 12 * e) } addCalendarMonths(t, e) { let n = this._createDateWithOverflow(this.getYear(t), this.getMonth(t) + e, this.getDate(t)); return this.getMonth(n) != ((this.getMonth(t) + e) % 12 + 12) % 12 && (n = this._createDateWithOverflow(this.getYear(n), this.getMonth(n), 0)), n } addCalendarDays(t, e) { return this._createDateWithOverflow(this.getYear(t), this.getMonth(t), this.getDate(t) + e) } toIso8601(t) { return [t.getUTCFullYear(), this._2digit(t.getUTCMonth() + 1), this._2digit(t.getUTCDate())].join("-") } deserialize(t) { if ("string" == typeof t) { if (!t) return null; if (wv.test(t)) { let e = new Date(t); if (this.isValid(e)) return e } } return super.deserialize(t) } isDateInstance(t) { return t instanceof Date } isValid(t) { return !isNaN(t.getTime()) } invalid() { return new Date(NaN) } _createDateWithOverflow(t, e, n) { const i = new Date; return i.setFullYear(t, e, n), i.setHours(0, 0, 0, 0), i } _2digit(t) { return ("00" + t).slice(-2) } _stripDirectionalityCharacters(t) { return t.replace(/[\u200e\u200f]/g, "") } _format(t, e) { const n = new Date; return n.setUTCFullYear(e.getFullYear(), e.getMonth(), e.getDate()), n.setUTCHours(e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()), t.format(n) } } return t.\u0275fac = function (e) { return new (e || t)(li(fv, 8), li(km)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), xv = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ providers: [{ provide: mv, useClass: kv }], imports: [[xm]] }), t })(); const Sv = { parse: { dateInput: null }, display: { dateInput: { year: "numeric", month: "numeric", day: "numeric" }, monthYearLabel: { year: "numeric", month: "short" }, dateA11yLabel: { year: "numeric", month: "long", day: "numeric" }, monthYearA11yLabel: { year: "numeric", month: "long" } } }; let Ev = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ providers: [{ provide: gv, useValue: Sv }], imports: [[xv]] }), t })(), Tv = (() => { class t { isErrorState(t, e) { return !!(t && t.invalid && (t.touched || e && e.submitted)) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ factory: function () { return new t }, token: t, providedIn: "root" }), t })(); class Rv { constructor(t, e, n) { this._renderer = t, this.element = e, this.config = n, this.state = 3 } fadeOut() { this._renderer.fadeOutRipple(this) } } const Av = { enterDuration: 450, exitDuration: 400 }, Ov = Om({ passive: !0 }), Iv = ["mousedown", "touchstart"], Dv = ["mouseup", "mouseleave", "touchend", "touchcancel"]; class Pv { constructor(t, e, n, i) { this._target = t, this._ngZone = e, this._isPointerDown = !1, this._activeRipples = new Set, this._pointerUpEventsRegistered = !1, i.isBrowser && (this._containerElement = pm(n)) } fadeInRipple(t, e, n = {}) { const i = this._containerRect = this._containerRect || this._containerElement.getBoundingClientRect(), s = Object.assign(Object.assign({}, Av), n.animation); n.centered && (t = i.left + i.width / 2, e = i.top + i.height / 2); const r = n.radius || function (t, e, n) { const i = Math.max(Math.abs(t - n.left), Math.abs(t - n.right)), s = Math.max(Math.abs(e - n.top), Math.abs(e - n.bottom)); return Math.sqrt(i * i + s * s) }(t, e, i), o = t - i.left, a = e - i.top, l = s.enterDuration, c = document.createElement("div"); c.classList.add("mat-ripple-element"), c.style.left = o - r + "px", c.style.top = a - r + "px", c.style.height = 2 * r + "px", c.style.width = 2 * r + "px", null != n.color && (c.style.backgroundColor = n.color), c.style.transitionDuration = `${l}ms`, this._containerElement.appendChild(c), window.getComputedStyle(c).getPropertyValue("opacity"), c.style.transform = "scale(1)"; const h = new Rv(this, c, n); return h.state = 0, this._activeRipples.add(h), n.persistent || (this._mostRecentTransientRipple = h), this._runTimeoutOutsideZone(() => { const t = h === this._mostRecentTransientRipple; h.state = 1, n.persistent || t && this._isPointerDown || h.fadeOut() }, l), h } fadeOutRipple(t) { const e = this._activeRipples.delete(t); if (t === this._mostRecentTransientRipple && (this._mostRecentTransientRipple = null), this._activeRipples.size || (this._containerRect = null), !e) return; const n = t.element, i = Object.assign(Object.assign({}, Av), t.config.animation); n.style.transitionDuration = `${i.exitDuration}ms`, n.style.opacity = "0", t.state = 2, this._runTimeoutOutsideZone(() => { t.state = 3, n.parentNode.removeChild(n) }, i.exitDuration) } fadeOutAll() { this._activeRipples.forEach(t => t.fadeOut()) } fadeOutAllNonPersistent() { this._activeRipples.forEach(t => { t.config.persistent || t.fadeOut() }) } setupTriggerEvents(t) { const e = pm(t); e && e !== this._triggerElement && (this._removeTriggerEvents(), this._triggerElement = e, this._registerEvents(Iv)) } handleEvent(t) { "mousedown" === t.type ? this._onMousedown(t) : "touchstart" === t.type ? this._onTouchStart(t) : this._onPointerUp(), this._pointerUpEventsRegistered || (this._registerEvents(Dv), this._pointerUpEventsRegistered = !0) } _onMousedown(t) { const e = n_(t), n = this._lastTouchStartEvent && Date.now() < this._lastTouchStartEvent + 800; this._target.rippleDisabled || e || n || (this._isPointerDown = !0, this.fadeInRipple(t.clientX, t.clientY, this._target.rippleConfig)) } _onTouchStart(t) { if (!this._target.rippleDisabled && !i_(t)) { this._lastTouchStartEvent = Date.now(), this._isPointerDown = !0; const e = t.changedTouches; for (let t = 0; t < e.length; t++)this.fadeInRipple(e[t].clientX, e[t].clientY, this._target.rippleConfig) } } _onPointerUp() { this._isPointerDown && (this._isPointerDown = !1, this._activeRipples.forEach(t => { !t.config.persistent && (1 === t.state || t.config.terminateOnPointerUp && 0 === t.state) && t.fadeOut() })) } _runTimeoutOutsideZone(t, e = 0) { this._ngZone.runOutsideAngular(() => setTimeout(t, e)) } _registerEvents(t) { this._ngZone.runOutsideAngular(() => { t.forEach(t => { this._triggerElement.addEventListener(t, this, Ov) }) }) } _removeTriggerEvents() { this._triggerElement && (Iv.forEach(t => { this._triggerElement.removeEventListener(t, this, Ov) }), this._pointerUpEventsRegistered && Dv.forEach(t => { this._triggerElement.removeEventListener(t, this, Ov) })) } } const Mv = new $n("mat-ripple-global-options"); let Nv = (() => { class t { constructor(t, e, n, i, s) { this._elementRef = t, this._animationMode = s, this.radius = 0, this._disabled = !1, this._isInitialized = !1, this._globalOptions = i || {}, this._rippleRenderer = new Pv(this, e, t, n) } get disabled() { return this._disabled } set disabled(t) { t && this.fadeOutAllNonPersistent(), this._disabled = t, this._setupTriggerEventsIfEnabled() } get trigger() { return this._trigger || this._elementRef.nativeElement } set trigger(t) { this._trigger = t, this._setupTriggerEventsIfEnabled() } ngOnInit() { this._isInitialized = !0, this._setupTriggerEventsIfEnabled() } ngOnDestroy() { this._rippleRenderer._removeTriggerEvents() } fadeOutAll() { this._rippleRenderer.fadeOutAll() } fadeOutAllNonPersistent() { this._rippleRenderer.fadeOutAllNonPersistent() } get rippleConfig() { return { centered: this.centered, radius: this.radius, color: this.color, animation: Object.assign(Object.assign(Object.assign({}, this._globalOptions.animation), "NoopAnimations" === this._animationMode ? { enterDuration: 0, exitDuration: 0 } : {}), this.animation), terminateOnPointerUp: this._globalOptions.terminateOnPointerUp } } get rippleDisabled() { return this.disabled || !!this._globalOptions.disabled } _setupTriggerEventsIfEnabled() { !this.disabled && this._isInitialized && this._rippleRenderer.setupTriggerEvents(this.trigger) } launch(t, e = 0, n) { return "number" == typeof t ? this._rippleRenderer.fadeInRipple(t, e, Object.assign(Object.assign({}, this.rippleConfig), n)) : this._rippleRenderer.fadeInRipple(0, 0, Object.assign(Object.assign({}, this.rippleConfig), t)) } } return t.\u0275fac = function (e) { return new (e || t)(bo(Ma), bo(vc), bo(km), bo(Mv, 8), bo(Xb, 8)) }, t.\u0275dir = Zt({ type: t, selectors: [["", "mat-ripple", ""], ["", "matRipple", ""]], hostAttrs: [1, "mat-ripple"], hostVars: 2, hostBindings: function (t, e) { 2 & t && Ko("mat-ripple-unbounded", e.unbounded) }, inputs: { radius: ["matRippleRadius", "radius"], disabled: ["matRippleDisabled", "disabled"], trigger: ["matRippleTrigger", "trigger"], color: ["matRippleColor", "color"], unbounded: ["matRippleUnbounded", "unbounded"], centered: ["matRippleCentered", "centered"], animation: ["matRippleAnimation", "animation"] }, exportAs: ["matRipple"] }), t })(), Fv = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ imports: [[lv, xm], lv] }), t })(), Lv = (() => { class t { constructor(t) { this._animationMode = t, this.state = "unchecked", this.disabled = !1 } } return t.\u0275fac = function (e) { return new (e || t)(bo(Xb, 8)) }, t.\u0275cmp = zt({ type: t, selectors: [["mat-pseudo-checkbox"]], hostAttrs: [1, "mat-pseudo-checkbox"], hostVars: 8, hostBindings: function (t, e) { 2 & t && Ko("mat-pseudo-checkbox-indeterminate", "indeterminate" === e.state)("mat-pseudo-checkbox-checked", "checked" === e.state)("mat-pseudo-checkbox-disabled", e.disabled)("_mat-animation-noopable", "NoopAnimations" === e._animationMode) }, inputs: { state: "state", disabled: "disabled" }, decls: 0, vars: 0, template: function (t, e) { }, styles: ['.mat-pseudo-checkbox{width:16px;height:16px;border:2px solid;border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;flex-shrink:0;transition:border-color 90ms cubic-bezier(0, 0, 0.2, 0.1),background-color 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:"";border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox.mat-pseudo-checkbox-indeterminate{border-color:transparent}._mat-animation-noopable.mat-pseudo-checkbox{transition:none;animation:none}._mat-animation-noopable.mat-pseudo-checkbox::after{transition:none}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{top:5px;left:1px;width:10px;opacity:1;border-radius:2px}.mat-pseudo-checkbox-checked::after{top:2.4px;left:1px;width:8px;height:3px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1;box-sizing:content-box}\n'], encapsulation: 2, changeDetection: 0 }), t })(), Vv = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ imports: [[lv]] }), t })(); const jv = new $n("MAT_OPTION_PARENT_COMPONENT"); class Bv { } const Hv = cv(Bv); let Uv = 0, zv = (() => { class t extends Hv { constructor(t) { var e; super(), this._labelId = "mat-optgroup-label-" + Uv++, this._inert = null !== (e = null == t ? void 0 : t.inertGroups) && void 0 !== e && e } } return t.\u0275fac = function (e) { return new (e || t)(bo(jv, 8)) }, t.\u0275dir = Zt({ type: t, inputs: { label: "label" }, features: [so] }), t })(); const $v = new $n("MatOptgroup"); let qv = 0; class Wv { constructor(t, e = !1) { this.source = t, this.isUserInput = e } } let Kv = (() => { class t { constructor(t, e, n, i) { this._element = t, this._changeDetectorRef = e, this._parent = n, this.group = i, this._selected = !1, this._active = !1, this._disabled = !1, this._mostRecentViewValue = "", this.id = "mat-option-" + qv++, this.onSelectionChange = new Ml, this._stateChanges = new k } get multiple() { return this._parent && this._parent.multiple } get selected() { return this._selected } get disabled() { return this.group && this.group.disabled || this._disabled } set disabled(t) { this._disabled = lm(t) } get disableRipple() { return this._parent && this._parent.disableRipple } get active() { return this._active } get viewValue() { return (this._getHostElement().textContent || "").trim() } select() { this._selected || (this._selected = !0, this._changeDetectorRef.markForCheck(), this._emitSelectionChangeEvent()) } deselect() { this._selected && (this._selected = !1, this._changeDetectorRef.markForCheck(), this._emitSelectionChangeEvent()) } focus(t, e) { const n = this._getHostElement(); "function" == typeof n.focus && n.focus(e) } setActiveStyles() { this._active || (this._active = !0, this._changeDetectorRef.markForCheck()) } setInactiveStyles() { this._active && (this._active = !1, this._changeDetectorRef.markForCheck()) } getLabel() { return this.viewValue } _handleKeydown(t) { 13 !== t.keyCode && 32 !== t.keyCode || Vg(t) || (this._selectViaInteraction(), t.preventDefault()) } _selectViaInteraction() { this.disabled || (this._selected = !this.multiple || !this._selected, this._changeDetectorRef.markForCheck(), this._emitSelectionChangeEvent(!0)) } _getAriaSelected() { return this.selected || !this.multiple && null } _getTabIndex() { return this.disabled ? "-1" : "0" } _getHostElement() { return this._element.nativeElement } ngAfterViewChecked() { if (this._selected) { const t = this.viewValue; t !== this._mostRecentViewValue && (this._mostRecentViewValue = t, this._stateChanges.next()) } } ngOnDestroy() { this._stateChanges.complete() } _emitSelectionChangeEvent(t = !1) { this.onSelectionChange.emit(new Wv(this, t)) } } return t.\u0275fac = function (e) { return new (e || t)(bo(Ma), bo(ol), bo(void 0), bo(zv)) }, t.\u0275dir = Zt({ type: t, inputs: { id: "id", disabled: "disabled", value: "value" }, outputs: { onSelectionChange: "onSelectionChange" } }), t })(), Yv = (() => { class t extends Kv { constructor(t, e, n, i) { super(t, e, n, i) } } return t.\u0275fac = function (e) { return new (e || t)(bo(Ma), bo(ol), bo(jv, 8), bo($v, 8)) }, t.\u0275cmp = zt({ type: t, selectors: [["mat-option"]], hostAttrs: ["role", "option", 1, "mat-option", "mat-focus-indicator"], hostVars: 12, hostBindings: function (t, e) { 1 & t && Io("click", function () { return e._selectViaInteraction() })("keydown", function (t) { return e._handleKeydown(t) }), 2 & t && (ha("id", e.id), mo("tabindex", e._getTabIndex())("aria-selected", e._getAriaSelected())("aria-disabled", e.disabled.toString()), Ko("mat-selected", e.selected)("mat-option-multiple", e.multiple)("mat-active", e.active)("mat-option-disabled", e.disabled)) }, exportAs: ["matOption"], features: [so], ngContentSelectors: rv, decls: 5, vars: 4, consts: [["class", "mat-option-pseudo-checkbox", 3, "state", "disabled", 4, "ngIf"], [1, "mat-option-text"], ["class", "cdk-visually-hidden", 4, "ngIf"], ["mat-ripple", "", 1, "mat-option-ripple", 3, "matRippleTrigger", "matRippleDisabled"], [1, "mat-option-pseudo-checkbox", 3, "state", "disabled"], [1, "cdk-visually-hidden"]], template: function (t, e) { 1 & t && (Vo(), _o(0, iv, 1, 2, "mat-pseudo-checkbox", 0), Co(1, "span", 1), jo(2), ko(), _o(3, sv, 2, 1, "span", 2), xo(4, "div", 3)), 2 & t && (vo("ngIf", e.multiple), qs(3), vo("ngIf", e.group && e.group._inert), qs(1), vo("matRippleTrigger", e._getHostElement())("matRippleDisabled", e.disabled || e.disableRipple)) }, directives: [Ch, Nv, Lv], styles: [".mat-option{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative;cursor:pointer;outline:none;display:flex;flex-direction:row;max-width:100%;box-sizing:border-box;align-items:center;-webkit-tap-highlight-color:transparent}.mat-option[disabled]{cursor:default}[dir=rtl] .mat-option{text-align:right}.mat-option .mat-icon{margin-right:16px;vertical-align:middle}.mat-option .mat-icon svg{vertical-align:top}[dir=rtl] .mat-option .mat-icon{margin-left:16px;margin-right:0}.mat-option[aria-disabled=true]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-optgroup .mat-option:not(.mat-option-multiple){padding-left:32px}[dir=rtl] .mat-optgroup .mat-option:not(.mat-option-multiple){padding-left:16px;padding-right:32px}.cdk-high-contrast-active .mat-option{margin:0 1px}.cdk-high-contrast-active .mat-option.mat-active{border:solid 1px currentColor;margin:0}.cdk-high-contrast-active .mat-option[aria-disabled=true]{opacity:.5}.mat-option-text{display:inline-block;flex-grow:1;overflow:hidden;text-overflow:ellipsis}.mat-option .mat-option-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-option-pseudo-checkbox{margin-right:8px}[dir=rtl] .mat-option-pseudo-checkbox{margin-left:8px;margin-right:0}\n"], encapsulation: 2, changeDetection: 0 }), t })(); function Zv(t, e, n) { if (n.length) { let i = e.toArray(), s = n.toArray(), r = 0; for (let e = 0; e < t + 1; e++)i[e].group && i[e].group === s[r] && r++; return r } return 0 } let Gv = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ imports: [[Fv, Ah, lv, Vv]] }), t })(); const Qv = [[["caption"]], [["colgroup"], ["col"]]], Xv = ["caption", "colgroup, col"]; let Jv = (() => { class t extends Ng { constructor() { super(...arguments), this.stickyCssClass = "mat-table-sticky", this.needsPositionStickyOnElement = !1 } } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = jn(t)))(n || t) } }(), t.\u0275cmp = zt({ type: t, selectors: [["mat-table"], ["table", "mat-table", ""]], hostAttrs: [1, "mat-table"], hostVars: 2, hostBindings: function (t, e) { 2 & t && Ko("mat-table-fixed-layout", e.fixedLayout) }, exportAs: ["matTable"], features: [Ta([{ provide: _m, useClass: mm }, { provide: Ng, useExisting: t }, { provide: ig, useExisting: t }, { provide: fg, useClass: mg }, { provide: Og, useValue: null }]), so], ngContentSelectors: Xv, decls: 6, vars: 0, consts: [["headerRowOutlet", ""], ["rowOutlet", ""], ["noDataRowOutlet", ""], ["footerRowOutlet", ""]], template: function (t, e) { 1 & t && (Vo(Qv), jo(0), jo(1, 1), To(2, 0), To(3, 1), To(4, 2), To(5, 3)) }, directives: [Dg, Ig, Mg, Pg], styles: ['mat-table{display:block}mat-header-row{min-height:56px}mat-row,mat-footer-row{min-height:48px}mat-row,mat-header-row,mat-footer-row{display:flex;border-width:0;border-bottom-width:1px;border-style:solid;align-items:center;box-sizing:border-box}mat-row::after,mat-header-row::after,mat-footer-row::after{display:inline-block;min-height:inherit;content:""}mat-cell:first-of-type,mat-header-cell:first-of-type,mat-footer-cell:first-of-type{padding-left:24px}[dir=rtl] mat-cell:first-of-type:not(:only-of-type),[dir=rtl] mat-header-cell:first-of-type:not(:only-of-type),[dir=rtl] mat-footer-cell:first-of-type:not(:only-of-type){padding-left:0;padding-right:24px}mat-cell:last-of-type,mat-header-cell:last-of-type,mat-footer-cell:last-of-type{padding-right:24px}[dir=rtl] mat-cell:last-of-type:not(:only-of-type),[dir=rtl] mat-header-cell:last-of-type:not(:only-of-type),[dir=rtl] mat-footer-cell:last-of-type:not(:only-of-type){padding-right:0;padding-left:24px}mat-cell,mat-header-cell,mat-footer-cell{flex:1;display:flex;align-items:center;overflow:hidden;word-wrap:break-word;min-height:inherit}table.mat-table{border-spacing:0}tr.mat-header-row{height:56px}tr.mat-row,tr.mat-footer-row{height:48px}th.mat-header-cell{text-align:left}[dir=rtl] th.mat-header-cell{text-align:right}th.mat-header-cell,td.mat-cell,td.mat-footer-cell{padding:0;border-bottom-width:1px;border-bottom-style:solid}th.mat-header-cell:first-of-type,td.mat-cell:first-of-type,td.mat-footer-cell:first-of-type{padding-left:24px}[dir=rtl] th.mat-header-cell:first-of-type:not(:only-of-type),[dir=rtl] td.mat-cell:first-of-type:not(:only-of-type),[dir=rtl] td.mat-footer-cell:first-of-type:not(:only-of-type){padding-left:0;padding-right:24px}th.mat-header-cell:last-of-type,td.mat-cell:last-of-type,td.mat-footer-cell:last-of-type{padding-right:24px}[dir=rtl] th.mat-header-cell:last-of-type:not(:only-of-type),[dir=rtl] td.mat-cell:last-of-type:not(:only-of-type),[dir=rtl] td.mat-footer-cell:last-of-type:not(:only-of-type){padding-right:0;padding-left:24px}.mat-table-sticky{position:-webkit-sticky !important;position:sticky !important}.mat-table-fixed-layout{table-layout:fixed}\n'], encapsulation: 2 }), t })(), tw = (() => { class t extends sg { } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = jn(t)))(n || t) } }(), t.\u0275dir = Zt({ type: t, selectors: [["", "matCellDef", ""]], features: [Ta([{ provide: sg, useExisting: t }]), so] }), t })(), ew = (() => { class t extends rg { } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = jn(t)))(n || t) } }(), t.\u0275dir = Zt({ type: t, selectors: [["", "matHeaderCellDef", ""]], features: [Ta([{ provide: rg, useExisting: t }]), so] }), t })(), nw = (() => { class t extends cg { get name() { return this._name } set name(t) { this._setNameInput(t) } _updateColumnCssClassName() { super._updateColumnCssClassName(), this._columnCssClassName.push(`mat-column-${this.cssClassFriendlyName}`) } } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = jn(t)))(n || t) } }(), t.\u0275dir = Zt({ type: t, selectors: [["", "matColumnDef", ""]], inputs: { sticky: "sticky", name: ["matColumnDef", "name"] }, features: [Ta([{ provide: cg, useExisting: t }, { provide: "MAT_SORT_HEADER_COLUMN_DEF", useExisting: t }]), so] }), t })(), iw = (() => { class t extends ug { } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = jn(t)))(n || t) } }(), t.\u0275dir = Zt({ type: t, selectors: [["mat-header-cell"], ["th", "mat-header-cell", ""]], hostAttrs: ["role", "columnheader", 1, "mat-header-cell"], features: [so] }), t })(), sw = (() => { class t extends dg { } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = jn(t)))(n || t) } }(), t.\u0275dir = Zt({ type: t, selectors: [["mat-cell"], ["td", "mat-cell", ""]], hostAttrs: ["role", "gridcell", 1, "mat-cell"], features: [so] }), t })(), rw = (() => { class t extends bg { } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = jn(t)))(n || t) } }(), t.\u0275dir = Zt({ type: t, selectors: [["", "matHeaderRowDef", ""]], inputs: { columns: ["matHeaderRowDef", "columns"], sticky: ["matHeaderRowDefSticky", "sticky"] }, features: [Ta([{ provide: bg, useExisting: t }]), so] }), t })(), ow = (() => { class t extends kg { } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = jn(t)))(n || t) } }(), t.\u0275dir = Zt({ type: t, selectors: [["", "matRowDef", ""]], inputs: { columns: ["matRowDefColumns", "columns"], when: ["matRowDefWhen", "when"] }, features: [Ta([{ provide: kg, useExisting: t }]), so] }), t })(), aw = (() => { class t extends Sg { } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = jn(t)))(n || t) } }(), t.\u0275cmp = zt({ type: t, selectors: [["mat-header-row"], ["tr", "mat-header-row", ""]], hostAttrs: ["role", "row", 1, "mat-header-row"], exportAs: ["matHeaderRow"], features: [Ta([{ provide: Sg, useExisting: t }]), so], decls: 1, vars: 0, consts: [["cdkCellOutlet", ""]], template: function (t, e) { 1 & t && To(0, 0) }, directives: [xg], encapsulation: 2 }), t })(), lw = (() => { class t extends Eg { } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = jn(t)))(n || t) } }(), t.\u0275cmp = zt({ type: t, selectors: [["mat-row"], ["tr", "mat-row", ""]], hostAttrs: ["role", "row", 1, "mat-row"], exportAs: ["matRow"], features: [Ta([{ provide: Eg, useExisting: t }]), so], decls: 1, vars: 0, consts: [["cdkCellOutlet", ""]], template: function (t, e) { 1 & t && To(0, 0) }, directives: [xg], encapsulation: 2 }), t })(), cw = (() => { class t extends Tg { } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = jn(t)))(n || t) } }(), t.\u0275dir = Zt({ type: t, selectors: [["ng-template", "matNoDataRow", ""]], features: [Ta([{ provide: Tg, useExisting: t }]), so] }), t })(), hw = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ imports: [[Lg, lv], lv] }), t })(); class uw extends class extends class { }{ constructor(t = []) { super(), this._renderData = new fu([]), this._filter = new fu(""), this._internalPageChanges = new k, this._renderChangesSubscription = null, this.sortingDataAccessor = (t, e) => { const n = t[e]; if (hm(n)) { const t = Number(n); return t < 9007199254740991 ? t : n } return n }, this.sortData = (t, e) => { const n = e.active, i = e.direction; return n && "" != i ? t.sort((t, e) => { let s = this.sortingDataAccessor(t, n), r = this.sortingDataAccessor(e, n); const o = typeof s, a = typeof r; o !== a && ("number" === o && (s += ""), "number" === a && (r += "")); let l = 0; return null != s && null != r ? s > r ? l = 1 : s < r && (l = -1) : null != s ? l = 1 : null != r && (l = -1), l * ("asc" == i ? 1 : -1) }) : t }, this.filterPredicate = (t, e) => { const n = Object.keys(t).reduce((e, n) => e + t[n] + "\u25ec", "").toLowerCase(), i = e.trim().toLowerCase(); return -1 != n.indexOf(i) }, this._data = new fu(t), this._updateChangeSubscription() } get data() { return this._data.value } set data(t) { this._data.next(t), this._renderChangesSubscription || this._filterData(t) } get filter() { return this._filter.value } set filter(t) { this._filter.next(t), this._renderChangesSubscription || this._filterData(this.data) } get sort() { return this._sort } set sort(t) { this._sort = t, this._updateChangeSubscription() } get paginator() { return this._paginator } set paginator(t) { this._paginator = t, this._updateChangeSubscription() } _updateChangeSubscription() { var t; const e = this._sort ? q(this._sort.sortChange, this._sort.initialized) : pu(null), n = this._paginator ? q(this._paginator.page, this._internalPageChanges, this._paginator.initialized) : pu(null), i = bu([this._data, this._filter]).pipe(E(([t]) => this._filterData(t))), s = bu([i, e]).pipe(E(([t]) => this._orderData(t))), r = bu([s, n]).pipe(E(([t]) => this._pageData(t))); null === (t = this._renderChangesSubscription) || void 0 === t || t.unsubscribe(), this._renderChangesSubscription = r.subscribe(t => this._renderData.next(t)) } _filterData(t) { return this.filteredData = null == this.filter || "" === this.filter ? t : t.filter(t => this.filterPredicate(t, this.filter)), this.paginator && this._updatePaginator(this.filteredData.length), this.filteredData } _orderData(t) { return this.sort ? this.sortData(t.slice(), this.sort) : t } _pageData(t) { if (!this.paginator) return t; const e = this.paginator.pageIndex * this.paginator.pageSize; return t.slice(e, e + this.paginator.pageSize) } _updatePaginator(t) { Promise.resolve().then(() => { const e = this.paginator; if (e && (e.length = t, e.pageIndex > 0)) { const t = Math.ceil(e.length / e.pageSize) - 1 || 0, n = Math.min(e.pageIndex, t); n !== e.pageIndex && (e.pageIndex = n, this._internalPageChanges.next()) } }) } connect() { return this._renderChangesSubscription || this._updateChangeSubscription(), this._renderData } disconnect() { var t; null === (t = this._renderChangesSubscription) || void 0 === t || t.unsubscribe(), this._renderChangesSubscription = null } }{ } const dw = "https://encoding.onrender.com/api"; class pw { } class fw { } class mw { constructor(t) { this.normalizedNames = new Map, this.lazyUpdate = null, t ? this.lazyInit = "string" == typeof t ? () => { this.headers = new Map, t.split("\n").forEach(t => { const e = t.indexOf(":"); if (e > 0) { const n = t.slice(0, e), i = n.toLowerCase(), s = t.slice(e + 1).trim(); this.maybeSetNormalizedName(n, i), this.headers.has(i) ? this.headers.get(i).push(s) : this.headers.set(i, [s]) } }) } : () => { this.headers = new Map, Object.keys(t).forEach(e => { let n = t[e]; const i = e.toLowerCase(); "string" == typeof n && (n = [n]), n.length > 0 && (this.headers.set(i, n), this.maybeSetNormalizedName(e, i)) }) } : this.headers = new Map } has(t) { return this.init(), this.headers.has(t.toLowerCase()) } get(t) { this.init(); const e = this.headers.get(t.toLowerCase()); return e && e.length > 0 ? e[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(t) { return this.init(), this.headers.get(t.toLowerCase()) || null } append(t, e) { return this.clone({ name: t, value: e, op: "a" }) } set(t, e) { return this.clone({ name: t, value: e, op: "s" }) } delete(t, e) { return this.clone({ name: t, value: e, op: "d" }) } maybeSetNormalizedName(t, e) { this.normalizedNames.has(e) || this.normalizedNames.set(e, t) } init() { this.lazyInit && (this.lazyInit instanceof mw ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(t => this.applyUpdate(t)), this.lazyUpdate = null)) } copyFrom(t) { t.init(), Array.from(t.headers.keys()).forEach(e => { this.headers.set(e, t.headers.get(e)), this.normalizedNames.set(e, t.normalizedNames.get(e)) }) } clone(t) { const e = new mw; return e.lazyInit = this.lazyInit && this.lazyInit instanceof mw ? this.lazyInit : this, e.lazyUpdate = (this.lazyUpdate || []).concat([t]), e } applyUpdate(t) { const e = t.name.toLowerCase(); switch (t.op) { case "a": case "s": let n = t.value; if ("string" == typeof n && (n = [n]), 0 === n.length) return; this.maybeSetNormalizedName(t.name, e); const i = ("a" === t.op ? this.headers.get(e) : void 0) || []; i.push(...n), this.headers.set(e, i); break; case "d": const s = t.value; if (s) { let t = this.headers.get(e); if (!t) return; t = t.filter(t => -1 === s.indexOf(t)), 0 === t.length ? (this.headers.delete(e), this.normalizedNames.delete(e)) : this.headers.set(e, t) } else this.headers.delete(e), this.normalizedNames.delete(e) } } forEach(t) { this.init(), Array.from(this.normalizedNames.keys()).forEach(e => t(this.normalizedNames.get(e), this.headers.get(e))) } } class gw { encodeKey(t) { return _w(t) } encodeValue(t) { return _w(t) } decodeKey(t) { return decodeURIComponent(t) } decodeValue(t) { return decodeURIComponent(t) } } function _w(t) { return encodeURIComponent(t).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/gi, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%2B/gi, "+").replace(/%3D/gi, "=").replace(/%3F/gi, "?").replace(/%2F/gi, "/") } function yw(t) { return `${t}` } class bw { constructor(t = {}) { if (this.updates = null, this.cloneFrom = null, this.encoder = t.encoder || new gw, t.fromString) { if (t.fromObject) throw new Error("Cannot specify both fromString and fromObject."); this.map = function (t, e) { const n = new Map; return t.length > 0 && t.replace(/^\?/, "").split("&").forEach(t => { const i = t.indexOf("="), [s, r] = -1 == i ? [e.decodeKey(t), ""] : [e.decodeKey(t.slice(0, i)), e.decodeValue(t.slice(i + 1))], o = n.get(s) || []; o.push(r), n.set(s, o) }), n }(t.fromString, this.encoder) } else t.fromObject ? (this.map = new Map, Object.keys(t.fromObject).forEach(e => { const n = t.fromObject[e]; this.map.set(e, Array.isArray(n) ? n : [n]) })) : this.map = null } has(t) { return this.init(), this.map.has(t) } get(t) { this.init(); const e = this.map.get(t); return e ? e[0] : null } getAll(t) { return this.init(), this.map.get(t) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(t, e) { return this.clone({ param: t, value: e, op: "a" }) } appendAll(t) { const e = []; return Object.keys(t).forEach(n => { const i = t[n]; Array.isArray(i) ? i.forEach(t => { e.push({ param: n, value: t, op: "a" }) }) : e.push({ param: n, value: i, op: "a" }) }), this.clone(e) } set(t, e) { return this.clone({ param: t, value: e, op: "s" }) } delete(t, e) { return this.clone({ param: t, value: e, op: "d" }) } toString() { return this.init(), this.keys().map(t => { const e = this.encoder.encodeKey(t); return this.map.get(t).map(t => e + "=" + this.encoder.encodeValue(t)).join("&") }).filter(t => "" !== t).join("&") } clone(t) { const e = new bw({ encoder: this.encoder }); return e.cloneFrom = this.cloneFrom || this, e.updates = (this.updates || []).concat(t), e } init() { null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(t => this.map.set(t, this.cloneFrom.map.get(t))), this.updates.forEach(t => { switch (t.op) { case "a": case "s": const e = ("a" === t.op ? this.map.get(t.param) : void 0) || []; e.push(yw(t.value)), this.map.set(t.param, e); break; case "d": if (void 0 === t.value) { this.map.delete(t.param); break } { let e = this.map.get(t.param) || []; const n = e.indexOf(yw(t.value)); -1 !== n && e.splice(n, 1), e.length > 0 ? this.map.set(t.param, e) : this.map.delete(t.param) } } }), this.cloneFrom = this.updates = null) } } class vw { constructor() { this.map = new Map } set(t, e) { return this.map.set(t, e), this } get(t) { return this.map.has(t) || this.map.set(t, t.defaultValue()), this.map.get(t) } delete(t) { return this.map.delete(t), this } keys() { return this.map.keys() } } function ww(t) { return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer } function Cw(t) { return "undefined" != typeof Blob && t instanceof Blob } function kw(t) { return "undefined" != typeof FormData && t instanceof FormData } class xw { constructor(t, e, n, i) { let s; if (this.url = e, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = t.toUpperCase(), function (t) { switch (t) { case "DELETE": case "GET": case "HEAD": case "OPTIONS": case "JSONP": return !1; default: return !0 } }(this.method) || i ? (this.body = void 0 !== n ? n : null, s = i) : s = n, s && (this.reportProgress = !!s.reportProgress, this.withCredentials = !!s.withCredentials, s.responseType && (this.responseType = s.responseType), s.headers && (this.headers = s.headers), s.context && (this.context = s.context), s.params && (this.params = s.params)), this.headers || (this.headers = new mw), this.context || (this.context = new vw), this.params) { const t = this.params.toString(); if (0 === t.length) this.urlWithParams = e; else { const n = e.indexOf("?"); this.urlWithParams = e + (-1 === n ? "?" : n < e.length - 1 ? "&" : "") + t } } else this.params = new bw, this.urlWithParams = e } serializeBody() { return null === this.body ? null : ww(this.body) || Cw(this.body) || kw(this.body) || "string" == typeof this.body ? this.body : this.body instanceof bw ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return null === this.body || kw(this.body) ? null : Cw(this.body) ? this.body.type || null : ww(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof bw ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || "boolean" == typeof this.body ? "application/json" : null } clone(t = {}) { var e; const n = t.method || this.method, i = t.url || this.url, s = t.responseType || this.responseType, r = void 0 !== t.body ? t.body : this.body, o = void 0 !== t.withCredentials ? t.withCredentials : this.withCredentials, a = void 0 !== t.reportProgress ? t.reportProgress : this.reportProgress; let l = t.headers || this.headers, c = t.params || this.params; const h = null !== (e = t.context) && void 0 !== e ? e : this.context; return void 0 !== t.setHeaders && (l = Object.keys(t.setHeaders).reduce((e, n) => e.set(n, t.setHeaders[n]), l)), t.setParams && (c = Object.keys(t.setParams).reduce((e, n) => e.set(n, t.setParams[n]), c)), new xw(n, i, r, { params: c, headers: l, context: h, reportProgress: a, responseType: s, withCredentials: o }) } } var Sw = function (t) { return t[t.Sent = 0] = "Sent", t[t.UploadProgress = 1] = "UploadProgress", t[t.ResponseHeader = 2] = "ResponseHeader", t[t.DownloadProgress = 3] = "DownloadProgress", t[t.Response = 4] = "Response", t[t.User = 5] = "User", t }({}); class Ew { constructor(t, e = 200, n = "OK") { this.headers = t.headers || new mw, this.status = void 0 !== t.status ? t.status : e, this.statusText = t.statusText || n, this.url = t.url || null, this.ok = this.status >= 200 && this.status < 300 } } class Tw extends Ew { constructor(t = {}) { super(t), this.type = Sw.ResponseHeader } clone(t = {}) { return new Tw({ headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class Rw extends Ew { constructor(t = {}) { super(t), this.type = Sw.Response, this.body = void 0 !== t.body ? t.body : null } clone(t = {}) { return new Rw({ body: void 0 !== t.body ? t.body : this.body, headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class Aw extends Ew { constructor(t) { super(t, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.message = this.status >= 200 && this.status < 300 ? `Http failure during parsing for ${t.url || "(unknown url)"}` : `Http failure response for ${t.url || "(unknown url)"}: ${t.status} ${t.statusText}`, this.error = t.error || null } } function Ow(t, e) { return { body: e, headers: t.headers, context: t.context, observe: t.observe, params: t.params, reportProgress: t.reportProgress, responseType: t.responseType, withCredentials: t.withCredentials } } let Iw = (() => { class t { constructor(t) { this.handler = t } request(t, e, n = {}) { let i; if (t instanceof xw) i = t; else { let s, r; s = n.headers instanceof mw ? n.headers : new mw(n.headers), n.params && (r = n.params instanceof bw ? n.params : new bw({ fromObject: n.params })), i = new xw(t, e, void 0 !== n.body ? n.body : null, { headers: s, context: n.context, params: r, reportProgress: n.reportProgress, responseType: n.responseType || "json", withCredentials: n.withCredentials }) } const s = pu(i).pipe($u(t => this.handler.handle(t))); if (t instanceof xw || "events" === n.observe) return s; const r = s.pipe(Vu(t => t instanceof Rw)); switch (n.observe || "body") { case "body": switch (i.responseType) { case "arraybuffer": return r.pipe(E(t => { if (null !== t.body && !(t.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer."); return t.body })); case "blob": return r.pipe(E(t => { if (null !== t.body && !(t.body instanceof Blob)) throw new Error("Response is not a Blob."); return t.body })); case "text": return r.pipe(E(t => { if (null !== t.body && "string" != typeof t.body) throw new Error("Response is not a string."); return t.body })); case "json": default: return r.pipe(E(t => t.body)) }case "response": return r; default: throw new Error(`Unreachable: unhandled observe type ${n.observe}}`) } } delete(t, e = {}) { return this.request("DELETE", t, e) } get(t, e = {}) { return this.request("GET", t, e) } head(t, e = {}) { return this.request("HEAD", t, e) } jsonp(t, e) { return this.request("JSONP", t, { params: (new bw).append(e, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(t, e = {}) { return this.request("OPTIONS", t, e) } patch(t, e, n = {}) { return this.request("PATCH", t, Ow(n, e)) } post(t, e, n = {}) { return this.request("POST", t, Ow(n, e)) } put(t, e, n = {}) { return this.request("PUT", t, Ow(n, e)) } } return t.\u0275fac = function (e) { return new (e || t)(li(pw)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); class Dw { constructor(t, e) { this.next = t, this.interceptor = e } handle(t) { return this.interceptor.intercept(t, this.next) } } const Pw = new $n("HTTP_INTERCEPTORS"); let Mw = (() => { class t { intercept(t, e) { return e.handle(t) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const Nw = /^\)\]\}',?\n/; let Fw = (() => { class t { constructor(t) { this.xhrFactory = t } handle(t) { if ("JSONP" === t.method) throw new Error("Attempted to construct Jsonp request without HttpClientJsonpModule installed."); return new y(e => { const n = this.xhrFactory.build(); if (n.open(t.method, t.urlWithParams), t.withCredentials && (n.withCredentials = !0), t.headers.forEach((t, e) => n.setRequestHeader(t, e.join(","))), t.headers.has("Accept") || n.setRequestHeader("Accept", "application/json, text/plain, */*"), !t.headers.has("Content-Type")) { const e = t.detectContentTypeHeader(); null !== e && n.setRequestHeader("Content-Type", e) } if (t.responseType) { const e = t.responseType.toLowerCase(); n.responseType = "json" !== e ? e : "text" } const i = t.serializeBody(); let s = null; const r = () => { if (null !== s) return s; const e = 1223 === n.status ? 204 : n.status, i = n.statusText || "OK", r = new mw(n.getAllResponseHeaders()), o = function (t) { return "responseURL" in t && t.responseURL ? t.responseURL : /^X-Request-URL:/m.test(t.getAllResponseHeaders()) ? t.getResponseHeader("X-Request-URL") : null }(n) || t.url; return s = new Tw({ headers: r, status: e, statusText: i, url: o }), s }, o = () => { let { headers: i, status: s, statusText: o, url: a } = r(), l = null; 204 !== s && (l = void 0 === n.response ? n.responseText : n.response), 0 === s && (s = l ? 200 : 0); let c = s >= 200 && s < 300; if ("json" === t.responseType && "string" == typeof l) { const t = l; l = l.replace(Nw, ""); try { l = "" !== l ? JSON.parse(l) : null } catch (h) { l = t, c && (c = !1, l = { error: h, text: l }) } } c ? (e.next(new Rw({ body: l, headers: i, status: s, statusText: o, url: a || void 0 })), e.complete()) : e.error(new Aw({ error: l, headers: i, status: s, statusText: o, url: a || void 0 })) }, a = t => { const { url: i } = r(), s = new Aw({ error: t, status: n.status || 0, statusText: n.statusText || "Unknown Error", url: i || void 0 }); e.error(s) }; let l = !1; const c = i => { l || (e.next(r()), l = !0); let s = { type: Sw.DownloadProgress, loaded: i.loaded }; i.lengthComputable && (s.total = i.total), "text" === t.responseType && n.responseText && (s.partialText = n.responseText), e.next(s) }, h = t => { let n = { type: Sw.UploadProgress, loaded: t.loaded }; t.lengthComputable && (n.total = t.total), e.next(n) }; return n.addEventListener("load", o), n.addEventListener("error", a), n.addEventListener("timeout", a), n.addEventListener("abort", a), t.reportProgress && (n.addEventListener("progress", c), null !== i && n.upload && n.upload.addEventListener("progress", h)), n.send(i), e.next({ type: Sw.Sent }), () => { n.removeEventListener("error", a), n.removeEventListener("abort", a), n.removeEventListener("load", o), n.removeEventListener("timeout", a), t.reportProgress && (n.removeEventListener("progress", c), null !== i && n.upload && n.upload.removeEventListener("progress", h)), n.readyState !== n.DONE && n.abort() } }) } } return t.\u0275fac = function (e) { return new (e || t)(li(Ph)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const Lw = new $n("XSRF_COOKIE_NAME"), Vw = new $n("XSRF_HEADER_NAME"); class jw { } let Bw = (() => { class t { constructor(t, e, n) { this.doc = t, this.platform = e, this.cookieName = n, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0 } getToken() { if ("server" === this.platform) return null; const t = this.doc.cookie || ""; return t !== this.lastCookieString && (this.parseCount++, this.lastToken = vh(t, this.cookieName), this.lastCookieString = t), this.lastToken } } return t.\u0275fac = function (e) { return new (e || t)(li(Jc), li(rc), li(Lw)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), Hw = (() => { class t { constructor(t, e) { this.tokenService = t, this.headerName = e } intercept(t, e) { const n = t.url.toLowerCase(); if ("GET" === t.method || "HEAD" === t.method || n.startsWith("http://") || n.startsWith("https://")) return e.handle(t); const i = this.tokenService.getToken(); return null === i || t.headers.has(this.headerName) || (t = t.clone({ headers: t.headers.set(this.headerName, i) })), e.handle(t) } } return t.\u0275fac = function (e) { return new (e || t)(li(jw), li(Vw)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), Uw = (() => { class t { constructor(t, e) { this.backend = t, this.injector = e, this.chain = null } handle(t) { if (null === this.chain) { const t = this.injector.get(Pw, []); this.chain = t.reduceRight((t, e) => new Dw(t, e), this.backend) } return this.chain.handle(t) } } return t.\u0275fac = function (e) { return new (e || t)(li(fw), li(no)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), zw = (() => { class t { static disable() { return { ngModule: t, providers: [{ provide: Hw, useClass: Mw }] } } static withOptions(e = {}) { return { ngModule: t, providers: [e.cookieName ? { provide: Lw, useValue: e.cookieName } : [], e.headerName ? { provide: Vw, useValue: e.headerName } : []] } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ providers: [Hw, { provide: Pw, useExisting: Hw, multi: !0 }, { provide: jw, useClass: Bw }, { provide: Lw, useValue: "XSRF-TOKEN" }, { provide: Vw, useValue: "X-XSRF-TOKEN" }] }), t })(), $w = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ providers: [Iw, { provide: pw, useClass: Uw }, Fw, { provide: fw, useExisting: Fw }], imports: [[zw.withOptions({ cookieName: "XSRF-TOKEN", headerName: "X-XSRF-TOKEN" })]] }), t })(), qw = (() => { class t { constructor(t) { this._http = t, this.url = dw + "/todo" } getTodos() { return this._http.get(`${this.url}`) } addTodo(t) { return this._http.post(`${this.url}/add`, Object.assign({}, t)) } updateTodo(t) { return this._http.put(`${this.url}/update`, { title: t.title, description: t.description, todoId: t._id, start: t.start, due: t.due, tag: t.tag, isCompleted: t.isCompleted, progress: t.progress }) } deleteTodo(t) { return this._http.delete(`${this.url}/delete/${t}`) } } return t.\u0275fac = function (e) { return new (e || t)(li(Iw)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); class Ww { attach(t) { return this._attachedHost = t, t.attach(this) } detach() { let t = this._attachedHost; null != t && (this._attachedHost = null, t.detach()) } get isAttached() { return null != this._attachedHost } setAttachedHost(t) { this._attachedHost = t } } class Kw extends Ww { constructor(t, e, n, i) { super(), this.component = t, this.viewContainerRef = e, this.injector = n, this.componentFactoryResolver = i } } class Yw extends Ww { constructor(t, e, n) { super(), this.templateRef = t, this.viewContainerRef = e, this.context = n } get origin() { return this.templateRef.elementRef } attach(t, e = this.context) { return this.context = e, super.attach(t) } detach() { return this.context = void 0, super.detach() } } class Zw extends Ww { constructor(t) { super(), this.element = t instanceof Ma ? t.nativeElement : t } } class Gw { constructor() { this._isDisposed = !1, this.attachDomPortal = null } hasAttached() { return !!this._attachedPortal } attach(t) { return t instanceof Kw ? (this._attachedPortal = t, this.attachComponentPortal(t)) : t instanceof Yw ? (this._attachedPortal = t, this.attachTemplatePortal(t)) : this.attachDomPortal && t instanceof Zw ? (this._attachedPortal = t, this.attachDomPortal(t)) : void 0 } detach() { this._attachedPortal && (this._attachedPortal.setAttachedHost(null), this._attachedPortal = null), this._invokeDisposeFn() } dispose() { this.hasAttached() && this.detach(), this._invokeDisposeFn(), this._isDisposed = !0 } setDisposeFn(t) { this._disposeFn = t } _invokeDisposeFn() { this._disposeFn && (this._disposeFn(), this._disposeFn = null) } } class Qw extends Gw { constructor(t, e, n, i, s) { super(), this.outletElement = t, this._componentFactoryResolver = e, this._appRef = n, this._defaultInjector = i, this.attachDomPortal = t => { const e = t.element, n = this._document.createComment("dom-portal"); e.parentNode.insertBefore(n, e), this.outletElement.appendChild(e), this._attachedPortal = t, super.setDisposeFn(() => { n.parentNode && n.parentNode.replaceChild(e, n) }) }, this._document = s } attachComponentPortal(t) { const e = (t.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(t.component); let n; return t.viewContainerRef ? (n = t.viewContainerRef.createComponent(e, t.viewContainerRef.length, t.injector || t.viewContainerRef.injector), this.setDisposeFn(() => n.destroy())) : (n = e.create(t.injector || this._defaultInjector), this._appRef.attachView(n.hostView), this.setDisposeFn(() => { this._appRef.detachView(n.hostView), n.destroy() })), this.outletElement.appendChild(this._getComponentRootNode(n)), this._attachedPortal = t, n } attachTemplatePortal(t) { let e = t.viewContainerRef, n = e.createEmbeddedView(t.templateRef, t.context); return n.rootNodes.forEach(t => this.outletElement.appendChild(t)), n.detectChanges(), this.setDisposeFn(() => { let t = e.indexOf(n); -1 !== t && e.remove(t) }), this._attachedPortal = t, n } dispose() { super.dispose(), null != this.outletElement.parentNode && this.outletElement.parentNode.removeChild(this.outletElement) } _getComponentRootNode(t) { return t.hostView.rootNodes[0] } } let Xw = (() => { class t extends Gw { constructor(t, e, n) { super(), this._componentFactoryResolver = t, this._viewContainerRef = e, this._isInitialized = !1, this.attached = new Ml, this.attachDomPortal = t => { const e = t.element, n = this._document.createComment("dom-portal"); t.setAttachedHost(this), e.parentNode.insertBefore(n, e), this._getRootNode().appendChild(e), this._attachedPortal = t, super.setDisposeFn(() => { n.parentNode && n.parentNode.replaceChild(e, n) }) }, this._document = n } get portal() { return this._attachedPortal } set portal(t) { (!this.hasAttached() || t || this._isInitialized) && (this.hasAttached() && super.detach(), t && super.attach(t), this._attachedPortal = t) } get attachedRef() { return this._attachedRef } ngOnInit() { this._isInitialized = !0 } ngOnDestroy() { super.dispose(), this._attachedPortal = null, this._attachedRef = null } attachComponentPortal(t) { t.setAttachedHost(this); const e = null != t.viewContainerRef ? t.viewContainerRef : this._viewContainerRef, n = (t.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(t.component), i = e.createComponent(n, e.length, t.injector || e.injector); return e !== this._viewContainerRef && this._getRootNode().appendChild(i.hostView.rootNodes[0]), super.setDisposeFn(() => i.destroy()), this._attachedPortal = t, this._attachedRef = i, this.attached.emit(i), i } attachTemplatePortal(t) { t.setAttachedHost(this); const e = this._viewContainerRef.createEmbeddedView(t.templateRef, t.context); return super.setDisposeFn(() => this._viewContainerRef.clear()), this._attachedPortal = t, this._attachedRef = e, this.attached.emit(e), e } _getRootNode() { const t = this._viewContainerRef.element.nativeElement; return t.nodeType === t.ELEMENT_NODE ? t : t.parentNode } } return t.\u0275fac = function (e) { return new (e || t)(bo(Oa), bo(yl), bo(Jc)) }, t.\u0275dir = Zt({ type: t, selectors: [["", "cdkPortalOutlet", ""]], inputs: { portal: ["cdkPortalOutlet", "portal"] }, outputs: { attached: "attached" }, exportAs: ["cdkPortalOutlet"], features: [so] }), t })(), Jw = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({}), t })(); class tC { constructor(t, e) { this.predicate = t, this.inclusive = e } call(t, e) { return e.subscribe(new eC(t, this.predicate, this.inclusive)) } } class eC extends f { constructor(t, e, n) { super(t), this.predicate = e, this.inclusive = n, this.index = 0 } _next(t) { const e = this.destination; let n; try { n = this.predicate(t, this.index++) } catch (i) { return void e.error(i) } this.nextOrComplete(t, n) } nextOrComplete(t, e) { const n = this.destination; Boolean(e) ? n.next(t) : (this.inclusive && n.next(t), n.complete()) } } const nC = Im(); class iC { constructor(t, e) { this._viewportRuler = t, this._previousHTMLStyles = { top: "", left: "" }, this._isEnabled = !1, this._document = e } attach() { } enable() { if (this._canBeEnabled()) { const t = this._document.documentElement; this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition(), this._previousHTMLStyles.left = t.style.left || "", this._previousHTMLStyles.top = t.style.top || "", t.style.left = dm(-this._previousScrollPosition.left), t.style.top = dm(-this._previousScrollPosition.top), t.classList.add("cdk-global-scrollblock"), this._isEnabled = !0 } } disable() { if (this._isEnabled) { const t = this._document.documentElement, e = t.style, n = this._document.body.style, i = e.scrollBehavior || "", s = n.scrollBehavior || ""; this._isEnabled = !1, e.left = this._previousHTMLStyles.left, e.top = this._previousHTMLStyles.top, t.classList.remove("cdk-global-scrollblock"), nC && (e.scrollBehavior = n.scrollBehavior = "auto"), window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top), nC && (e.scrollBehavior = i, n.scrollBehavior = s) } } _canBeEnabled() { if (this._document.documentElement.classList.contains("cdk-global-scrollblock") || this._isEnabled) return !1; const t = this._document.body, e = this._viewportRuler.getViewportSize(); return t.scrollHeight > e.height || t.scrollWidth > e.width } } class sC { constructor(t, e, n, i) { this._scrollDispatcher = t, this._ngZone = e, this._viewportRuler = n, this._config = i, this._scrollSubscription = null, this._detach = () => { this.disable(), this._overlayRef.hasAttached() && this._ngZone.run(() => this._overlayRef.detach()) } } attach(t) { this._overlayRef = t } enable() { if (this._scrollSubscription) return; const t = this._scrollDispatcher.scrolled(0); this._config && this._config.threshold && this._config.threshold > 1 ? (this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top, this._scrollSubscription = t.subscribe(() => { const t = this._viewportRuler.getViewportScrollPosition().top; Math.abs(t - this._initialScrollPosition) > this._config.threshold ? this._detach() : this._overlayRef.updatePosition() })) : this._scrollSubscription = t.subscribe(this._detach) } disable() { this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null) } detach() { this.disable(), this._overlayRef = null } } class rC { enable() { } disable() { } attach() { } } function oC(t, e) { return e.some(e => t.bottom < e.top || t.top > e.bottom || t.right < e.left || t.left > e.right) } function aC(t, e) { return e.some(e => t.top < e.top || t.bottom > e.bottom || t.left < e.left || t.right > e.right) } class lC { constructor(t, e, n, i) { this._scrollDispatcher = t, this._viewportRuler = e, this._ngZone = n, this._config = i, this._scrollSubscription = null } attach(t) { this._overlayRef = t } enable() { this._scrollSubscription || (this._scrollSubscription = this._scrollDispatcher.scrolled(this._config ? this._config.scrollThrottle : 0).subscribe(() => { if (this._overlayRef.updatePosition(), this._config && this._config.autoClose) { const t = this._overlayRef.overlayElement.getBoundingClientRect(), { width: e, height: n } = this._viewportRuler.getViewportSize(); oC(t, [{ width: e, height: n, bottom: n, right: e, top: 0, left: 0 }]) && (this.disable(), this._ngZone.run(() => this._overlayRef.detach())) } })) } disable() { this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null) } detach() { this.disable(), this._overlayRef = null } } let cC = (() => { class t { constructor(t, e, n, i) { this._scrollDispatcher = t, this._viewportRuler = e, this._ngZone = n, this.noop = () => new rC, this.close = t => new sC(this._scrollDispatcher, this._ngZone, this._viewportRuler, t), this.block = () => new iC(this._viewportRuler, this._document), this.reposition = t => new lC(this._scrollDispatcher, this._viewportRuler, this._ngZone, t), this._document = i } } return t.\u0275fac = function (e) { return new (e || t)(li(Gm), li(Qm), li(vc), li(Jc)) }, t.\u0275prov = dt({ factory: function () { return new t(li(Gm), li(Qm), li(vc), li(Jc)) }, token: t, providedIn: "root" }), t })(); class hC { constructor(t) { if (this.scrollStrategy = new rC, this.panelClass = "", this.hasBackdrop = !1, this.backdropClass = "cdk-overlay-dark-backdrop", this.disposeOnNavigation = !1, t) { const e = Object.keys(t); for (const n of e) void 0 !== t[n] && (this[n] = t[n]) } } } class uC { constructor(t, e, n, i, s) { this.offsetX = n, this.offsetY = i, this.panelClass = s, this.originX = t.originX, this.originY = t.originY, this.overlayX = e.overlayX, this.overlayY = e.overlayY } } class dC { constructor(t, e) { this.connectionPair = t, this.scrollableViewProperties = e } } let pC = (() => { class t { constructor(t) { this._attachedOverlays = [], this._document = t } ngOnDestroy() { this.detach() } add(t) { this.remove(t), this._attachedOverlays.push(t) } remove(t) { const e = this._attachedOverlays.indexOf(t); e > -1 && this._attachedOverlays.splice(e, 1), 0 === this._attachedOverlays.length && this.detach() } } return t.\u0275fac = function (e) { return new (e || t)(li(Jc)) }, t.\u0275prov = dt({ factory: function () { return new t(li(Jc)) }, token: t, providedIn: "root" }), t })(), fC = (() => { class t extends pC { constructor(t) { super(t), this._keydownListener = t => { const e = this._attachedOverlays; for (let n = e.length - 1; n > -1; n--)if (e[n]._keydownEvents.observers.length > 0) { e[n]._keydownEvents.next(t); break } } } add(t) { super.add(t), this._isAttached || (this._document.body.addEventListener("keydown", this._keydownListener), this._isAttached = !0) } detach() { this._isAttached && (this._document.body.removeEventListener("keydown", this._keydownListener), this._isAttached = !1) } } return t.\u0275fac = function (e) { return new (e || t)(li(Jc)) }, t.\u0275prov = dt({ factory: function () { return new t(li(Jc)) }, token: t, providedIn: "root" }), t })(), mC = (() => { class t extends pC { constructor(t, e) { super(t), this._platform = e, this._cursorStyleIsSet = !1, this._clickListener = t => { const e = t.composedPath ? t.composedPath()[0] : t.target, n = this._attachedOverlays.slice(); for (let i = n.length - 1; i > -1; i--) { const s = n[i]; if (!(s._outsidePointerEvents.observers.length < 1) && s.hasAttached()) { if (s.overlayElement.contains(e)) break; s._outsidePointerEvents.next(t) } } } } add(t) { if (super.add(t), !this._isAttached) { const t = this._document.body; t.addEventListener("click", this._clickListener, !0), t.addEventListener("auxclick", this._clickListener, !0), t.addEventListener("contextmenu", this._clickListener, !0), this._platform.IOS && !this._cursorStyleIsSet && (this._cursorOriginalValue = t.style.cursor, t.style.cursor = "pointer", this._cursorStyleIsSet = !0), this._isAttached = !0 } } detach() { if (this._isAttached) { const t = this._document.body; t.removeEventListener("click", this._clickListener, !0), t.removeEventListener("auxclick", this._clickListener, !0), t.removeEventListener("contextmenu", this._clickListener, !0), this._platform.IOS && this._cursorStyleIsSet && (t.style.cursor = this._cursorOriginalValue, this._cursorStyleIsSet = !1), this._isAttached = !1 } } } return t.\u0275fac = function (e) { return new (e || t)(li(Jc), li(km)) }, t.\u0275prov = dt({ factory: function () { return new t(li(Jc), li(km)) }, token: t, providedIn: "root" }), t })(); const gC = !("undefined" == typeof window || !window || !window.__karma__ && !window.jasmine); let _C = (() => { class t { constructor(t, e) { this._platform = e, this._document = t } ngOnDestroy() { const t = this._containerElement; t && t.parentNode && t.parentNode.removeChild(t) } getContainerElement() { return this._containerElement || this._createContainer(), this._containerElement } _createContainer() { const t = "cdk-overlay-container"; if (this._platform.isBrowser || gC) { const e = this._document.querySelectorAll(`.${t}[platform="server"], .${t}[platform="test"]`); for (let t = 0; t < e.length; t++)e[t].parentNode.removeChild(e[t]) } const e = this._document.createElement("div"); e.classList.add(t), gC ? e.setAttribute("platform", "test") : this._platform.isBrowser || e.setAttribute("platform", "server"), this._document.body.appendChild(e), this._containerElement = e } } return t.\u0275fac = function (e) { return new (e || t)(li(Jc), li(km)) }, t.\u0275prov = dt({ factory: function () { return new t(li(Jc), li(km)) }, token: t, providedIn: "root" }), t })(); class yC { constructor(t, e, n, i, s, r, o, a, l) { this._portalOutlet = t, this._host = e, this._pane = n, this._config = i, this._ngZone = s, this._keyboardDispatcher = r, this._document = o, this._location = a, this._outsideClickDispatcher = l, this._backdropElement = null, this._backdropClick = new k, this._attachments = new k, this._detachments = new k, this._locationChanges = u.EMPTY, this._backdropClickHandler = t => this._backdropClick.next(t), this._keydownEvents = new k, this._outsidePointerEvents = new k, i.scrollStrategy && (this._scrollStrategy = i.scrollStrategy, this._scrollStrategy.attach(this)), this._positionStrategy = i.positionStrategy } get overlayElement() { return this._pane } get backdropElement() { return this._backdropElement } get hostElement() { return this._host } attach(t) { let e = this._portalOutlet.attach(t); return !this._host.parentElement && this._previousHostParent && this._previousHostParent.appendChild(this._host), this._positionStrategy && this._positionStrategy.attach(this), this._updateStackingOrder(), this._updateElementSize(), this._updateElementDirection(), this._scrollStrategy && this._scrollStrategy.enable(), this._ngZone.onStable.pipe(Iu(1)).subscribe(() => { this.hasAttached() && this.updatePosition() }), this._togglePointerEvents(!0), this._config.hasBackdrop && this._attachBackdrop(), this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !0), this._attachments.next(), this._keyboardDispatcher.add(this), this._config.disposeOnNavigation && (this._locationChanges = this._location.subscribe(() => this.dispose())), this._outsideClickDispatcher.add(this), e } detach() { if (!this.hasAttached()) return; this.detachBackdrop(), this._togglePointerEvents(!1), this._positionStrategy && this._positionStrategy.detach && this._positionStrategy.detach(), this._scrollStrategy && this._scrollStrategy.disable(); const t = this._portalOutlet.detach(); return this._detachments.next(), this._keyboardDispatcher.remove(this), this._detachContentWhenStable(), this._locationChanges.unsubscribe(), this._outsideClickDispatcher.remove(this), t } dispose() { const t = this.hasAttached(); this._positionStrategy && this._positionStrategy.dispose(), this._disposeScrollStrategy(), this.detachBackdrop(), this._locationChanges.unsubscribe(), this._keyboardDispatcher.remove(this), this._portalOutlet.dispose(), this._attachments.complete(), this._backdropClick.complete(), this._keydownEvents.complete(), this._outsidePointerEvents.complete(), this._outsideClickDispatcher.remove(this), this._host && this._host.parentNode && (this._host.parentNode.removeChild(this._host), this._host = null), this._previousHostParent = this._pane = null, t && this._detachments.next(), this._detachments.complete() } hasAttached() { return this._portalOutlet.hasAttached() } backdropClick() { return this._backdropClick } attachments() { return this._attachments } detachments() { return this._detachments } keydownEvents() { return this._keydownEvents } outsidePointerEvents() { return this._outsidePointerEvents } getConfig() { return this._config } updatePosition() { this._positionStrategy && this._positionStrategy.apply() } updatePositionStrategy(t) { t !== this._positionStrategy && (this._positionStrategy && this._positionStrategy.dispose(), this._positionStrategy = t, this.hasAttached() && (t.attach(this), this.updatePosition())) } updateSize(t) { this._config = Object.assign(Object.assign({}, this._config), t), this._updateElementSize() } setDirection(t) { this._config = Object.assign(Object.assign({}, this._config), { direction: t }), this._updateElementDirection() } addPanelClass(t) { this._pane && this._toggleClasses(this._pane, t, !0) } removePanelClass(t) { this._pane && this._toggleClasses(this._pane, t, !1) } getDirection() { const t = this._config.direction; return t ? "string" == typeof t ? t : t.value : "ltr" } updateScrollStrategy(t) { t !== this._scrollStrategy && (this._disposeScrollStrategy(), this._scrollStrategy = t, this.hasAttached() && (t.attach(this), t.enable())) } _updateElementDirection() { this._host.setAttribute("dir", this.getDirection()) } _updateElementSize() { if (!this._pane) return; const t = this._pane.style; t.width = dm(this._config.width), t.height = dm(this._config.height), t.minWidth = dm(this._config.minWidth), t.minHeight = dm(this._config.minHeight), t.maxWidth = dm(this._config.maxWidth), t.maxHeight = dm(this._config.maxHeight) } _togglePointerEvents(t) { this._pane.style.pointerEvents = t ? "" : "none" } _attachBackdrop() { const t = "cdk-overlay-backdrop-showing"; this._backdropElement = this._document.createElement("div"), this._backdropElement.classList.add("cdk-overlay-backdrop"), this._config.backdropClass && this._toggleClasses(this._backdropElement, this._config.backdropClass, !0), this._host.parentElement.insertBefore(this._backdropElement, this._host), this._backdropElement.addEventListener("click", this._backdropClickHandler), "undefined" != typeof requestAnimationFrame ? this._ngZone.runOutsideAngular(() => { requestAnimationFrame(() => { this._backdropElement && this._backdropElement.classList.add(t) }) }) : this._backdropElement.classList.add(t) } _updateStackingOrder() { this._host.nextSibling && this._host.parentNode.appendChild(this._host) } detachBackdrop() { let t, e = this._backdropElement; if (!e) return; let n = () => { e && (e.removeEventListener("click", this._backdropClickHandler), e.removeEventListener("transitionend", n), e.parentNode && e.parentNode.removeChild(e)), this._backdropElement == e && (this._backdropElement = null), this._config.backdropClass && this._toggleClasses(e, this._config.backdropClass, !1), clearTimeout(t) }; e.classList.remove("cdk-overlay-backdrop-showing"), this._ngZone.runOutsideAngular(() => { e.addEventListener("transitionend", n) }), e.style.pointerEvents = "none", t = this._ngZone.runOutsideAngular(() => setTimeout(n, 500)) } _toggleClasses(t, e, n) { const i = t.classList; um(e).forEach(t => { t && (n ? i.add(t) : i.remove(t)) }) } _detachContentWhenStable() { this._ngZone.runOutsideAngular(() => { const t = this._ngZone.onStable.pipe(Km(q(this._attachments, this._detachments))).subscribe(() => { this._pane && this._host && 0 !== this._pane.children.length || (this._pane && this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !1), this._host && this._host.parentElement && (this._previousHostParent = this._host.parentElement, this._previousHostParent.removeChild(this._host)), t.unsubscribe()) }) }) } _disposeScrollStrategy() { const t = this._scrollStrategy; t && (t.disable(), t.detach && t.detach()) } } const bC = "cdk-overlay-connected-position-bounding-box", vC = /([A-Za-z%]+)$/; class wC { constructor(t, e, n, i, s) { this._viewportRuler = e, this._document = n, this._platform = i, this._overlayContainer = s, this._lastBoundingBoxSize = { width: 0, height: 0 }, this._isPushed = !1, this._canPush = !0, this._growAfterOpen = !1, this._hasFlexibleDimensions = !0, this._positionLocked = !1, this._viewportMargin = 0, this._scrollables = [], this._preferredPositions = [], this._positionChanges = new k, this._resizeSubscription = u.EMPTY, this._offsetX = 0, this._offsetY = 0, this._appliedPanelClasses = [], this.positionChanges = this._positionChanges, this.setOrigin(t) } get positions() { return this._preferredPositions } attach(t) { this._validatePositions(), t.hostElement.classList.add(bC), this._overlayRef = t, this._boundingBox = t.hostElement, this._pane = t.overlayElement, this._isDisposed = !1, this._isInitialRender = !0, this._lastPosition = null, this._resizeSubscription.unsubscribe(), this._resizeSubscription = this._viewportRuler.change().subscribe(() => { this._isInitialRender = !0, this.apply() }) } apply() { if (this._isDisposed || !this._platform.isBrowser) return; if (!this._isInitialRender && this._positionLocked && this._lastPosition) return void this.reapplyLastPosition(); this._clearPanelClasses(), this._resetOverlayElementStyles(), this._resetBoundingBoxStyles(), this._viewportRect = this._getNarrowedViewportRect(), this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(); const t = this._originRect, e = this._overlayRect, n = this._viewportRect, i = []; let s; for (let r of this._preferredPositions) { let o = this._getOriginPoint(t, r), a = this._getOverlayPoint(o, e, r), l = this._getOverlayFit(a, e, n, r); if (l.isCompletelyWithinViewport) return this._isPushed = !1, void this._applyPosition(r, o); this._canFitWithFlexibleDimensions(l, a, n) ? i.push({ position: r, origin: o, overlayRect: e, boundingBoxRect: this._calculateBoundingBoxRect(o, r) }) : (!s || s.overlayFit.visibleArea < l.visibleArea) && (s = { overlayFit: l, overlayPoint: a, originPoint: o, position: r, overlayRect: e }) } if (i.length) { let t = null, e = -1; for (const n of i) { const i = n.boundingBoxRect.width * n.boundingBoxRect.height * (n.position.weight || 1); i > e && (e = i, t = n) } return this._isPushed = !1, void this._applyPosition(t.position, t.origin) } if (this._canPush) return this._isPushed = !0, void this._applyPosition(s.position, s.originPoint); this._applyPosition(s.position, s.originPoint) } detach() { this._clearPanelClasses(), this._lastPosition = null, this._previousPushAmount = null, this._resizeSubscription.unsubscribe() } dispose() { this._isDisposed || (this._boundingBox && CC(this._boundingBox.style, { top: "", left: "", right: "", bottom: "", height: "", width: "", alignItems: "", justifyContent: "" }), this._pane && this._resetOverlayElementStyles(), this._overlayRef && this._overlayRef.hostElement.classList.remove(bC), this.detach(), this._positionChanges.complete(), this._overlayRef = this._boundingBox = null, this._isDisposed = !0) } reapplyLastPosition() { if (!this._isDisposed && (!this._platform || this._platform.isBrowser)) { this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(), this._viewportRect = this._getNarrowedViewportRect(); const t = this._lastPosition || this._preferredPositions[0], e = this._getOriginPoint(this._originRect, t); this._applyPosition(t, e) } } withScrollableContainers(t) { return this._scrollables = t, this } withPositions(t) { return this._preferredPositions = t, -1 === t.indexOf(this._lastPosition) && (this._lastPosition = null), this._validatePositions(), this } withViewportMargin(t) { return this._viewportMargin = t, this } withFlexibleDimensions(t = !0) { return this._hasFlexibleDimensions = t, this } withGrowAfterOpen(t = !0) { return this._growAfterOpen = t, this } withPush(t = !0) { return this._canPush = t, this } withLockedPosition(t = !0) { return this._positionLocked = t, this } setOrigin(t) { return this._origin = t, this } withDefaultOffsetX(t) { return this._offsetX = t, this } withDefaultOffsetY(t) { return this._offsetY = t, this } withTransformOriginOn(t) { return this._transformOriginSelector = t, this } _getOriginPoint(t, e) { let n, i; if ("center" == e.originX) n = t.left + t.width / 2; else { const i = this._isRtl() ? t.right : t.left, s = this._isRtl() ? t.left : t.right; n = "start" == e.originX ? i : s } return i = "center" == e.originY ? t.top + t.height / 2 : "top" == e.originY ? t.top : t.bottom, { x: n, y: i } } _getOverlayPoint(t, e, n) { let i, s; return i = "center" == n.overlayX ? -e.width / 2 : "start" === n.overlayX ? this._isRtl() ? -e.width : 0 : this._isRtl() ? 0 : -e.width, s = "center" == n.overlayY ? -e.height / 2 : "top" == n.overlayY ? 0 : -e.height, { x: t.x + i, y: t.y + s } } _getOverlayFit(t, e, n, i) { const s = xC(e); let { x: r, y: o } = t, a = this._getOffset(i, "x"), l = this._getOffset(i, "y"); a && (r += a), l && (o += l); let c = 0 - o, h = o + s.height - n.height, u = this._subtractOverflows(s.width, 0 - r, r + s.width - n.width), d = this._subtractOverflows(s.height, c, h), p = u * d; return { visibleArea: p, isCompletelyWithinViewport: s.width * s.height === p, fitsInViewportVertically: d === s.height, fitsInViewportHorizontally: u == s.width } } _canFitWithFlexibleDimensions(t, e, n) { if (this._hasFlexibleDimensions) { const i = n.bottom - e.y, s = n.right - e.x, r = kC(this._overlayRef.getConfig().minHeight), o = kC(this._overlayRef.getConfig().minWidth), a = t.fitsInViewportHorizontally || null != o && o <= s; return (t.fitsInViewportVertically || null != r && r <= i) && a } return !1 } _pushOverlayOnScreen(t, e, n) { if (this._previousPushAmount && this._positionLocked) return { x: t.x + this._previousPushAmount.x, y: t.y + this._previousPushAmount.y }; const i = xC(e), s = this._viewportRect, r = Math.max(t.x + i.width - s.width, 0), o = Math.max(t.y + i.height - s.height, 0), a = Math.max(s.top - n.top - t.y, 0), l = Math.max(s.left - n.left - t.x, 0); let c = 0, h = 0; return c = i.width <= s.width ? l || -r : t.x < this._viewportMargin ? s.left - n.left - t.x : 0, h = i.height <= s.height ? a || -o : t.y < this._viewportMargin ? s.top - n.top - t.y : 0, this._previousPushAmount = { x: c, y: h }, { x: t.x + c, y: t.y + h } } _applyPosition(t, e) { if (this._setTransformOrigin(t), this._setOverlayElementStyles(e, t), this._setBoundingBoxStyles(e, t), t.panelClass && this._addPanelClasses(t.panelClass), this._lastPosition = t, this._positionChanges.observers.length) { const e = this._getScrollVisibility(), n = new dC(t, e); this._positionChanges.next(n) } this._isInitialRender = !1 } _setTransformOrigin(t) { if (!this._transformOriginSelector) return; const e = this._boundingBox.querySelectorAll(this._transformOriginSelector); let n, i = t.overlayY; n = "center" === t.overlayX ? "center" : this._isRtl() ? "start" === t.overlayX ? "right" : "left" : "start" === t.overlayX ? "left" : "right"; for (let s = 0; s < e.length; s++)e[s].style.transformOrigin = `${n} ${i}` } _calculateBoundingBoxRect(t, e) { const n = this._viewportRect, i = this._isRtl(); let s, r, o, a, l, c; if ("top" === e.overlayY) r = t.y, s = n.height - r + this._viewportMargin; else if ("bottom" === e.overlayY) o = n.height - t.y + 2 * this._viewportMargin, s = n.height - o + this._viewportMargin; else { const e = Math.min(n.bottom - t.y + n.top, t.y), i = this._lastBoundingBoxSize.height; s = 2 * e, r = t.y - e, s > i && !this._isInitialRender && !this._growAfterOpen && (r = t.y - i / 2) } if ("end" === e.overlayX && !i || "start" === e.overlayX && i) c = n.width - t.x + this._viewportMargin, a = t.x - this._viewportMargin; else if ("start" === e.overlayX && !i || "end" === e.overlayX && i) l = t.x, a = n.right - t.x; else { const e = Math.min(n.right - t.x + n.left, t.x), i = this._lastBoundingBoxSize.width; a = 2 * e, l = t.x - e, a > i && !this._isInitialRender && !this._growAfterOpen && (l = t.x - i / 2) } return { top: r, left: l, bottom: o, right: c, width: a, height: s } } _setBoundingBoxStyles(t, e) { const n = this._calculateBoundingBoxRect(t, e); this._isInitialRender || this._growAfterOpen || (n.height = Math.min(n.height, this._lastBoundingBoxSize.height), n.width = Math.min(n.width, this._lastBoundingBoxSize.width)); const i = {}; if (this._hasExactPosition()) i.top = i.left = "0", i.bottom = i.right = i.maxHeight = i.maxWidth = "", i.width = i.height = "100%"; else { const t = this._overlayRef.getConfig().maxHeight, s = this._overlayRef.getConfig().maxWidth; i.height = dm(n.height), i.top = dm(n.top), i.bottom = dm(n.bottom), i.width = dm(n.width), i.left = dm(n.left), i.right = dm(n.right), i.alignItems = "center" === e.overlayX ? "center" : "end" === e.overlayX ? "flex-end" : "flex-start", i.justifyContent = "center" === e.overlayY ? "center" : "bottom" === e.overlayY ? "flex-end" : "flex-start", t && (i.maxHeight = dm(t)), s && (i.maxWidth = dm(s)) } this._lastBoundingBoxSize = n, CC(this._boundingBox.style, i) } _resetBoundingBoxStyles() { CC(this._boundingBox.style, { top: "0", left: "0", right: "0", bottom: "0", height: "", width: "", alignItems: "", justifyContent: "" }) } _resetOverlayElementStyles() { CC(this._pane.style, { top: "", left: "", bottom: "", right: "", position: "", transform: "" }) } _setOverlayElementStyles(t, e) { const n = {}, i = this._hasExactPosition(), s = this._hasFlexibleDimensions, r = this._overlayRef.getConfig(); if (i) { const i = this._viewportRuler.getViewportScrollPosition(); CC(n, this._getExactOverlayY(e, t, i)), CC(n, this._getExactOverlayX(e, t, i)) } else n.position = "static"; let o = "", a = this._getOffset(e, "x"), l = this._getOffset(e, "y"); a && (o += `translateX(${a}px) `), l && (o += `translateY(${l}px)`), n.transform = o.trim(), r.maxHeight && (i ? n.maxHeight = dm(r.maxHeight) : s && (n.maxHeight = "")), r.maxWidth && (i ? n.maxWidth = dm(r.maxWidth) : s && (n.maxWidth = "")), CC(this._pane.style, n) } _getExactOverlayY(t, e, n) { let i = { top: "", bottom: "" }, s = this._getOverlayPoint(e, this._overlayRect, t); this._isPushed && (s = this._pushOverlayOnScreen(s, this._overlayRect, n)); let r = this._overlayContainer.getContainerElement().getBoundingClientRect().top; return s.y -= r, "bottom" === t.overlayY ? i.bottom = this._document.documentElement.clientHeight - (s.y + this._overlayRect.height) + "px" : i.top = dm(s.y), i } _getExactOverlayX(t, e, n) { let i, s = { left: "", right: "" }, r = this._getOverlayPoint(e, this._overlayRect, t); return this._isPushed && (r = this._pushOverlayOnScreen(r, this._overlayRect, n)), i = this._isRtl() ? "end" === t.overlayX ? "left" : "right" : "end" === t.overlayX ? "right" : "left", "right" === i ? s.right = this._document.documentElement.clientWidth - (r.x + this._overlayRect.width) + "px" : s.left = dm(r.x), s } _getScrollVisibility() { const t = this._getOriginRect(), e = this._pane.getBoundingClientRect(), n = this._scrollables.map(t => t.getElementRef().nativeElement.getBoundingClientRect()); return { isOriginClipped: aC(t, n), isOriginOutsideView: oC(t, n), isOverlayClipped: aC(e, n), isOverlayOutsideView: oC(e, n) } } _subtractOverflows(t, ...e) { return e.reduce((t, e) => t - Math.max(e, 0), t) } _getNarrowedViewportRect() { const t = this._document.documentElement.clientWidth, e = this._document.documentElement.clientHeight, n = this._viewportRuler.getViewportScrollPosition(); return { top: n.top + this._viewportMargin, left: n.left + this._viewportMargin, right: n.left + t - this._viewportMargin, bottom: n.top + e - this._viewportMargin, width: t - 2 * this._viewportMargin, height: e - 2 * this._viewportMargin } } _isRtl() { return "rtl" === this._overlayRef.getDirection() } _hasExactPosition() { return !this._hasFlexibleDimensions || this._isPushed } _getOffset(t, e) { return "x" === e ? null == t.offsetX ? this._offsetX : t.offsetX : null == t.offsetY ? this._offsetY : t.offsetY } _validatePositions() { } _addPanelClasses(t) { this._pane && um(t).forEach(t => { "" !== t && -1 === this._appliedPanelClasses.indexOf(t) && (this._appliedPanelClasses.push(t), this._pane.classList.add(t)) }) } _clearPanelClasses() { this._pane && (this._appliedPanelClasses.forEach(t => { this._pane.classList.remove(t) }), this._appliedPanelClasses = []) } _getOriginRect() { const t = this._origin; if (t instanceof Ma) return t.nativeElement.getBoundingClientRect(); if (t instanceof Element) return t.getBoundingClientRect(); const e = t.width || 0, n = t.height || 0; return { top: t.y, bottom: t.y + n, left: t.x, right: t.x + e, height: n, width: e } } } function CC(t, e) { for (let n in e) e.hasOwnProperty(n) && (t[n] = e[n]); return t } function kC(t) { if ("number" != typeof t && null != t) { const [e, n] = t.split(vC); return n && "px" !== n ? null : parseFloat(e) } return t || null } function xC(t) { return { top: Math.floor(t.top), right: Math.floor(t.right), bottom: Math.floor(t.bottom), left: Math.floor(t.left), width: Math.floor(t.width), height: Math.floor(t.height) } } class SC { constructor(t, e, n, i, s, r, o) { this._preferredPositions = [], this._positionStrategy = new wC(n, i, s, r, o).withFlexibleDimensions(!1).withPush(!1).withViewportMargin(0), this.withFallbackPosition(t, e), this.onPositionChange = this._positionStrategy.positionChanges } get positions() { return this._preferredPositions } attach(t) { this._overlayRef = t, this._positionStrategy.attach(t), this._direction && (t.setDirection(this._direction), this._direction = null) } dispose() { this._positionStrategy.dispose() } detach() { this._positionStrategy.detach() } apply() { this._positionStrategy.apply() } recalculateLastPosition() { this._positionStrategy.reapplyLastPosition() } withScrollableContainers(t) { this._positionStrategy.withScrollableContainers(t) } withFallbackPosition(t, e, n, i) { const s = new uC(t, e, n, i); return this._preferredPositions.push(s), this._positionStrategy.withPositions(this._preferredPositions), this } withDirection(t) { return this._overlayRef ? this._overlayRef.setDirection(t) : this._direction = t, this } withOffsetX(t) { return this._positionStrategy.withDefaultOffsetX(t), this } withOffsetY(t) { return this._positionStrategy.withDefaultOffsetY(t), this } withLockedPosition(t) { return this._positionStrategy.withLockedPosition(t), this } withPositions(t) { return this._preferredPositions = t.slice(), this._positionStrategy.withPositions(this._preferredPositions), this } setOrigin(t) { return this._positionStrategy.setOrigin(t), this } } const EC = "cdk-global-overlay-wrapper"; class TC { constructor() { this._cssPosition = "static", this._topOffset = "", this._bottomOffset = "", this._leftOffset = "", this._rightOffset = "", this._alignItems = "", this._justifyContent = "", this._width = "", this._height = "" } attach(t) { const e = t.getConfig(); this._overlayRef = t, this._width && !e.width && t.updateSize({ width: this._width }), this._height && !e.height && t.updateSize({ height: this._height }), t.hostElement.classList.add(EC), this._isDisposed = !1 } top(t = "") { return this._bottomOffset = "", this._topOffset = t, this._alignItems = "flex-start", this } left(t = "") { return this._rightOffset = "", this._leftOffset = t, this._justifyContent = "flex-start", this } bottom(t = "") { return this._topOffset = "", this._bottomOffset = t, this._alignItems = "flex-end", this } right(t = "") { return this._leftOffset = "", this._rightOffset = t, this._justifyContent = "flex-end", this } width(t = "") { return this._overlayRef ? this._overlayRef.updateSize({ width: t }) : this._width = t, this } height(t = "") { return this._overlayRef ? this._overlayRef.updateSize({ height: t }) : this._height = t, this } centerHorizontally(t = "") { return this.left(t), this._justifyContent = "center", this } centerVertically(t = "") { return this.top(t), this._alignItems = "center", this } apply() { if (!this._overlayRef || !this._overlayRef.hasAttached()) return; const t = this._overlayRef.overlayElement.style, e = this._overlayRef.hostElement.style, n = this._overlayRef.getConfig(), { width: i, height: s, maxWidth: r, maxHeight: o } = n, a = !("100%" !== i && "100vw" !== i || r && "100%" !== r && "100vw" !== r), l = !("100%" !== s && "100vh" !== s || o && "100%" !== o && "100vh" !== o); t.position = this._cssPosition, t.marginLeft = a ? "0" : this._leftOffset, t.marginTop = l ? "0" : this._topOffset, t.marginBottom = this._bottomOffset, t.marginRight = this._rightOffset, a ? e.justifyContent = "flex-start" : "center" === this._justifyContent ? e.justifyContent = "center" : "rtl" === this._overlayRef.getConfig().direction ? "flex-start" === this._justifyContent ? e.justifyContent = "flex-end" : "flex-end" === this._justifyContent && (e.justifyContent = "flex-start") : e.justifyContent = this._justifyContent, e.alignItems = l ? "flex-start" : this._alignItems } dispose() { if (this._isDisposed || !this._overlayRef) return; const t = this._overlayRef.overlayElement.style, e = this._overlayRef.hostElement, n = e.style; e.classList.remove(EC), n.justifyContent = n.alignItems = t.marginTop = t.marginBottom = t.marginLeft = t.marginRight = t.position = "", this._overlayRef = null, this._isDisposed = !0 } } let RC = (() => { class t { constructor(t, e, n, i) { this._viewportRuler = t, this._document = e, this._platform = n, this._overlayContainer = i } global() { return new TC } connectedTo(t, e, n) { return new SC(e, n, t, this._viewportRuler, this._document, this._platform, this._overlayContainer) } flexibleConnectedTo(t) { return new wC(t, this._viewportRuler, this._document, this._platform, this._overlayContainer) } } return t.\u0275fac = function (e) { return new (e || t)(li(Qm), li(Jc), li(km), li(_C)) }, t.\u0275prov = dt({ factory: function () { return new t(li(Qm), li(Jc), li(km), li(_C)) }, token: t, providedIn: "root" }), t })(), AC = 0, OC = (() => { class t { constructor(t, e, n, i, s, r, o, a, l, c, h) { this.scrollStrategies = t, this._overlayContainer = e, this._componentFactoryResolver = n, this._positionBuilder = i, this._keyboardDispatcher = s, this._injector = r, this._ngZone = o, this._document = a, this._directionality = l, this._location = c, this._outsideClickDispatcher = h } create(t) { const e = this._createHostElement(), n = this._createPaneElement(e), i = this._createPortalOutlet(n), s = new hC(t); return s.direction = s.direction || this._directionality.value, new yC(i, e, n, s, this._ngZone, this._keyboardDispatcher, this._document, this._location, this._outsideClickDispatcher) } position() { return this._positionBuilder } _createPaneElement(t) { const e = this._document.createElement("div"); return e.id = "cdk-overlay-" + AC++, e.classList.add("cdk-overlay-pane"), t.appendChild(e), e } _createHostElement() { const t = this._document.createElement("div"); return this._overlayContainer.getContainerElement().appendChild(t), t } _createPortalOutlet(t) { return this._appRef || (this._appRef = this._injector.get(Hc)), new Qw(t, this._componentFactoryResolver, this._appRef, this._injector, this._document) } } return t.\u0275fac = function (e) { return new (e || t)(li(cC), li(_C), li(Oa), li(RC), li(fC), li(no), li(vc), li(Jc), li(vm), li(fh), li(mC)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(); const IC = [{ originX: "start", originY: "bottom", overlayX: "start", overlayY: "top" }, { originX: "start", originY: "top", overlayX: "start", overlayY: "bottom" }, { originX: "end", originY: "top", overlayX: "end", overlayY: "bottom" }, { originX: "end", originY: "bottom", overlayX: "end", overlayY: "top" }], DC = new $n("cdk-connected-overlay-scroll-strategy"); let PC = (() => { class t { constructor(t) { this.elementRef = t } } return t.\u0275fac = function (e) { return new (e || t)(bo(Ma)) }, t.\u0275dir = Zt({ type: t, selectors: [["", "cdk-overlay-origin", ""], ["", "overlay-origin", ""], ["", "cdkOverlayOrigin", ""]], exportAs: ["cdkOverlayOrigin"] }), t })(), MC = (() => { class t { constructor(t, e, n, i, s) { this._overlay = t, this._dir = s, this._hasBackdrop = !1, this._lockPosition = !1, this._growAfterOpen = !1, this._flexibleDimensions = !1, this._push = !1, this._backdropSubscription = u.EMPTY, this._attachSubscription = u.EMPTY, this._detachSubscription = u.EMPTY, this._positionSubscription = u.EMPTY, this.viewportMargin = 0, this.open = !1, this.disableClose = !1, this.backdropClick = new Ml, this.positionChange = new Ml, this.attach = new Ml, this.detach = new Ml, this.overlayKeydown = new Ml, this.overlayOutsideClick = new Ml, this._templatePortal = new Yw(e, n), this._scrollStrategyFactory = i, this.scrollStrategy = this._scrollStrategyFactory() } get offsetX() { return this._offsetX } set offsetX(t) { this._offsetX = t, this._position && this._updatePositionStrategy(this._position) } get offsetY() { return this._offsetY } set offsetY(t) { this._offsetY = t, this._position && this._updatePositionStrategy(this._position) } get hasBackdrop() { return this._hasBackdrop } set hasBackdrop(t) { this._hasBackdrop = lm(t) } get lockPosition() { return this._lockPosition } set lockPosition(t) { this._lockPosition = lm(t) } get flexibleDimensions() { return this._flexibleDimensions } set flexibleDimensions(t) { this._flexibleDimensions = lm(t) } get growAfterOpen() { return this._growAfterOpen } set growAfterOpen(t) { this._growAfterOpen = lm(t) } get push() { return this._push } set push(t) { this._push = lm(t) } get overlayRef() { return this._overlayRef } get dir() { return this._dir ? this._dir.value : "ltr" } ngOnDestroy() { this._attachSubscription.unsubscribe(), this._detachSubscription.unsubscribe(), this._backdropSubscription.unsubscribe(), this._positionSubscription.unsubscribe(), this._overlayRef && this._overlayRef.dispose() } ngOnChanges(t) { this._position && (this._updatePositionStrategy(this._position), this._overlayRef.updateSize({ width: this.width, minWidth: this.minWidth, height: this.height, minHeight: this.minHeight }), t.origin && this.open && this._position.apply()), t.open && (this.open ? this._attachOverlay() : this._detachOverlay()) } _createOverlay() { this.positions && this.positions.length || (this.positions = IC); const t = this._overlayRef = this._overlay.create(this._buildConfig()); this._attachSubscription = t.attachments().subscribe(() => this.attach.emit()), this._detachSubscription = t.detachments().subscribe(() => this.detach.emit()), t.keydownEvents().subscribe(t => { this.overlayKeydown.next(t), 27 !== t.keyCode || this.disableClose || Vg(t) || (t.preventDefault(), this._detachOverlay()) }), this._overlayRef.outsidePointerEvents().subscribe(t => { this.overlayOutsideClick.next(t) }) } _buildConfig() { const t = this._position = this.positionStrategy || this._createPositionStrategy(), e = new hC({ direction: this._dir, positionStrategy: t, scrollStrategy: this.scrollStrategy, hasBackdrop: this.hasBackdrop }); return (this.width || 0 === this.width) && (e.width = this.width), (this.height || 0 === this.height) && (e.height = this.height), (this.minWidth || 0 === this.minWidth) && (e.minWidth = this.minWidth), (this.minHeight || 0 === this.minHeight) && (e.minHeight = this.minHeight), this.backdropClass && (e.backdropClass = this.backdropClass), this.panelClass && (e.panelClass = this.panelClass), e } _updatePositionStrategy(t) { const e = this.positions.map(t => ({ originX: t.originX, originY: t.originY, overlayX: t.overlayX, overlayY: t.overlayY, offsetX: t.offsetX || this.offsetX, offsetY: t.offsetY || this.offsetY, panelClass: t.panelClass || void 0 })); return t.setOrigin(this.origin.elementRef).withPositions(e).withFlexibleDimensions(this.flexibleDimensions).withPush(this.push).withGrowAfterOpen(this.growAfterOpen).withViewportMargin(this.viewportMargin).withLockedPosition(this.lockPosition).withTransformOriginOn(this.transformOriginSelector) } _createPositionStrategy() { const t = this._overlay.position().flexibleConnectedTo(this.origin.elementRef); return this._updatePositionStrategy(t), t } _attachOverlay() { this._overlayRef ? this._overlayRef.getConfig().hasBackdrop = this.hasBackdrop : this._createOverlay(), this._overlayRef.hasAttached() || this._overlayRef.attach(this._templatePortal), this.hasBackdrop ? this._backdropSubscription = this._overlayRef.backdropClick().subscribe(t => { this.backdropClick.emit(t) }) : this._backdropSubscription.unsubscribe(), this._positionSubscription.unsubscribe(), this.positionChange.observers.length > 0 && (this._positionSubscription = this._position.positionChanges.pipe(function (t, e = !1) { return n => n.lift(new tC(t, e)) }(() => this.positionChange.observers.length > 0)).subscribe(t => { this.positionChange.emit(t), 0 === this.positionChange.observers.length && this._positionSubscription.unsubscribe() })) } _detachOverlay() { this._overlayRef && this._overlayRef.detach(), this._backdropSubscription.unsubscribe(), this._positionSubscription.unsubscribe() } } return t.\u0275fac = function (e) { return new (e || t)(bo(OC), bo(ul), bo(yl), bo(DC), bo(vm, 8)) }, t.\u0275dir = Zt({ type: t, selectors: [["", "cdk-connected-overlay", ""], ["", "connected-overlay", ""], ["", "cdkConnectedOverlay", ""]], inputs: { viewportMargin: ["cdkConnectedOverlayViewportMargin", "viewportMargin"], open: ["cdkConnectedOverlayOpen", "open"], disableClose: ["cdkConnectedOverlayDisableClose", "disableClose"], scrollStrategy: ["cdkConnectedOverlayScrollStrategy", "scrollStrategy"], offsetX: ["cdkConnectedOverlayOffsetX", "offsetX"], offsetY: ["cdkConnectedOverlayOffsetY", "offsetY"], hasBackdrop: ["cdkConnectedOverlayHasBackdrop", "hasBackdrop"], lockPosition: ["cdkConnectedOverlayLockPosition", "lockPosition"], flexibleDimensions: ["cdkConnectedOverlayFlexibleDimensions", "flexibleDimensions"], growAfterOpen: ["cdkConnectedOverlayGrowAfterOpen", "growAfterOpen"], push: ["cdkConnectedOverlayPush", "push"], positions: ["cdkConnectedOverlayPositions", "positions"], origin: ["cdkConnectedOverlayOrigin", "origin"], positionStrategy: ["cdkConnectedOverlayPositionStrategy", "positionStrategy"], width: ["cdkConnectedOverlayWidth", "width"], height: ["cdkConnectedOverlayHeight", "height"], minWidth: ["cdkConnectedOverlayMinWidth", "minWidth"], minHeight: ["cdkConnectedOverlayMinHeight", "minHeight"], backdropClass: ["cdkConnectedOverlayBackdropClass", "backdropClass"], panelClass: ["cdkConnectedOverlayPanelClass", "panelClass"], transformOriginSelector: ["cdkConnectedOverlayTransformOriginOn", "transformOriginSelector"] }, outputs: { backdropClick: "backdropClick", positionChange: "positionChange", attach: "attach", detach: "detach", overlayKeydown: "overlayKeydown", overlayOutsideClick: "overlayOutsideClick" }, exportAs: ["cdkConnectedOverlay"], features: [le] }), t })(); const NC = { provide: DC, deps: [OC], useFactory: function (t) { return () => t.scrollStrategies.reposition() } }; let FC = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ providers: [OC, NC], imports: [[wm, Jw, Jm], Jm] }), t })(); function LC(t, e) { } class VC { constructor() { this.role = "dialog", this.panelClass = "", this.hasBackdrop = !0, this.backdropClass = "", this.disableClose = !1, this.width = "", this.height = "", this.maxWidth = "80vw", this.data = null, this.ariaDescribedBy = null, this.ariaLabelledBy = null, this.ariaLabel = null, this.autoFocus = !0, this.restoreFocus = !0, this.closeOnNavigation = !0 } } const jC = { dialogContainer: g_("dialogContainer", [v_("void, exit", b_({ opacity: 0, transform: "scale(0.7)" })), v_("enter", b_({ transform: "none" })), w_("* => enter", __("150ms cubic-bezier(0, 0, 0.2, 1)", b_({ transform: "none", opacity: 1 }))), w_("* => void, * => exit", __("75ms cubic-bezier(0.4, 0.0, 0.2, 1)", b_({ opacity: 0 })))]) }; let BC = (() => { class t extends Gw { constructor(t, e, n, i, s, r) { super(), this._elementRef = t, this._focusTrapFactory = e, this._changeDetectorRef = n, this._config = s, this._focusMonitor = r, this._animationStateChanged = new Ml, this._elementFocusedBeforeDialogWasOpened = null, this._closeInteractionType = null, this.attachDomPortal = t => (this._portalOutlet.hasAttached(), this._portalOutlet.attachDomPortal(t)), this._ariaLabelledBy = s.ariaLabelledBy || null, this._document = i } _initializeWithAttachedContent() { this._setupFocusTrap(), this._capturePreviouslyFocusedElement(), this._focusDialogContainer() } attachComponentPortal(t) { return this._portalOutlet.hasAttached(), this._portalOutlet.attachComponentPortal(t) } attachTemplatePortal(t) { return this._portalOutlet.hasAttached(), this._portalOutlet.attachTemplatePortal(t) } _recaptureFocus() { this._containsFocus() || (!this._config.autoFocus || !this._focusTrap.focusInitialElement()) && this._elementRef.nativeElement.focus() } _trapFocus() { this._config.autoFocus ? this._focusTrap.focusInitialElementWhenReady() : this._containsFocus() || this._elementRef.nativeElement.focus() } _restoreFocus() { const t = this._elementFocusedBeforeDialogWasOpened; if (this._config.restoreFocus && t && "function" == typeof t.focus) { const e = Dm(), n = this._elementRef.nativeElement; e && e !== this._document.body && e !== n && !n.contains(e) || (this._focusMonitor ? (this._focusMonitor.focusVia(t, this._closeInteractionType), this._closeInteractionType = null) : t.focus()) } this._focusTrap && this._focusTrap.destroy() } _setupFocusTrap() { this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement) } _capturePreviouslyFocusedElement() { this._document && (this._elementFocusedBeforeDialogWasOpened = Dm()) } _focusDialogContainer() { this._elementRef.nativeElement.focus && this._elementRef.nativeElement.focus() } _containsFocus() { const t = this._elementRef.nativeElement, e = Dm(); return t === e || t.contains(e) } } return t.\u0275fac = function (e) { return new (e || t)(bo(Ma), bo(Xg), bo(ol), bo(Jc, 8), bo(VC), bo(o_)) }, t.\u0275dir = Zt({ type: t, viewQuery: function (t, e) { if (1 & t && Kl(Xw, 7), 2 & t) { let t; Wl(t = Zl()) && (e._portalOutlet = t.first) } }, features: [so] }), t })(), HC = (() => { class t extends BC { constructor() { super(...arguments), this._state = "enter" } _onAnimationDone({ toState: t, totalTime: e }) { "enter" === t ? (this._trapFocus(), this._animationStateChanged.next({ state: "opened", totalTime: e })) : "exit" === t && (this._restoreFocus(), this._animationStateChanged.next({ state: "closed", totalTime: e })) } _onAnimationStart({ toState: t, totalTime: e }) { "enter" === t ? this._animationStateChanged.next({ state: "opening", totalTime: e }) : "exit" !== t && "void" !== t || this._animationStateChanged.next({ state: "closing", totalTime: e }) } _startExitAnimation() { this._state = "exit", this._changeDetectorRef.markForCheck() } } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = jn(t)))(n || t) } }(), t.\u0275cmp = zt({ type: t, selectors: [["mat-dialog-container"]], hostAttrs: ["tabindex", "-1", "aria-modal", "true", 1, "mat-dialog-container"], hostVars: 6, hostBindings: function (t, e) { 1 & t && Do("@dialogContainer.start", function (t) { return e._onAnimationStart(t) })("@dialogContainer.done", function (t) { return e._onAnimationDone(t) }), 2 & t && (ha("id", e._id), mo("role", e._config.role)("aria-labelledby", e._config.ariaLabel ? null : e._ariaLabelledBy)("aria-label", e._config.ariaLabel)("aria-describedby", e._config.ariaDescribedBy || null), ua("@dialogContainer", e._state)) }, features: [so], decls: 1, vars: 0, consts: [["cdkPortalOutlet", ""]], template: function (t, e) { 1 & t && _o(0, LC, 0, 0, "ng-template", 0) }, directives: [Xw], styles: [".mat-dialog-container{display:block;padding:24px;border-radius:4px;box-sizing:border-box;overflow:auto;outline:0;width:100%;height:100%;min-height:inherit;max-height:inherit}.cdk-high-contrast-active .mat-dialog-container{outline:solid 1px}.mat-dialog-content{display:block;margin:0 -24px;padding:0 24px;max-height:65vh;overflow:auto;-webkit-overflow-scrolling:touch}.mat-dialog-title{margin:0 0 20px;display:block}.mat-dialog-actions{padding:8px 0;display:flex;flex-wrap:wrap;min-height:52px;align-items:center;box-sizing:content-box;margin-bottom:-24px}.mat-dialog-actions[align=end]{justify-content:flex-end}.mat-dialog-actions[align=center]{justify-content:center}.mat-dialog-actions .mat-button-base+.mat-button-base,.mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}\n"], encapsulation: 2, data: { animation: [jC.dialogContainer] } }), t })(), UC = 0; class zC { constructor(t, e, n = "mat-dialog-" + UC++) { this._overlayRef = t, this._containerInstance = e, this.id = n, this.disableClose = this._containerInstance._config.disableClose, this._afterOpened = new k, this._afterClosed = new k, this._beforeClosed = new k, this._state = 0, e._id = n, e._animationStateChanged.pipe(Vu(t => "opened" === t.state), Iu(1)).subscribe(() => { this._afterOpened.next(), this._afterOpened.complete() }), e._animationStateChanged.pipe(Vu(t => "closed" === t.state), Iu(1)).subscribe(() => { clearTimeout(this._closeFallbackTimeout), this._finishDialogClose() }), t.detachments().subscribe(() => { this._beforeClosed.next(this._result), this._beforeClosed.complete(), this._afterClosed.next(this._result), this._afterClosed.complete(), this.componentInstance = null, this._overlayRef.dispose() }), t.keydownEvents().pipe(Vu(t => 27 === t.keyCode && !this.disableClose && !Vg(t))).subscribe(t => { t.preventDefault(), $C(this, "keyboard") }), t.backdropClick().subscribe(() => { this.disableClose ? this._containerInstance._recaptureFocus() : $C(this, "mouse") }) } close(t) { this._result = t, this._containerInstance._animationStateChanged.pipe(Vu(t => "closing" === t.state), Iu(1)).subscribe(e => { this._beforeClosed.next(t), this._beforeClosed.complete(), this._overlayRef.detachBackdrop(), this._closeFallbackTimeout = setTimeout(() => this._finishDialogClose(), e.totalTime + 100) }), this._state = 1, this._containerInstance._startExitAnimation() } afterOpened() { return this._afterOpened } afterClosed() { return this._afterClosed } beforeClosed() { return this._beforeClosed } backdropClick() { return this._overlayRef.backdropClick() } keydownEvents() { return this._overlayRef.keydownEvents() } updatePosition(t) { let e = this._getPositionStrategy(); return t && (t.left || t.right) ? t.left ? e.left(t.left) : e.right(t.right) : e.centerHorizontally(), t && (t.top || t.bottom) ? t.top ? e.top(t.top) : e.bottom(t.bottom) : e.centerVertically(), this._overlayRef.updatePosition(), this } updateSize(t = "", e = "") { return this._overlayRef.updateSize({ width: t, height: e }), this._overlayRef.updatePosition(), this } addPanelClass(t) { return this._overlayRef.addPanelClass(t), this } removePanelClass(t) { return this._overlayRef.removePanelClass(t), this } getState() { return this._state } _finishDialogClose() { this._state = 2, this._overlayRef.dispose() } _getPositionStrategy() { return this._overlayRef.getConfig().positionStrategy } } function $C(t, e, n) { return void 0 !== t._containerInstance && (t._containerInstance._closeInteractionType = e), t.close(n) } const qC = new $n("MatDialogData"), WC = new $n("mat-dialog-default-options"), KC = new $n("mat-dialog-scroll-strategy"), YC = { provide: KC, deps: [OC], useFactory: function (t) { return () => t.scrollStrategies.block() } }; let ZC = (() => { class t { constructor(t, e, n, i, s, r, o, a, l) { this._overlay = t, this._injector = e, this._defaultOptions = n, this._parentDialog = i, this._overlayContainer = s, this._dialogRefConstructor = o, this._dialogContainerType = a, this._dialogDataToken = l, this._openDialogsAtThisLevel = [], this._afterAllClosedAtThisLevel = new k, this._afterOpenedAtThisLevel = new k, this._ariaHiddenElements = new Map, this.afterAllClosed = Eu(() => this.openDialogs.length ? this._getAfterAllClosed() : this._getAfterAllClosed().pipe(Mu(void 0))), this._scrollStrategy = r } get openDialogs() { return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel } get afterOpened() { return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel } _getAfterAllClosed() { const t = this._parentDialog; return t ? t._getAfterAllClosed() : this._afterAllClosedAtThisLevel } open(t, e) { (e = function (t, e) { return Object.assign(Object.assign({}, e), t) }(e, this._defaultOptions || new VC)).id && this.getDialogById(e.id); const n = this._createOverlay(e), i = this._attachDialogContainer(n, e), s = this._attachDialogContent(t, i, n, e); return this.openDialogs.length || this._hideNonDialogContentFromAssistiveTechnology(), this.openDialogs.push(s), s.afterClosed().subscribe(() => this._removeOpenDialog(s)), this.afterOpened.next(s), i._initializeWithAttachedContent(), s } closeAll() { this._closeDialogs(this.openDialogs) } getDialogById(t) { return this.openDialogs.find(e => e.id === t) } ngOnDestroy() { this._closeDialogs(this._openDialogsAtThisLevel), this._afterAllClosedAtThisLevel.complete(), this._afterOpenedAtThisLevel.complete() } _createOverlay(t) { const e = this._getOverlayConfig(t); return this._overlay.create(e) } _getOverlayConfig(t) { const e = new hC({ positionStrategy: this._overlay.position().global(), scrollStrategy: t.scrollStrategy || this._scrollStrategy(), panelClass: t.panelClass, hasBackdrop: t.hasBackdrop, direction: t.direction, minWidth: t.minWidth, minHeight: t.minHeight, maxWidth: t.maxWidth, maxHeight: t.maxHeight, disposeOnNavigation: t.closeOnNavigation }); return t.backdropClass && (e.backdropClass = t.backdropClass), e } _attachDialogContainer(t, e) { const n = no.create({ parent: e && e.viewContainerRef && e.viewContainerRef.injector || this._injector, providers: [{ provide: VC, useValue: e }] }), i = new Kw(this._dialogContainerType, e.viewContainerRef, n, e.componentFactoryResolver); return t.attach(i).instance } _attachDialogContent(t, e, n, i) { const s = new this._dialogRefConstructor(n, e, i.id); if (t instanceof ul) e.attachTemplatePortal(new Yw(t, null, { $implicit: i.data, dialogRef: s })); else { const n = this._createInjector(i, s, e), r = e.attachComponentPortal(new Kw(t, i.viewContainerRef, n)); s.componentInstance = r.instance } return s.updateSize(i.width, i.height).updatePosition(i.position), s } _createInjector(t, e, n) { const i = t && t.viewContainerRef && t.viewContainerRef.injector, s = [{ provide: this._dialogContainerType, useValue: n }, { provide: this._dialogDataToken, useValue: t.data }, { provide: this._dialogRefConstructor, useValue: e }]; return !t.direction || i && i.get(vm, null) || s.push({ provide: vm, useValue: { value: t.direction, change: pu() } }), no.create({ parent: i || this._injector, providers: s }) } _removeOpenDialog(t) { const e = this.openDialogs.indexOf(t); e > -1 && (this.openDialogs.splice(e, 1), this.openDialogs.length || (this._ariaHiddenElements.forEach((t, e) => { t ? e.setAttribute("aria-hidden", t) : e.removeAttribute("aria-hidden") }), this._ariaHiddenElements.clear(), this._getAfterAllClosed().next())) } _hideNonDialogContentFromAssistiveTechnology() { const t = this._overlayContainer.getContainerElement(); if (t.parentElement) { const e = t.parentElement.children; for (let n = e.length - 1; n > -1; n--) { let i = e[n]; i === t || "SCRIPT" === i.nodeName || "STYLE" === i.nodeName || i.hasAttribute("aria-live") || (this._ariaHiddenElements.set(i, i.getAttribute("aria-hidden")), i.setAttribute("aria-hidden", "true")) } } } _closeDialogs(t) { let e = t.length; for (; e--;)t[e].close() } } return t.\u0275fac = function (e) { return new (e || t)(bo(OC), bo(no), bo(void 0), bo(void 0), bo(_C), bo(void 0), bo(Wn), bo(Wn), bo($n)) }, t.\u0275dir = Zt({ type: t }), t })(), GC = (() => { class t extends ZC { constructor(t, e, n, i, s, r, o) { super(t, e, i, r, o, s, zC, HC, qC) } } return t.\u0275fac = function (e) { return new (e || t)(li(OC), li(no), li(fh, 8), li(WC, 8), li(KC), li(t, 12), li(_C)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac }), t })(), QC = 0, XC = (() => { class t { constructor(t, e, n) { this.dialogRef = t, this._elementRef = e, this._dialog = n, this.type = "button" } ngOnInit() { this.dialogRef || (this.dialogRef = nk(this._elementRef, this._dialog.openDialogs)) } ngOnChanges(t) { const e = t._matDialogClose || t._matDialogCloseResult; e && (this.dialogResult = e.currentValue) } _onButtonClick(t) { $C(this.dialogRef, 0 === t.screenX && 0 === t.screenY ? "keyboard" : "mouse", this.dialogResult) } } return t.\u0275fac = function (e) { return new (e || t)(bo(zC, 8), bo(Ma), bo(GC)) }, t.\u0275dir = Zt({ type: t, selectors: [["", "mat-dialog-close", ""], ["", "matDialogClose", ""]], hostVars: 2, hostBindings: function (t, e) { 1 & t && Io("click", function (t) { return e._onButtonClick(t) }), 2 & t && mo("aria-label", e.ariaLabel || null)("type", e.type) }, inputs: { type: "type", dialogResult: ["mat-dialog-close", "dialogResult"], ariaLabel: ["aria-label", "ariaLabel"], _matDialogClose: ["matDialogClose", "_matDialogClose"] }, exportAs: ["matDialogClose"], features: [le] }), t })(), JC = (() => { class t { constructor(t, e, n) { this._dialogRef = t, this._elementRef = e, this._dialog = n, this.id = "mat-dialog-title-" + QC++ } ngOnInit() { this._dialogRef || (this._dialogRef = nk(this._elementRef, this._dialog.openDialogs)), this._dialogRef && Promise.resolve().then(() => { const t = this._dialogRef._containerInstance; t && !t._ariaLabelledBy && (t._ariaLabelledBy = this.id) }) } } return t.\u0275fac = function (e) { return new (e || t)(bo(zC, 8), bo(Ma), bo(GC)) }, t.\u0275dir = Zt({ type: t, selectors: [["", "mat-dialog-title", ""], ["", "matDialogTitle", ""]], hostAttrs: [1, "mat-dialog-title"], hostVars: 1, hostBindings: function (t, e) { 2 & t && ha("id", e.id) }, inputs: { id: "id" }, exportAs: ["matDialogTitle"] }), t })(), tk = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = Zt({ type: t, selectors: [["", "mat-dialog-content", ""], ["mat-dialog-content"], ["", "matDialogContent", ""]], hostAttrs: [1, "mat-dialog-content"] }), t })(), ek = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = Zt({ type: t, selectors: [["", "mat-dialog-actions", ""], ["mat-dialog-actions"], ["", "matDialogActions", ""]], hostAttrs: [1, "mat-dialog-actions"] }), t })(); function nk(t, e) { let n = t.nativeElement.parentElement; for (; n && !n.classList.contains("mat-dialog-container");)n = n.parentElement; return n ? e.find(t => t.id === n.id) : null } let ik = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ providers: [GC, YC], imports: [[FC, Jw, lv], lv] }), t })(); const sk = ["mat-button", ""], rk = ["*"], ok = ["mat-button", "mat-flat-button", "mat-icon-button", "mat-raised-button", "mat-stroked-button", "mat-mini-fab", "mat-fab"]; class ak { constructor(t) { this._elementRef = t } } const lk = hv(cv(uv(ak))); let ck = (() => { class t extends lk { constructor(t, e, n) { super(t), this._focusMonitor = e, this._animationMode = n, this.isRoundButton = this._hasHostAttributes("mat-fab", "mat-mini-fab"), this.isIconButton = this._hasHostAttributes("mat-icon-button"); for (const i of ok) this._hasHostAttributes(i) && this._getHostElement().classList.add(i); t.nativeElement.classList.add("mat-button-base"), this.isRoundButton && (this.color = "accent") } ngAfterViewInit() { this._focusMonitor.monitor(this._elementRef, !0) } ngOnDestroy() { this._focusMonitor.stopMonitoring(this._elementRef) } focus(t, e) { t ? this._focusMonitor.focusVia(this._getHostElement(), t, e) : this._getHostElement().focus(e) } _getHostElement() { return this._elementRef.nativeElement } _isRippleDisabled() { return this.disableRipple || this.disabled } _hasHostAttributes(...t) { return t.some(t => this._getHostElement().hasAttribute(t)) } } return t.\u0275fac = function (e) { return new (e || t)(bo(Ma), bo(o_), bo(Xb, 8)) }, t.\u0275cmp = zt({ type: t, selectors: [["button", "mat-button", ""], ["button", "mat-raised-button", ""], ["button", "mat-icon-button", ""], ["button", "mat-fab", ""], ["button", "mat-mini-fab", ""], ["button", "mat-stroked-button", ""], ["button", "mat-flat-button", ""]], viewQuery: function (t, e) { if (1 & t && Kl(Nv, 5), 2 & t) { let t; Wl(t = Zl()) && (e.ripple = t.first) } }, hostAttrs: [1, "mat-focus-indicator"], hostVars: 5, hostBindings: function (t, e) { 2 & t && (mo("disabled", e.disabled || null), Ko("_mat-animation-noopable", "NoopAnimations" === e._animationMode)("mat-button-disabled", e.disabled)) }, inputs: { disabled: "disabled", disableRipple: "disableRipple", color: "color" }, exportAs: ["matButton"], features: [so], attrs: sk, ngContentSelectors: rk, decls: 4, vars: 5, consts: [[1, "mat-button-wrapper"], ["matRipple", "", 1, "mat-button-ripple", 3, "matRippleDisabled", "matRippleCentered", "matRippleTrigger"], [1, "mat-button-focus-overlay"]], template: function (t, e) { 1 & t && (Vo(), Co(0, "span", 0), jo(1), ko(), xo(2, "span", 1), xo(3, "span", 2)), 2 & t && (qs(2), Ko("mat-button-ripple-round", e.isRoundButton || e.isIconButton), vo("matRippleDisabled", e._isRippleDisabled())("matRippleCentered", e.isIconButton)("matRippleTrigger", e._getHostElement())) }, directives: [Nv], styles: [".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button.mat-button-disabled,.mat-icon-button.mat-button-disabled,.mat-stroked-button.mat-button-disabled,.mat-flat-button.mat-button-disabled{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button.mat-button-disabled{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab.mat-button-disabled{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab.mat-button-disabled{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:inline-flex;justify-content:center;align-items:center;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}.cdk-high-contrast-active .mat-button-base.cdk-keyboard-focused,.cdk-high-contrast-active .mat-button-base.cdk-program-focused{outline:solid 3px}\n"], encapsulation: 2, changeDetection: 0 }), t })(), hk = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ imports: [[Fv, lv], lv] }), t })(); class uk { constructor(t) { this.total = t } call(t, e) { return e.subscribe(new dk(t, this.total)) } } class dk extends f { constructor(t, e) { super(t), this.total = e, this.count = 0 } _next(t) { ++this.count > this.total && this.destination.next(t) } } const pk = new Set; let fk, mk = (() => { class t { constructor(t) { this._platform = t, this._matchMedia = this._platform.isBrowser && window.matchMedia ? window.matchMedia.bind(window) : gk } matchMedia(t) { return this._platform.WEBKIT && function (t) { if (!pk.has(t)) try { fk || (fk = document.createElement("style"), fk.setAttribute("type", "text/css"), document.head.appendChild(fk)), fk.sheet && (fk.sheet.insertRule(`@media ${t} {.fx-query-test{ }}`, 0), pk.add(t)) } catch (e) { console.error(e) } }(t), this._matchMedia(t) } } return t.\u0275fac = function (e) { return new (e || t)(li(km)) }, t.\u0275prov = dt({ factory: function () { return new t(li(km)) }, token: t, providedIn: "root" }), t })(); function gk(t) { return { matches: "all" === t || "" === t, media: t, addListener: () => { }, removeListener: () => { } } } let _k = (() => { class t { constructor(t, e) { this._mediaMatcher = t, this._zone = e, this._queries = new Map, this._destroySubject = new k } ngOnDestroy() { this._destroySubject.next(), this._destroySubject.complete() } isMatched(t) { return yk(um(t)).some(t => this._registerQuery(t).mql.matches) } observe(t) { let e = bu(yk(um(t)).map(t => this._registerQuery(t).observable)); return e = ku(e.pipe(Iu(1)), e.pipe(t => t.lift(new uk(1)), jg(0))), e.pipe(E(t => { const e = { matches: !1, breakpoints: {} }; return t.forEach(({ matches: t, query: n }) => { e.matches = e.matches || t, e.breakpoints[n] = t }), e })) } _registerQuery(t) { if (this._queries.has(t)) return this._queries.get(t); const e = this._mediaMatcher.matchMedia(t), n = { observable: new y(t => { const n = e => this._zone.run(() => t.next(e)); return e.addListener(n), () => { e.removeListener(n) } }).pipe(Mu(e), E(({ matches: e }) => ({ query: t, matches: e })), Km(this._destroySubject)), mql: e }; return this._queries.set(t, n), n } } return t.\u0275fac = function (e) { return new (e || t)(li(mk), li(vc)) }, t.\u0275prov = dt({ factory: function () { return new t(li(mk), li(vc)) }, token: t, providedIn: "root" }), t })(); function yk(t) { return t.map(t => t.split(",")).reduce((t, e) => t.concat(e)).map(t => t.trim()) } function bk(t, e) { if (1 & t) { const t = Ro(); Co(0, "div", 1), Co(1, "button", 2), Io("click", function () { return Ie(t), Fo().action() }), ra(2), ko(), ko() } if (2 & t) { const t = Fo(); qs(2), oa(t.data.action) } } function vk(t, e) { } const wk = new $n("MatSnackBarData"); class Ck { constructor() { this.politeness = "assertive", this.announcementMessage = "", this.duration = 0, this.data = null, this.horizontalPosition = "center", this.verticalPosition = "bottom" } } const kk = Math.pow(2, 31) - 1; class xk { constructor(t, e) { this._overlayRef = e, this._afterDismissed = new k, this._afterOpened = new k, this._onAction = new k, this._dismissedByAction = !1, this.containerInstance = t, this.onAction().subscribe(() => this.dismiss()), t._onExit.subscribe(() => this._finishDismiss()) } dismiss() { this._afterDismissed.closed || this.containerInstance.exit(), clearTimeout(this._durationTimeoutId) } dismissWithAction() { this._onAction.closed || (this._dismissedByAction = !0, this._onAction.next(), this._onAction.complete()), clearTimeout(this._durationTimeoutId) } closeWithAction() { this.dismissWithAction() } _dismissAfter(t) { this._durationTimeoutId = setTimeout(() => this.dismiss(), Math.min(t, kk)) } _open() { this._afterOpened.closed || (this._afterOpened.next(), this._afterOpened.complete()) } _finishDismiss() { this._overlayRef.dispose(), this._onAction.closed || this._onAction.complete(), this._afterDismissed.next({ dismissedByAction: this._dismissedByAction }), this._afterDismissed.complete(), this._dismissedByAction = !1 } afterDismissed() { return this._afterDismissed } afterOpened() { return this.containerInstance._onEnter } onAction() { return this._onAction } } let Sk = (() => { class t { constructor(t, e) { this.snackBarRef = t, this.data = e } action() { this.snackBarRef.dismissWithAction() } get hasAction() { return !!this.data.action } } return t.\u0275fac = function (e) { return new (e || t)(bo(xk), bo(wk)) }, t.\u0275cmp = zt({ type: t, selectors: [["simple-snack-bar"]], hostAttrs: [1, "mat-simple-snackbar"], decls: 3, vars: 2, consts: [["class", "mat-simple-snackbar-action", 4, "ngIf"], [1, "mat-simple-snackbar-action"], ["mat-button", "", 3, "click"]], template: function (t, e) { 1 & t && (Co(0, "span"), ra(1), ko(), _o(2, bk, 3, 1, "div", 0)), 2 & t && (qs(1), oa(e.data.message), qs(1), vo("ngIf", e.hasAction)) }, directives: [Ch, ck], styles: [".mat-simple-snackbar{display:flex;justify-content:space-between;align-items:center;line-height:20px;opacity:1}.mat-simple-snackbar-action{flex-shrink:0;margin:-8px -8px -8px 8px}.mat-simple-snackbar-action button{max-height:36px;min-width:0}[dir=rtl] .mat-simple-snackbar-action{margin-left:-8px;margin-right:8px}\n"], encapsulation: 2, changeDetection: 0 }), t })(); const Ek = { snackBarState: g_("state", [v_("void, hidden", b_({ transform: "scale(0.8)", opacity: 0 })), v_("visible", b_({ transform: "scale(1)", opacity: 1 })), w_("* => visible", __("150ms cubic-bezier(0, 0, 0.2, 1)")), w_("* => void, * => hidden", __("75ms cubic-bezier(0.4, 0.0, 1, 1)", b_({ opacity: 0 })))]) }; let Tk = (() => { class t extends Gw { constructor(t, e, n, i, s) { super(), this._ngZone = t, this._elementRef = e, this._changeDetectorRef = n, this._platform = i, this.snackBarConfig = s, this._announceDelay = 150, this._destroyed = !1, this._onAnnounce = new k, this._onExit = new k, this._onEnter = new k, this._animationState = "void", this.attachDomPortal = t => (this._assertNotAttached(), this._applySnackBarClasses(), this._portalOutlet.attachDomPortal(t)), this._live = "assertive" !== s.politeness || s.announcementMessage ? "off" === s.politeness ? "off" : "polite" : "assertive", this._platform.FIREFOX && ("polite" === this._live && (this._role = "status"), "assertive" === this._live && (this._role = "alert")) } attachComponentPortal(t) { return this._assertNotAttached(), this._applySnackBarClasses(), this._portalOutlet.attachComponentPortal(t) } attachTemplatePortal(t) { return this._assertNotAttached(), this._applySnackBarClasses(), this._portalOutlet.attachTemplatePortal(t) } onAnimationEnd(t) { const { fromState: e, toState: n } = t; if (("void" === n && "void" !== e || "hidden" === n) && this._completeExit(), "visible" === n) { const t = this._onEnter; this._ngZone.run(() => { t.next(), t.complete() }) } } enter() { this._destroyed || (this._animationState = "visible", this._changeDetectorRef.detectChanges(), this._screenReaderAnnounce()) } exit() { return this._animationState = "hidden", this._elementRef.nativeElement.setAttribute("mat-exit", ""), clearTimeout(this._announceTimeoutId), this._onExit } ngOnDestroy() { this._destroyed = !0, this._completeExit() } _completeExit() { this._ngZone.onMicrotaskEmpty.pipe(Iu(1)).subscribe(() => { this._onExit.next(), this._onExit.complete() }) } _applySnackBarClasses() { const t = this._elementRef.nativeElement, e = this.snackBarConfig.panelClass; e && (Array.isArray(e) ? e.forEach(e => t.classList.add(e)) : t.classList.add(e)), "center" === this.snackBarConfig.horizontalPosition && t.classList.add("mat-snack-bar-center"), "top" === this.snackBarConfig.verticalPosition && t.classList.add("mat-snack-bar-top") } _assertNotAttached() { this._portalOutlet.hasAttached() } _screenReaderAnnounce() { this._announceTimeoutId || this._ngZone.runOutsideAngular(() => { this._announceTimeoutId = setTimeout(() => { const t = this._elementRef.nativeElement.querySelector("[aria-hidden]"), e = this._elementRef.nativeElement.querySelector("[aria-live]"); if (t && e) { let n = null; this._platform.isBrowser && document.activeElement instanceof HTMLElement && t.contains(document.activeElement) && (n = document.activeElement), t.removeAttribute("aria-hidden"), e.appendChild(t), null == n || n.focus(), this._onAnnounce.next(), this._onAnnounce.complete() } }, this._announceDelay) }) } } return t.\u0275fac = function (e) { return new (e || t)(bo(vc), bo(Ma), bo(ol), bo(km), bo(Ck)) }, t.\u0275cmp = zt({ type: t, selectors: [["snack-bar-container"]], viewQuery: function (t, e) { if (1 & t && Kl(Xw, 7), 2 & t) { let t; Wl(t = Zl()) && (e._portalOutlet = t.first) } }, hostAttrs: [1, "mat-snack-bar-container"], hostVars: 1, hostBindings: function (t, e) { 1 & t && Do("@state.done", function (t) { return e.onAnimationEnd(t) }), 2 & t && ua("@state", e._animationState) }, features: [so], decls: 3, vars: 2, consts: [["aria-hidden", "true"], ["cdkPortalOutlet", ""]], template: function (t, e) { 1 & t && (Co(0, "div", 0), _o(1, vk, 0, 0, "ng-template", 1), ko(), xo(2, "div")), 2 & t && (qs(2), mo("aria-live", e._live)("role", e._role)) }, directives: [Xw], styles: [".mat-snack-bar-container{border-radius:4px;box-sizing:border-box;display:block;margin:24px;max-width:33vw;min-width:344px;padding:14px 16px;min-height:48px;transform-origin:center}.cdk-high-contrast-active .mat-snack-bar-container{border:solid 1px}.mat-snack-bar-handset{width:100%}.mat-snack-bar-handset .mat-snack-bar-container{margin:8px;max-width:100%;min-width:0;width:100%}\n"], encapsulation: 2, data: { animation: [Ek.snackBarState] } }), t })(), Rk = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ imports: [[FC, Jw, Ah, hk, lv], lv] }), t })(); const Ak = new $n("mat-snack-bar-default-options", { providedIn: "root", factory: function () { return new Ck } }); let Ok = (() => { class t { constructor(t, e, n, i, s, r) { this._overlay = t, this._live = e, this._injector = n, this._breakpointObserver = i, this._parentSnackBar = s, this._defaultConfig = r, this._snackBarRefAtThisLevel = null, this.simpleSnackBarComponent = Sk, this.snackBarContainerComponent = Tk, this.handsetCssClass = "mat-snack-bar-handset" } get _openedSnackBarRef() { const t = this._parentSnackBar; return t ? t._openedSnackBarRef : this._snackBarRefAtThisLevel } set _openedSnackBarRef(t) { this._parentSnackBar ? this._parentSnackBar._openedSnackBarRef = t : this._snackBarRefAtThisLevel = t } openFromComponent(t, e) { return this._attach(t, e) } openFromTemplate(t, e) { return this._attach(t, e) } open(t, e = "", n) { const i = Object.assign(Object.assign({}, this._defaultConfig), n); return i.data = { message: t, action: e }, i.announcementMessage === t && (i.announcementMessage = void 0), this.openFromComponent(this.simpleSnackBarComponent, i) } dismiss() { this._openedSnackBarRef && this._openedSnackBarRef.dismiss() } ngOnDestroy() { this._snackBarRefAtThisLevel && this._snackBarRefAtThisLevel.dismiss() } _attachSnackBarContainer(t, e) { const n = no.create({ parent: e && e.viewContainerRef && e.viewContainerRef.injector || this._injector, providers: [{ provide: Ck, useValue: e }] }), i = new Kw(this.snackBarContainerComponent, e.viewContainerRef, n), s = t.attach(i); return s.instance.snackBarConfig = e, s.instance } _attach(t, e) { const n = Object.assign(Object.assign(Object.assign({}, new Ck), this._defaultConfig), e), i = this._createOverlay(n), s = this._attachSnackBarContainer(i, n), r = new xk(s, i); if (t instanceof ul) { const e = new Yw(t, null, { $implicit: n.data, snackBarRef: r }); r.instance = s.attachTemplatePortal(e) } else { const e = this._createInjector(n, r), i = new Kw(t, void 0, e), o = s.attachComponentPortal(i); r.instance = o.instance } return this._breakpointObserver.observe("(max-width: 599.98px) and (orientation: portrait)").pipe(Km(i.detachments())).subscribe(t => { const e = i.overlayElement.classList; t.matches ? e.add(this.handsetCssClass) : e.remove(this.handsetCssClass) }), n.announcementMessage && s._onAnnounce.subscribe(() => { this._live.announce(n.announcementMessage, n.politeness) }), this._animateSnackBar(r, n), this._openedSnackBarRef = r, this._openedSnackBarRef } _animateSnackBar(t, e) { t.afterDismissed().subscribe(() => { this._openedSnackBarRef == t && (this._openedSnackBarRef = null), e.announcementMessage && this._live.clear() }), this._openedSnackBarRef ? (this._openedSnackBarRef.afterDismissed().subscribe(() => { t.containerInstance.enter() }), this._openedSnackBarRef.dismiss()) : t.containerInstance.enter(), e.duration && e.duration > 0 && t.afterOpened().subscribe(() => t._dismissAfter(e.duration)) } _createOverlay(t) { const e = new hC; e.direction = t.direction; let n = this._overlay.position().global(); const i = "rtl" === t.direction, s = "left" === t.horizontalPosition || "start" === t.horizontalPosition && !i || "end" === t.horizontalPosition && i, r = !s && "center" !== t.horizontalPosition; return s ? n.left("0") : r ? n.right("0") : n.centerHorizontally(), "top" === t.verticalPosition ? n.top("0") : n.bottom("0"), e.positionStrategy = n, this._overlay.create(e) } _createInjector(t, e) { return no.create({ parent: t && t.viewContainerRef && t.viewContainerRef.injector || this._injector, providers: [{ provide: xk, useValue: e }, { provide: wk, useValue: t.data }] }) } } return t.\u0275fac = function (e) { return new (e || t)(li(OC), li(e_), li(no), li(_k), li(t, 12), li(Ak)) }, t.\u0275prov = dt({ factory: function () { return new t(li(OC), li(e_), li(Hr), li(_k), li(t, 12), li(Ak)) }, token: t, providedIn: Rk }), t })(); function Ik(...t) { if (1 === t.length) { const e = t[0]; if (l(e)) return Dk(e, null); if (c(e) && Object.getPrototypeOf(e) === Object.prototype) { const t = Object.keys(e); return Dk(t.map(t => e[t]), t) } } if ("function" == typeof t[t.length - 1]) { const e = t.pop(); return Dk(t = 1 === t.length && l(t[0]) ? t[0] : t, null).pipe(E(t => e(...t))) } return Dk(t, null) } function Dk(t, e) { return new y(n => { const i = t.length; if (0 === i) return void n.complete(); const s = new Array(i); let r = 0, o = 0; for (let a = 0; a < i; a++) { const l = F(t[a]); let c = !1; n.add(l.subscribe({ next: t => { c || (c = !0, o++), s[a] = t }, error: t => n.error(t), complete: () => { r++, r !== i && c || (o === i && n.next(e ? e.reduce((t, e, n) => (t[e] = s[n], t), {}) : s), n.complete()) } })) } }) } let Pk = (() => { class t { constructor(t, e) { this._renderer = t, this._elementRef = e, this.onChange = t => { }, this.onTouched = () => { } } setProperty(t, e) { this._renderer.setProperty(this._elementRef.nativeElement, t, e) } registerOnTouched(t) { this.onTouched = t } registerOnChange(t) { this.onChange = t } setDisabledState(t) { this.setProperty("disabled", t) } } return t.\u0275fac = function (e) { return new (e || t)(bo(La), bo(Ma)) }, t.\u0275dir = Zt({ type: t }), t })(), Mk = (() => { class t extends Pk { } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = jn(t)))(n || t) } }(), t.\u0275dir = Zt({ type: t, features: [so] }), t })(); const Nk = new $n("NgValueAccessor"), Fk = { provide: Nk, useExisting: rt(() => Vk), multi: !0 }, Lk = new $n("CompositionEventMode"); let Vk = (() => { class t extends Pk { constructor(t, e, n) { super(t, e), this._compositionMode = n, this._composing = !1, null == this._compositionMode && (this._compositionMode = !function () { const t = Xc() ? Xc().getUserAgent() : ""; return /android (\d+)/.test(t.toLowerCase()) }()) } writeValue(t) { this.setProperty("value", null == t ? "" : t) } _handleInput(t) { (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(t) } _compositionStart() { this._composing = !0 } _compositionEnd(t) { this._composing = !1, this._compositionMode && this.onChange(t) } } return t.\u0275fac = function (e) { return new (e || t)(bo(La), bo(Ma), bo(Lk, 8)) }, t.\u0275dir = Zt({ type: t, selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]], hostBindings: function (t, e) { 1 & t && Io("input", function (t) { return e._handleInput(t.target.value) })("blur", function () { return e.onTouched() })("compositionstart", function () { return e._compositionStart() })("compositionend", function (t) { return e._compositionEnd(t.target.value) }) }, features: [Ta([Fk]), so] }), t })(); const jk = new $n("NgValidators"), Bk = new $n("NgAsyncValidators"); function Hk(t) { return null != t } function Uk(t) { const e = Ao(t) ? F(t) : t; return Oo(e), e } function zk(t) { let e = {}; return t.forEach(t => { e = null != t ? Object.assign(Object.assign({}, e), t) : e }), 0 === Object.keys(e).length ? null : e } function $k(t, e) { return e.map(e => e(t)) } function qk(t) { return t.map(t => function (t) { return !t.validate }(t) ? t : e => t.validate(e)) } function Wk(t) { return null != t ? function (t) { if (!t) return null; const e = t.filter(Hk); return 0 == e.length ? null : function (t) { return zk($k(t, e)) } }(qk(t)) : null } function Kk(t) { return null != t ? function (t) { if (!t) return null; const e = t.filter(Hk); return 0 == e.length ? null : function (t) { return Ik($k(t, e).map(Uk)).pipe(E(zk)) } }(qk(t)) : null } function Yk(t, e) { return null === t ? [e] : Array.isArray(t) ? [...t, e] : [t, e] } function Zk(t) { return t._rawValidators } function Gk(t) { return t._rawAsyncValidators } let Qk = (() => { class t { constructor() { this._rawValidators = [], this._rawAsyncValidators = [], this._onDestroyCallbacks = [] } get value() { return this.control ? this.control.value : null } get valid() { return this.control ? this.control.valid : null } get invalid() { return this.control ? this.control.invalid : null } get pending() { return this.control ? this.control.pending : null } get disabled() { return this.control ? this.control.disabled : null } get enabled() { return this.control ? this.control.enabled : null } get errors() { return this.control ? this.control.errors : null } get pristine() { return this.control ? this.control.pristine : null } get dirty() { return this.control ? this.control.dirty : null } get touched() { return this.control ? this.control.touched : null } get status() { return this.control ? this.control.status : null } get untouched() { return this.control ? this.control.untouched : null } get statusChanges() { return this.control ? this.control.statusChanges : null } get valueChanges() { return this.control ? this.control.valueChanges : null } get path() { return null } _setValidators(t) { this._rawValidators = t || [], this._composedValidatorFn = Wk(this._rawValidators) } _setAsyncValidators(t) { this._rawAsyncValidators = t || [], this._composedAsyncValidatorFn = Kk(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn || null } get asyncValidator() { return this._composedAsyncValidatorFn || null } _registerOnDestroy(t) { this._onDestroyCallbacks.push(t) } _invokeOnDestroyCallbacks() { this._onDestroyCallbacks.forEach(t => t()), this._onDestroyCallbacks = [] } reset(t) { this.control && this.control.reset(t) } hasError(t, e) { return !!this.control && this.control.hasError(t, e) } getError(t, e) { return this.control ? this.control.getError(t, e) : null } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = Zt({ type: t }), t })(), Xk = (() => { class t extends Qk { get formDirective() { return null } get path() { return null } } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = jn(t)))(n || t) } }(), t.\u0275dir = Zt({ type: t, features: [so] }), t })(); class Jk extends Qk { constructor() { super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null } } class tx { constructor(t) { this._cd = t } is(t) { var e, n; return !!(null === (n = null === (e = this._cd) || void 0 === e ? void 0 : e.control) || void 0 === n ? void 0 : n[t]) } } let ex = (() => { class t extends tx { constructor(t) { super(t) } } return t.\u0275fac = function (e) { return new (e || t)(bo(Jk, 2)) }, t.\u0275dir = Zt({ type: t, selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]], hostVars: 14, hostBindings: function (t, e) { 2 & t && Ko("ng-untouched", e.is("untouched"))("ng-touched", e.is("touched"))("ng-pristine", e.is("pristine"))("ng-dirty", e.is("dirty"))("ng-valid", e.is("valid"))("ng-invalid", e.is("invalid"))("ng-pending", e.is("pending")) }, features: [so] }), t })(), nx = (() => { class t extends tx { constructor(t) { super(t) } } return t.\u0275fac = function (e) { return new (e || t)(bo(Xk, 10)) }, t.\u0275dir = Zt({ type: t, selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]], hostVars: 14, hostBindings: function (t, e) { 2 & t && Ko("ng-untouched", e.is("untouched"))("ng-touched", e.is("touched"))("ng-pristine", e.is("pristine"))("ng-dirty", e.is("dirty"))("ng-valid", e.is("valid"))("ng-invalid", e.is("invalid"))("ng-pending", e.is("pending")) }, features: [so] }), t })(); function ix(t, e) { ox(t, e), e.valueAccessor.writeValue(t.value), function (t, e) { e.valueAccessor.registerOnChange(n => { t._pendingValue = n, t._pendingChange = !0, t._pendingDirty = !0, "change" === t.updateOn && lx(t, e) }) }(t, e), function (t, e) { const n = (t, n) => { e.valueAccessor.writeValue(t), n && e.viewToModelUpdate(t) }; t.registerOnChange(n), e._registerOnDestroy(() => { t._unregisterOnChange(n) }) }(t, e), function (t, e) { e.valueAccessor.registerOnTouched(() => { t._pendingTouched = !0, "blur" === t.updateOn && t._pendingChange && lx(t, e), "submit" !== t.updateOn && t.markAsTouched() }) }(t, e), function (t, e) { if (e.valueAccessor.setDisabledState) { const n = t => { e.valueAccessor.setDisabledState(t) }; t.registerOnDisabledChange(n), e._registerOnDestroy(() => { t._unregisterOnDisabledChange(n) }) } }(t, e) } function sx(t, e, n = !0) { const i = () => { }; e.valueAccessor && (e.valueAccessor.registerOnChange(i), e.valueAccessor.registerOnTouched(i)), ax(t, e), t && (e._invokeOnDestroyCallbacks(), t._registerOnCollectionChange(() => { })) } function rx(t, e) { t.forEach(t => { t.registerOnValidatorChange && t.registerOnValidatorChange(e) }) } function ox(t, e) { const n = Zk(t); null !== e.validator ? t.setValidators(Yk(n, e.validator)) : "function" == typeof n && t.setValidators([n]); const i = Gk(t); null !== e.asyncValidator ? t.setAsyncValidators(Yk(i, e.asyncValidator)) : "function" == typeof i && t.setAsyncValidators([i]); const s = () => t.updateValueAndValidity(); rx(e._rawValidators, s), rx(e._rawAsyncValidators, s) } function ax(t, e) { let n = !1; if (null !== t) { if (null !== e.validator) { const i = Zk(t); if (Array.isArray(i) && i.length > 0) { const s = i.filter(t => t !== e.validator); s.length !== i.length && (n = !0, t.setValidators(s)) } } if (null !== e.asyncValidator) { const i = Gk(t); if (Array.isArray(i) && i.length > 0) { const s = i.filter(t => t !== e.asyncValidator); s.length !== i.length && (n = !0, t.setAsyncValidators(s)) } } } const i = () => { }; return rx(e._rawValidators, i), rx(e._rawAsyncValidators, i), n } function lx(t, e) { t._pendingDirty && t.markAsDirty(), t.setValue(t._pendingValue, { emitModelToViewChange: !1 }), e.viewToModelUpdate(t._pendingValue), t._pendingChange = !1 } function cx(t, e) { ox(t, e) } function hx(t, e) { t._syncPendingControls(), e.forEach(t => { const e = t.control; "submit" === e.updateOn && e._pendingChange && (t.viewToModelUpdate(e._pendingValue), e._pendingChange = !1) }) } function ux(t, e) { const n = t.indexOf(e); n > -1 && t.splice(n, 1) } const dx = "VALID", px = "INVALID", fx = "PENDING", mx = "DISABLED"; function gx(t) { return (vx(t) ? t.validators : t) || null } function _x(t) { return Array.isArray(t) ? Wk(t) : t || null } function yx(t, e) { return (vx(e) ? e.asyncValidators : t) || null } function bx(t) { return Array.isArray(t) ? Kk(t) : t || null } function vx(t) { return null != t && !Array.isArray(t) && "object" == typeof t } class wx { constructor(t, e) { this._hasOwnPendingAsyncValidator = !1, this._onCollectionChange = () => { }, this._parent = null, this.pristine = !0, this.touched = !1, this._onDisabledChange = [], this._rawValidators = t, this._rawAsyncValidators = e, this._composedValidatorFn = _x(this._rawValidators), this._composedAsyncValidatorFn = bx(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn } set validator(t) { this._rawValidators = this._composedValidatorFn = t } get asyncValidator() { return this._composedAsyncValidatorFn } set asyncValidator(t) { this._rawAsyncValidators = this._composedAsyncValidatorFn = t } get parent() { return this._parent } get valid() { return this.status === dx } get invalid() { return this.status === px } get pending() { return this.status == fx } get disabled() { return this.status === mx } get enabled() { return this.status !== mx } get dirty() { return !this.pristine } get untouched() { return !this.touched } get updateOn() { return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change" } setValidators(t) { this._rawValidators = t, this._composedValidatorFn = _x(t) } setAsyncValidators(t) { this._rawAsyncValidators = t, this._composedAsyncValidatorFn = bx(t) } clearValidators() { this.validator = null } clearAsyncValidators() { this.asyncValidator = null } markAsTouched(t = {}) { this.touched = !0, this._parent && !t.onlySelf && this._parent.markAsTouched(t) } markAllAsTouched() { this.markAsTouched({ onlySelf: !0 }), this._forEachChild(t => t.markAllAsTouched()) } markAsUntouched(t = {}) { this.touched = !1, this._pendingTouched = !1, this._forEachChild(t => { t.markAsUntouched({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updateTouched(t) } markAsDirty(t = {}) { this.pristine = !1, this._parent && !t.onlySelf && this._parent.markAsDirty(t) } markAsPristine(t = {}) { this.pristine = !0, this._pendingDirty = !1, this._forEachChild(t => { t.markAsPristine({ onlySelf: !0 }) }), this._parent && !t.onlySelf && this._parent._updatePristine(t) } markAsPending(t = {}) { this.status = fx, !1 !== t.emitEvent && this.statusChanges.emit(this.status), this._parent && !t.onlySelf && this._parent.markAsPending(t) } disable(t = {}) { const e = this._parentMarkedDirty(t.onlySelf); this.status = mx, this.errors = null, this._forEachChild(e => { e.disable(Object.assign(Object.assign({}, t), { onlySelf: !0 })) }), this._updateValue(), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors(Object.assign(Object.assign({}, t), { skipPristineCheck: e })), this._onDisabledChange.forEach(t => t(!0)) } enable(t = {}) { const e = this._parentMarkedDirty(t.onlySelf); this.status = dx, this._forEachChild(e => { e.enable(Object.assign(Object.assign({}, t), { onlySelf: !0 })) }), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }), this._updateAncestors(Object.assign(Object.assign({}, t), { skipPristineCheck: e })), this._onDisabledChange.forEach(t => t(!1)) } _updateAncestors(t) { this._parent && !t.onlySelf && (this._parent.updateValueAndValidity(t), t.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched()) } setParent(t) { this._parent = t } updateValueAndValidity(t = {}) { this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), this.status !== dx && this.status !== fx || this._runAsyncValidator(t.emitEvent)), !1 !== t.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !t.onlySelf && this._parent.updateValueAndValidity(t) } _updateTreeValidity(t = { emitEvent: !0 }) { this._forEachChild(e => e._updateTreeValidity(t)), this.updateValueAndValidity({ onlySelf: !0, emitEvent: t.emitEvent }) } _setInitialStatus() { this.status = this._allControlsDisabled() ? mx : dx } _runValidator() { return this.validator ? this.validator(this) : null } _runAsyncValidator(t) { if (this.asyncValidator) { this.status = fx, this._hasOwnPendingAsyncValidator = !0; const e = Uk(this.asyncValidator(this)); this._asyncValidationSubscription = e.subscribe(e => { this._hasOwnPendingAsyncValidator = !1, this.setErrors(e, { emitEvent: t }) }) } } _cancelExistingSubscription() { this._asyncValidationSubscription && (this._asyncValidationSubscription.unsubscribe(), this._hasOwnPendingAsyncValidator = !1) } setErrors(t, e = {}) { this.errors = t, this._updateControlsErrors(!1 !== e.emitEvent) } get(t) { return function (t, e, n) { if (null == e) return null; if (Array.isArray(e) || (e = e.split(".")), Array.isArray(e) && 0 === e.length) return null; let i = t; return e.forEach(t => { i = i instanceof kx ? i.controls.hasOwnProperty(t) ? i.controls[t] : null : i instanceof xx && i.at(t) || null }), i }(this, t) } getError(t, e) { const n = e ? this.get(e) : this; return n && n.errors ? n.errors[t] : null } hasError(t, e) { return !!this.getError(t, e) } get root() { let t = this; for (; t._parent;)t = t._parent; return t } _updateControlsErrors(t) { this.status = this._calculateStatus(), t && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(t) } _initObservables() { this.valueChanges = new Ml, this.statusChanges = new Ml } _calculateStatus() { return this._allControlsDisabled() ? mx : this.errors ? px : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(fx) ? fx : this._anyControlsHaveStatus(px) ? px : dx } _anyControlsHaveStatus(t) { return this._anyControls(e => e.status === t) } _anyControlsDirty() { return this._anyControls(t => t.dirty) } _anyControlsTouched() { return this._anyControls(t => t.touched) } _updatePristine(t = {}) { this.pristine = !this._anyControlsDirty(), this._parent && !t.onlySelf && this._parent._updatePristine(t) } _updateTouched(t = {}) { this.touched = this._anyControlsTouched(), this._parent && !t.onlySelf && this._parent._updateTouched(t) } _isBoxedValue(t) { return "object" == typeof t && null !== t && 2 === Object.keys(t).length && "value" in t && "disabled" in t } _registerOnCollectionChange(t) { this._onCollectionChange = t } _setUpdateStrategy(t) { vx(t) && null != t.updateOn && (this._updateOn = t.updateOn) } _parentMarkedDirty(t) { return !t && !(!this._parent || !this._parent.dirty) && !this._parent._anyControlsDirty() } } class Cx extends wx { constructor(t = null, e, n) { super(gx(e), yx(n, e)), this._onChange = [], this._applyFormState(t), this._setUpdateStrategy(e), this._initObservables(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!n }) } setValue(t, e = {}) { this.value = this._pendingValue = t, this._onChange.length && !1 !== e.emitModelToViewChange && this._onChange.forEach(t => t(this.value, !1 !== e.emitViewToModelChange)), this.updateValueAndValidity(e) } patchValue(t, e = {}) { this.setValue(t, e) } reset(t = null, e = {}) { this._applyFormState(t), this.markAsPristine(e), this.markAsUntouched(e), this.setValue(this.value, e), this._pendingChange = !1 } _updateValue() { } _anyControls(t) { return !1 } _allControlsDisabled() { return this.disabled } registerOnChange(t) { this._onChange.push(t) } _unregisterOnChange(t) { ux(this._onChange, t) } registerOnDisabledChange(t) { this._onDisabledChange.push(t) } _unregisterOnDisabledChange(t) { ux(this._onDisabledChange, t) } _forEachChild(t) { } _syncPendingControls() { return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange) || (this.setValue(this._pendingValue, { onlySelf: !0, emitModelToViewChange: !1 }), 0)) } _applyFormState(t) { this._isBoxedValue(t) ? (this.value = this._pendingValue = t.value, t.disabled ? this.disable({ onlySelf: !0, emitEvent: !1 }) : this.enable({ onlySelf: !0, emitEvent: !1 })) : this.value = this._pendingValue = t } } class kx extends wx { constructor(t, e, n) { super(gx(e), yx(n, e)), this.controls = t, this._initObservables(), this._setUpdateStrategy(e), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!n }) } registerControl(t, e) { return this.controls[t] ? this.controls[t] : (this.controls[t] = e, e.setParent(this), e._registerOnCollectionChange(this._onCollectionChange), e) } addControl(t, e, n = {}) { this.registerControl(t, e), this.updateValueAndValidity({ emitEvent: n.emitEvent }), this._onCollectionChange() } removeControl(t, e = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), delete this.controls[t], this.updateValueAndValidity({ emitEvent: e.emitEvent }), this._onCollectionChange() } setControl(t, e, n = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), delete this.controls[t], e && this.registerControl(t, e), this.updateValueAndValidity({ emitEvent: n.emitEvent }), this._onCollectionChange() } contains(t) { return this.controls.hasOwnProperty(t) && this.controls[t].enabled } setValue(t, e = {}) { this._checkAllValuesPresent(t), Object.keys(t).forEach(n => { this._throwIfControlMissing(n), this.controls[n].setValue(t[n], { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } patchValue(t, e = {}) { null != t && (Object.keys(t).forEach(n => { this.controls[n] && this.controls[n].patchValue(t[n], { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e)) } reset(t = {}, e = {}) { this._forEachChild((n, i) => { n.reset(t[i], { onlySelf: !0, emitEvent: e.emitEvent }) }), this._updatePristine(e), this._updateTouched(e), this.updateValueAndValidity(e) } getRawValue() { return this._reduceChildren({}, (t, e, n) => (t[n] = e instanceof Cx ? e.value : e.getRawValue(), t)) } _syncPendingControls() { let t = this._reduceChildren(!1, (t, e) => !!e._syncPendingControls() || t); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _throwIfControlMissing(t) { if (!Object.keys(this.controls).length) throw new Error("\n        There are no form controls registered with this group yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "); if (!this.controls[t]) throw new Error(`Cannot find form control with name: ${t}.`) } _forEachChild(t) { Object.keys(this.controls).forEach(e => { const n = this.controls[e]; n && t(n, e) }) } _setUpControls() { this._forEachChild(t => { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) }) } _updateValue() { this.value = this._reduceValue() } _anyControls(t) { for (const e of Object.keys(this.controls)) { const n = this.controls[e]; if (this.contains(e) && t(n)) return !0 } return !1 } _reduceValue() { return this._reduceChildren({}, (t, e, n) => ((e.enabled || this.disabled) && (t[n] = e.value), t)) } _reduceChildren(t, e) { let n = t; return this._forEachChild((t, i) => { n = e(n, t, i) }), n } _allControlsDisabled() { for (const t of Object.keys(this.controls)) if (this.controls[t].enabled) return !1; return Object.keys(this.controls).length > 0 || this.disabled } _checkAllValuesPresent(t) { this._forEachChild((e, n) => { if (void 0 === t[n]) throw new Error(`Must supply a value for form control with name: '${n}'.`) }) } } class xx extends wx { constructor(t, e, n) { super(gx(e), yx(n, e)), this.controls = t, this._initObservables(), this._setUpdateStrategy(e), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!n }) } at(t) { return this.controls[t] } push(t, e = {}) { this.controls.push(t), this._registerControl(t), this.updateValueAndValidity({ emitEvent: e.emitEvent }), this._onCollectionChange() } insert(t, e, n = {}) { this.controls.splice(t, 0, e), this._registerControl(e), this.updateValueAndValidity({ emitEvent: n.emitEvent }) } removeAt(t, e = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), this.controls.splice(t, 1), this.updateValueAndValidity({ emitEvent: e.emitEvent }) } setControl(t, e, n = {}) { this.controls[t] && this.controls[t]._registerOnCollectionChange(() => { }), this.controls.splice(t, 1), e && (this.controls.splice(t, 0, e), this._registerControl(e)), this.updateValueAndValidity({ emitEvent: n.emitEvent }), this._onCollectionChange() } get length() { return this.controls.length } setValue(t, e = {}) { this._checkAllValuesPresent(t), t.forEach((t, n) => { this._throwIfControlMissing(n), this.at(n).setValue(t, { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e) } patchValue(t, e = {}) { null != t && (t.forEach((t, n) => { this.at(n) && this.at(n).patchValue(t, { onlySelf: !0, emitEvent: e.emitEvent }) }), this.updateValueAndValidity(e)) } reset(t = [], e = {}) { this._forEachChild((n, i) => { n.reset(t[i], { onlySelf: !0, emitEvent: e.emitEvent }) }), this._updatePristine(e), this._updateTouched(e), this.updateValueAndValidity(e) } getRawValue() { return this.controls.map(t => t instanceof Cx ? t.value : t.getRawValue()) } clear(t = {}) { this.controls.length < 1 || (this._forEachChild(t => t._registerOnCollectionChange(() => { })), this.controls.splice(0), this.updateValueAndValidity({ emitEvent: t.emitEvent })) } _syncPendingControls() { let t = this.controls.reduce((t, e) => !!e._syncPendingControls() || t, !1); return t && this.updateValueAndValidity({ onlySelf: !0 }), t } _throwIfControlMissing(t) { if (!this.controls.length) throw new Error("\n        There are no form controls registered with this array yet. If you're using ngModel,\n        you may want to check next tick (e.g. use setTimeout).\n      "); if (!this.at(t)) throw new Error(`Cannot find form control at index ${t}`) } _forEachChild(t) { this.controls.forEach((e, n) => { t(e, n) }) } _updateValue() { this.value = this.controls.filter(t => t.enabled || this.disabled).map(t => t.value) } _anyControls(t) { return this.controls.some(e => e.enabled && t(e)) } _setUpControls() { this._forEachChild(t => this._registerControl(t)) } _checkAllValuesPresent(t) { this._forEachChild((e, n) => { if (void 0 === t[n]) throw new Error(`Must supply a value for form control at index: ${n}.`) }) } _allControlsDisabled() { for (const t of this.controls) if (t.enabled) return !1; return this.controls.length > 0 || this.disabled } _registerControl(t) { t.setParent(this), t._registerOnCollectionChange(this._onCollectionChange) } } const Sx = { provide: Xk, useExisting: rt(() => Tx) }, Ex = (() => Promise.resolve(null))(); let Tx = (() => { class t extends Xk { constructor(t, e) { super(), this.submitted = !1, this._directives = [], this.ngSubmit = new Ml, this.form = new kx({}, Wk(t), Kk(e)) } ngAfterViewInit() { this._setUpdateStrategy() } get formDirective() { return this } get control() { return this.form } get path() { return [] } get controls() { return this.form.controls } addControl(t) { Ex.then(() => { const e = this._findContainer(t.path); t.control = e.registerControl(t.name, t.control), ix(t.control, t), t.control.updateValueAndValidity({ emitEvent: !1 }), this._directives.push(t) }) } getControl(t) { return this.form.get(t.path) } removeControl(t) { Ex.then(() => { const e = this._findContainer(t.path); e && e.removeControl(t.name), ux(this._directives, t) }) } addFormGroup(t) { Ex.then(() => { const e = this._findContainer(t.path), n = new kx({}); cx(n, t), e.registerControl(t.name, n), n.updateValueAndValidity({ emitEvent: !1 }) }) } removeFormGroup(t) { Ex.then(() => { const e = this._findContainer(t.path); e && e.removeControl(t.name) }) } getFormGroup(t) { return this.form.get(t.path) } updateModel(t, e) { Ex.then(() => { this.form.get(t.path).setValue(e) }) } setValue(t) { this.control.setValue(t) } onSubmit(t) { return this.submitted = !0, hx(this.form, this._directives), this.ngSubmit.emit(t), !1 } onReset() { this.resetForm() } resetForm(t) { this.form.reset(t), this.submitted = !1 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.form._updateOn = this.options.updateOn) } _findContainer(t) { return t.pop(), t.length ? this.form.get(t) : this.form } } return t.\u0275fac = function (e) { return new (e || t)(bo(jk, 10), bo(Bk, 10)) }, t.\u0275dir = Zt({ type: t, selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]], hostBindings: function (t, e) { 1 & t && Io("submit", function (t) { return e.onSubmit(t) })("reset", function () { return e.onReset() }) }, inputs: { options: ["ngFormOptions", "options"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [Ta([Sx]), so] }), t })(); const Rx = { provide: Jk, useExisting: rt(() => Ox) }, Ax = (() => Promise.resolve(null))(); let Ox = (() => { class t extends Jk { constructor(t, e, n, i) { super(), this.control = new Cx, this._registered = !1, this.update = new Ml, this._parent = t, this._setValidators(e), this._setAsyncValidators(n), this.valueAccessor = function (t, e) { if (!e) return null; let n, i, s; return Array.isArray(e), e.forEach(t => { t.constructor === Vk ? n = t : Object.getPrototypeOf(t.constructor) === Mk ? i = t : s = t }), s || i || n || null }(0, i) } ngOnChanges(t) { this._checkForErrors(), this._registered || this._setUpControl(), "isDisabled" in t && this._updateDisabled(t), function (t, e) { if (!t.hasOwnProperty("model")) return !1; const n = t.model; return !!n.isFirstChange() || !Object.is(e, n.currentValue) }(t, this.viewModel) && (this._updateValue(this.model), this.viewModel = this.model) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } get path() { return this._parent ? [...this._parent.path, this.name] : [this.name] } get formDirective() { return this._parent ? this._parent.formDirective : null } viewToModelUpdate(t) { this.viewModel = t, this.update.emit(t) } _setUpControl() { this._setUpdateStrategy(), this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this), this._registered = !0 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.control._updateOn = this.options.updateOn) } _isStandalone() { return !this._parent || !(!this.options || !this.options.standalone) } _setUpStandalone() { ix(this.control, this), this.control.updateValueAndValidity({ emitEvent: !1 }) } _checkForErrors() { this._isStandalone() || this._checkParentType(), this._checkName() } _checkParentType() { } _checkName() { this.options && this.options.name && (this.name = this.options.name), this._isStandalone() } _updateValue(t) { Ax.then(() => { this.control.setValue(t, { emitViewToModelChange: !1 }) }) } _updateDisabled(t) { const e = t.isDisabled.currentValue, n = "" === e || e && "false" !== e; Ax.then(() => { n && !this.control.disabled ? this.control.disable() : !n && this.control.disabled && this.control.enable() }) } } return t.\u0275fac = function (e) { return new (e || t)(bo(Xk, 9), bo(jk, 10), bo(Bk, 10), bo(Nk, 10)) }, t.\u0275dir = Zt({ type: t, selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]], inputs: { name: "name", isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"], options: ["ngModelOptions", "options"] }, outputs: { update: "ngModelChange" }, exportAs: ["ngModel"], features: [Ta([Rx]), so, le] }), t })(), Ix = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = Zt({ type: t, selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]], hostAttrs: ["novalidate", ""] }), t })(), Dx = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({}), t })(); const Px = new $n("NgModelWithFormControlWarning"), Mx = { provide: Xk, useExisting: rt(() => Nx) }; let Nx = (() => { class t extends Xk { constructor(t, e) { super(), this.validators = t, this.asyncValidators = e, this.submitted = !1, this._onCollectionChange = () => this._updateDomValue(), this.directives = [], this.form = null, this.ngSubmit = new Ml, this._setValidators(t), this._setAsyncValidators(e) } ngOnChanges(t) { this._checkFormPresent(), t.hasOwnProperty("form") && (this._updateValidators(), this._updateDomValue(), this._updateRegistrations(), this._oldForm = this.form) } ngOnDestroy() { this.form && (ax(this.form, this), this.form._onCollectionChange === this._onCollectionChange && this.form._registerOnCollectionChange(() => { })) } get formDirective() { return this } get control() { return this.form } get path() { return [] } addControl(t) { const e = this.form.get(t.path); return ix(e, t), e.updateValueAndValidity({ emitEvent: !1 }), this.directives.push(t), e } getControl(t) { return this.form.get(t.path) } removeControl(t) { sx(t.control || null, t, !1), ux(this.directives, t) } addFormGroup(t) { this._setUpFormContainer(t) } removeFormGroup(t) { this._cleanUpFormContainer(t) } getFormGroup(t) { return this.form.get(t.path) } addFormArray(t) { this._setUpFormContainer(t) } removeFormArray(t) { this._cleanUpFormContainer(t) } getFormArray(t) { return this.form.get(t.path) } updateModel(t, e) { this.form.get(t.path).setValue(e) } onSubmit(t) { return this.submitted = !0, hx(this.form, this.directives), this.ngSubmit.emit(t), !1 } onReset() { this.resetForm() } resetForm(t) { this.form.reset(t), this.submitted = !1 } _updateDomValue() { this.directives.forEach(t => { const e = t.control, n = this.form.get(t.path); e !== n && (sx(e || null, t), n instanceof Cx && (ix(n, t), t.control = n)) }), this.form._updateTreeValidity({ emitEvent: !1 }) } _setUpFormContainer(t) { const e = this.form.get(t.path); cx(e, t), e.updateValueAndValidity({ emitEvent: !1 }) } _cleanUpFormContainer(t) { if (this.form) { const e = this.form.get(t.path); e && function (t, e) { return ax(t, e) }(e, t) && e.updateValueAndValidity({ emitEvent: !1 }) } } _updateRegistrations() { this.form._registerOnCollectionChange(this._onCollectionChange), this._oldForm && this._oldForm._registerOnCollectionChange(() => { }) } _updateValidators() { ox(this.form, this), this._oldForm && ax(this._oldForm, this) } _checkFormPresent() { } } return t.\u0275fac = function (e) { return new (e || t)(bo(jk, 10), bo(Bk, 10)) }, t.\u0275dir = Zt({ type: t, selectors: [["", "formGroup", ""]], hostBindings: function (t, e) { 1 & t && Io("submit", function (t) { return e.onSubmit(t) })("reset", function () { return e.onReset() }) }, inputs: { form: ["formGroup", "form"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [Ta([Mx]), so, le] }), t })(); const Fx = { provide: jk, useExisting: rt(() => Lx), multi: !0 }; let Lx = (() => { class t { constructor() { this._required = !1 } get required() { return this._required } set required(t) { this._required = null != t && !1 !== t && "false" != `${t}`, this._onChange && this._onChange() } validate(t) { return this.required ? function (t) { return null == (e = t.value) || 0 === e.length ? { required: !0 } : null; var e }(t) : null } registerOnValidatorChange(t) { this._onChange = t } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = Zt({ type: t, selectors: [["", "required", "", "formControlName", "", 3, "type", "checkbox"], ["", "required", "", "formControl", "", 3, "type", "checkbox"], ["", "required", "", "ngModel", "", 3, "type", "checkbox"]], hostVars: 1, hostBindings: function (t, e) { 2 & t && mo("required", e.required ? "" : null) }, inputs: { required: "required" }, features: [Ta([Fx])] }), t })(), Vx = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ imports: [[Dx]] }), t })(), jx = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ imports: [Vx] }), t })(), Bx = (() => { class t { static withConfig(e) { return { ngModule: t, providers: [{ provide: Px, useValue: e.warnOnNgModelWithFormControl }] } } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ imports: [Vx] }), t })(); const Hx = ["underline"], Ux = ["connectionContainer"], zx = ["inputContainer"], $x = ["label"]; function qx(t, e) { 1 & t && (So(0), Co(1, "div", 14), xo(2, "div", 15), xo(3, "div", 16), xo(4, "div", 17), ko(), Co(5, "div", 18), xo(6, "div", 15), xo(7, "div", 16), xo(8, "div", 17), ko(), Eo()) } function Wx(t, e) { 1 & t && (Co(0, "div", 19), jo(1, 1), ko()) } function Kx(t, e) { if (1 & t && (So(0), jo(1, 2), Co(2, "span"), ra(3), ko(), Eo()), 2 & t) { const t = Fo(2); qs(3), oa(t._control.placeholder) } } function Yx(t, e) { 1 & t && jo(0, 3, ["*ngSwitchCase", "true"]) } function Zx(t, e) { 1 & t && (Co(0, "span", 23), ra(1, " *"), ko()) } function Gx(t, e) { if (1 & t) { const t = Ro(); Co(0, "label", 20, 21), Io("cdkObserveContent", function () { return Ie(t), Fo().updateOutlineGap() }), _o(2, Kx, 4, 1, "ng-container", 12), _o(3, Yx, 1, 0, "ng-content", 12), _o(4, Zx, 2, 0, "span", 22), ko() } if (2 & t) { const t = Fo(); Ko("mat-empty", t._control.empty && !t._shouldAlwaysFloat())("mat-form-field-empty", t._control.empty && !t._shouldAlwaysFloat())("mat-accent", "accent" == t.color)("mat-warn", "warn" == t.color), vo("cdkObserveContentDisabled", "outline" != t.appearance)("id", t._labelId)("ngSwitch", t._hasLabel()), mo("for", t._control.id)("aria-owns", t._control.id), qs(2), vo("ngSwitchCase", !1), qs(1), vo("ngSwitchCase", !0), qs(1), vo("ngIf", !t.hideRequiredMarker && t._control.required && !t._control.disabled) } } function Qx(t, e) { 1 & t && (Co(0, "div", 24), jo(1, 4), ko()) } function Xx(t, e) { if (1 & t && (Co(0, "div", 25, 26), xo(2, "span", 27), ko()), 2 & t) { const t = Fo(); qs(2), Ko("mat-accent", "accent" == t.color)("mat-warn", "warn" == t.color) } } function Jx(t, e) { 1 & t && (Co(0, "div"), jo(1, 5), ko()), 2 & t && vo("@transitionMessages", Fo()._subscriptAnimationState) } function tS(t, e) { if (1 & t && (Co(0, "div", 31), ra(1), ko()), 2 & t) { const t = Fo(2); vo("id", t._hintLabelId), qs(1), oa(t.hintLabel) } } function eS(t, e) { if (1 & t && (Co(0, "div", 28), _o(1, tS, 2, 2, "div", 29), jo(2, 6), xo(3, "div", 30), jo(4, 7), ko()), 2 & t) { const t = Fo(); vo("@transitionMessages", t._subscriptAnimationState), qs(1), vo("ngIf", t.hintLabel) } } const nS = ["*", [["", "matPrefix", ""]], [["mat-placeholder"]], [["mat-label"]], [["", "matSuffix", ""]], [["mat-error"]], [["mat-hint", 3, "align", "end"]], [["mat-hint", "align", "end"]]], iS = ["*", "[matPrefix]", "mat-placeholder", "mat-label", "[matSuffix]", "mat-error", "mat-hint:not([align='end'])", "mat-hint[align='end']"]; let sS = 0; const rS = new $n("MatError"); let oS = (() => { class t { constructor(t, e) { this.id = "mat-error-" + sS++, t || e.nativeElement.setAttribute("aria-live", "polite") } } return t.\u0275fac = function (e) { return new (e || t)(Hn("aria-live"), bo(Ma)) }, t.\u0275dir = Zt({ type: t, selectors: [["mat-error"]], hostAttrs: ["aria-atomic", "true", 1, "mat-error"], hostVars: 1, hostBindings: function (t, e) { 2 & t && mo("id", e.id) }, inputs: { id: "id" }, features: [Ta([{ provide: rS, useExisting: t }])] }), t })(); const aS = { transitionMessages: g_("transitionMessages", [v_("enter", b_({ opacity: 1, transform: "translateY(0%)" })), w_("void => enter", [b_({ opacity: 0, transform: "translateY(-5px)" }), __("300ms cubic-bezier(0.55, 0, 0.55, 0.2)")])]) }; let lS = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = Zt({ type: t }), t })(); const cS = new $n("MatHint"); let hS = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = Zt({ type: t, selectors: [["mat-label"]] }), t })(), uS = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = Zt({ type: t, selectors: [["mat-placeholder"]] }), t })(); const dS = new $n("MatPrefix"), pS = new $n("MatSuffix"); let fS = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = Zt({ type: t, selectors: [["", "matSuffix", ""]], features: [Ta([{ provide: pS, useExisting: t }])] }), t })(), mS = 0; class gS { constructor(t) { this._elementRef = t } } const _S = hv(gS, "primary"), yS = new $n("MAT_FORM_FIELD_DEFAULT_OPTIONS"), bS = new $n("MatFormField"); let vS = (() => { class t extends _S { constructor(t, e, n, i, s, r, o, a) { super(t), this._elementRef = t, this._changeDetectorRef = e, this._dir = i, this._defaults = s, this._platform = r, this._ngZone = o, this._outlineGapCalculationNeededImmediately = !1, this._outlineGapCalculationNeededOnStable = !1, this._destroyed = new k, this._showAlwaysAnimate = !1, this._subscriptAnimationState = "", this._hintLabel = "", this._hintLabelId = "mat-hint-" + mS++, this._labelId = "mat-form-field-label-" + mS++, this.floatLabel = this._getDefaultFloatLabelState(), this._animationsEnabled = "NoopAnimations" !== a, this.appearance = s && s.appearance ? s.appearance : "legacy", this._hideRequiredMarker = !(!s || null == s.hideRequiredMarker) && s.hideRequiredMarker } get appearance() { return this._appearance } set appearance(t) { const e = this._appearance; this._appearance = t || this._defaults && this._defaults.appearance || "legacy", "outline" === this._appearance && e !== t && (this._outlineGapCalculationNeededOnStable = !0) } get hideRequiredMarker() { return this._hideRequiredMarker } set hideRequiredMarker(t) { this._hideRequiredMarker = lm(t) } _shouldAlwaysFloat() { return "always" === this.floatLabel && !this._showAlwaysAnimate } _canLabelFloat() { return "never" !== this.floatLabel } get hintLabel() { return this._hintLabel } set hintLabel(t) { this._hintLabel = t, this._processHints() } get floatLabel() { return "legacy" !== this.appearance && "never" === this._floatLabel ? "auto" : this._floatLabel } set floatLabel(t) { t !== this._floatLabel && (this._floatLabel = t || this._getDefaultFloatLabelState(), this._changeDetectorRef.markForCheck()) } get _control() { return this._explicitFormFieldControl || this._controlNonStatic || this._controlStatic } set _control(t) { this._explicitFormFieldControl = t } getLabelId() { return this._hasFloatingLabel() ? this._labelId : null } getConnectedOverlayOrigin() { return this._connectionContainerRef || this._elementRef } ngAfterContentInit() { this._validateControlChild(); const t = this._control; t.controlType && this._elementRef.nativeElement.classList.add(`mat-form-field-type-${t.controlType}`), t.stateChanges.pipe(Mu(null)).subscribe(() => { this._validatePlaceholders(), this._syncDescribedByIds(), this._changeDetectorRef.markForCheck() }), t.ngControl && t.ngControl.valueChanges && t.ngControl.valueChanges.pipe(Km(this._destroyed)).subscribe(() => this._changeDetectorRef.markForCheck()), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.pipe(Km(this._destroyed)).subscribe(() => { this._outlineGapCalculationNeededOnStable && this.updateOutlineGap() }) }), q(this._prefixChildren.changes, this._suffixChildren.changes).subscribe(() => { this._outlineGapCalculationNeededOnStable = !0, this._changeDetectorRef.markForCheck() }), this._hintChildren.changes.pipe(Mu(null)).subscribe(() => { this._processHints(), this._changeDetectorRef.markForCheck() }), this._errorChildren.changes.pipe(Mu(null)).subscribe(() => { this._syncDescribedByIds(), this._changeDetectorRef.markForCheck() }), this._dir && this._dir.change.pipe(Km(this._destroyed)).subscribe(() => { "function" == typeof requestAnimationFrame ? this._ngZone.runOutsideAngular(() => { requestAnimationFrame(() => this.updateOutlineGap()) }) : this.updateOutlineGap() }) } ngAfterContentChecked() { this._validateControlChild(), this._outlineGapCalculationNeededImmediately && this.updateOutlineGap() } ngAfterViewInit() { this._subscriptAnimationState = "enter", this._changeDetectorRef.detectChanges() } ngOnDestroy() { this._destroyed.next(), this._destroyed.complete() } _shouldForward(t) { const e = this._control ? this._control.ngControl : null; return e && e[t] } _hasPlaceholder() { return !!(this._control && this._control.placeholder || this._placeholderChild) } _hasLabel() { return !(!this._labelChildNonStatic && !this._labelChildStatic) } _shouldLabelFloat() { return this._canLabelFloat() && (this._control && this._control.shouldLabelFloat || this._shouldAlwaysFloat()) } _hideControlPlaceholder() { return "legacy" === this.appearance && !this._hasLabel() || this._hasLabel() && !this._shouldLabelFloat() } _hasFloatingLabel() { return this._hasLabel() || "legacy" === this.appearance && this._hasPlaceholder() } _getDisplayedMessages() { return this._errorChildren && this._errorChildren.length > 0 && this._control.errorState ? "error" : "hint" } _animateAndLockLabel() { this._hasFloatingLabel() && this._canLabelFloat() && (this._animationsEnabled && this._label && (this._showAlwaysAnimate = !0, Pm(this._label.nativeElement, "transitionend").pipe(Iu(1)).subscribe(() => { this._showAlwaysAnimate = !1 })), this.floatLabel = "always", this._changeDetectorRef.markForCheck()) } _validatePlaceholders() { } _processHints() { this._validateHints(), this._syncDescribedByIds() } _validateHints() { } _getDefaultFloatLabelState() { return this._defaults && this._defaults.floatLabel || "auto" } _syncDescribedByIds() { if (this._control) { let t = []; if (this._control.userAriaDescribedBy && "string" == typeof this._control.userAriaDescribedBy && t.push(...this._control.userAriaDescribedBy.split(" ")), "hint" === this._getDisplayedMessages()) { const e = this._hintChildren ? this._hintChildren.find(t => "start" === t.align) : null, n = this._hintChildren ? this._hintChildren.find(t => "end" === t.align) : null; e ? t.push(e.id) : this._hintLabel && t.push(this._hintLabelId), n && t.push(n.id) } else this._errorChildren && t.push(...this._errorChildren.map(t => t.id)); this._control.setDescribedByIds(t) } } _validateControlChild() { } updateOutlineGap() { const t = this._label ? this._label.nativeElement : null; if ("outline" !== this.appearance || !t || !t.children.length || !t.textContent.trim()) return; if (!this._platform.isBrowser) return; if (!this._isAttachedToDOM()) return void (this._outlineGapCalculationNeededImmediately = !0); let e = 0, n = 0; const i = this._connectionContainerRef.nativeElement, s = i.querySelectorAll(".mat-form-field-outline-start"), r = i.querySelectorAll(".mat-form-field-outline-gap"); if (this._label && this._label.nativeElement.children.length) { const s = i.getBoundingClientRect(); if (0 === s.width && 0 === s.height) return this._outlineGapCalculationNeededOnStable = !0, void (this._outlineGapCalculationNeededImmediately = !1); const r = this._getStartEnd(s), o = t.children, a = this._getStartEnd(o[0].getBoundingClientRect()); let l = 0; for (let t = 0; t < o.length; t++)l += o[t].offsetWidth; e = Math.abs(a - r) - 5, n = l > 0 ? .75 * l + 10 : 0 } for (let o = 0; o < s.length; o++)s[o].style.width = `${e}px`; for (let o = 0; o < r.length; o++)r[o].style.width = `${n}px`; this._outlineGapCalculationNeededOnStable = this._outlineGapCalculationNeededImmediately = !1 } _getStartEnd(t) { return this._dir && "rtl" === this._dir.value ? t.right : t.left } _isAttachedToDOM() { const t = this._elementRef.nativeElement; if (t.getRootNode) { const e = t.getRootNode(); return e && e !== t } return document.documentElement.contains(t) } } return t.\u0275fac = function (e) { return new (e || t)(bo(Ma), bo(ol), bo(Ma), bo(vm, 8), bo(yS, 8), bo(km), bo(vc), bo(Xb, 8)) }, t.\u0275cmp = zt({ type: t, selectors: [["mat-form-field"]], contentQueries: function (t, e, n) { if (1 & t && (Yl(n, lS, 5), Yl(n, lS, 7), Yl(n, hS, 5), Yl(n, hS, 7), Yl(n, uS, 5), Yl(n, rS, 5), Yl(n, cS, 5), Yl(n, dS, 5), Yl(n, pS, 5)), 2 & t) { let t; Wl(t = Zl()) && (e._controlNonStatic = t.first), Wl(t = Zl()) && (e._controlStatic = t.first), Wl(t = Zl()) && (e._labelChildNonStatic = t.first), Wl(t = Zl()) && (e._labelChildStatic = t.first), Wl(t = Zl()) && (e._placeholderChild = t.first), Wl(t = Zl()) && (e._errorChildren = t), Wl(t = Zl()) && (e._hintChildren = t), Wl(t = Zl()) && (e._prefixChildren = t), Wl(t = Zl()) && (e._suffixChildren = t) } }, viewQuery: function (t, e) { if (1 & t && (Kl(Hx, 5), Kl(Ux, 7), Kl(zx, 5), Kl($x, 5)), 2 & t) { let t; Wl(t = Zl()) && (e.underlineRef = t.first), Wl(t = Zl()) && (e._connectionContainerRef = t.first), Wl(t = Zl()) && (e._inputContainerRef = t.first), Wl(t = Zl()) && (e._label = t.first) } }, hostAttrs: [1, "mat-form-field"], hostVars: 40, hostBindings: function (t, e) { 2 & t && Ko("mat-form-field-appearance-standard", "standard" == e.appearance)("mat-form-field-appearance-fill", "fill" == e.appearance)("mat-form-field-appearance-outline", "outline" == e.appearance)("mat-form-field-appearance-legacy", "legacy" == e.appearance)("mat-form-field-invalid", e._control.errorState)("mat-form-field-can-float", e._canLabelFloat())("mat-form-field-should-float", e._shouldLabelFloat())("mat-form-field-has-label", e._hasFloatingLabel())("mat-form-field-hide-placeholder", e._hideControlPlaceholder())("mat-form-field-disabled", e._control.disabled)("mat-form-field-autofilled", e._control.autofilled)("mat-focused", e._control.focused)("ng-untouched", e._shouldForward("untouched"))("ng-touched", e._shouldForward("touched"))("ng-pristine", e._shouldForward("pristine"))("ng-dirty", e._shouldForward("dirty"))("ng-valid", e._shouldForward("valid"))("ng-invalid", e._shouldForward("invalid"))("ng-pending", e._shouldForward("pending"))("_mat-animation-noopable", !e._animationsEnabled) }, inputs: { color: "color", floatLabel: "floatLabel", appearance: "appearance", hideRequiredMarker: "hideRequiredMarker", hintLabel: "hintLabel" }, exportAs: ["matFormField"], features: [Ta([{ provide: bS, useExisting: t }]), so], ngContentSelectors: iS, decls: 15, vars: 8, consts: [[1, "mat-form-field-wrapper"], [1, "mat-form-field-flex", 3, "click"], ["connectionContainer", ""], [4, "ngIf"], ["class", "mat-form-field-prefix", 4, "ngIf"], [1, "mat-form-field-infix"], ["inputContainer", ""], [1, "mat-form-field-label-wrapper"], ["class", "mat-form-field-label", 3, "cdkObserveContentDisabled", "id", "mat-empty", "mat-form-field-empty", "mat-accent", "mat-warn", "ngSwitch", "cdkObserveContent", 4, "ngIf"], ["class", "mat-form-field-suffix", 4, "ngIf"], ["class", "mat-form-field-underline", 4, "ngIf"], [1, "mat-form-field-subscript-wrapper", 3, "ngSwitch"], [4, "ngSwitchCase"], ["class", "mat-form-field-hint-wrapper", 4, "ngSwitchCase"], [1, "mat-form-field-outline"], [1, "mat-form-field-outline-start"], [1, "mat-form-field-outline-gap"], [1, "mat-form-field-outline-end"], [1, "mat-form-field-outline", "mat-form-field-outline-thick"], [1, "mat-form-field-prefix"], [1, "mat-form-field-label", 3, "cdkObserveContentDisabled", "id", "ngSwitch", "cdkObserveContent"], ["label", ""], ["class", "mat-placeholder-required mat-form-field-required-marker", "aria-hidden", "true", 4, "ngIf"], ["aria-hidden", "true", 1, "mat-placeholder-required", "mat-form-field-required-marker"], [1, "mat-form-field-suffix"], [1, "mat-form-field-underline"], ["underline", ""], [1, "mat-form-field-ripple"], [1, "mat-form-field-hint-wrapper"], ["class", "mat-hint", 3, "id", 4, "ngIf"], [1, "mat-form-field-hint-spacer"], [1, "mat-hint", 3, "id"]], template: function (t, e) { 1 & t && (Vo(nS), Co(0, "div", 0), Co(1, "div", 1, 2), Io("click", function (t) { return e._control.onContainerClick && e._control.onContainerClick(t) }), _o(3, qx, 9, 0, "ng-container", 3), _o(4, Wx, 2, 0, "div", 4), Co(5, "div", 5, 6), jo(7), Co(8, "span", 7), _o(9, Gx, 5, 16, "label", 8), ko(), ko(), _o(10, Qx, 2, 0, "div", 9), ko(), _o(11, Xx, 3, 4, "div", 10), Co(12, "div", 11), _o(13, Jx, 2, 1, "div", 12), _o(14, eS, 5, 2, "div", 13), ko(), ko()), 2 & t && (qs(3), vo("ngIf", "outline" == e.appearance), qs(1), vo("ngIf", e._prefixChildren.length), qs(5), vo("ngIf", e._hasFloatingLabel()), qs(1), vo("ngIf", e._suffixChildren.length), qs(1), vo("ngIf", "outline" != e.appearance), qs(1), vo("ngSwitch", e._getDisplayedMessages()), qs(1), vo("ngSwitchCase", "error"), qs(1), vo("ngSwitchCase", "hint")) }, directives: [Ch, Eh, Th, qg], styles: [".mat-form-field{display:inline-block;position:relative;text-align:left}[dir=rtl] .mat-form-field{text-align:right}.mat-form-field-wrapper{position:relative}.mat-form-field-flex{display:inline-flex;align-items:baseline;box-sizing:border-box;width:100%}.mat-form-field-prefix,.mat-form-field-suffix{white-space:nowrap;flex:none;position:relative}.mat-form-field-infix{display:block;position:relative;flex:auto;min-width:0;width:180px}.cdk-high-contrast-active .mat-form-field-infix{border-image:linear-gradient(transparent, transparent)}.mat-form-field-label-wrapper{position:absolute;left:0;box-sizing:content-box;width:100%;height:100%;overflow:hidden;pointer-events:none}[dir=rtl] .mat-form-field-label-wrapper{left:auto;right:0}.mat-form-field-label{position:absolute;left:0;font:inherit;pointer-events:none;width:100%;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;transform-origin:0 0;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),color 400ms cubic-bezier(0.25, 0.8, 0.25, 1),width 400ms cubic-bezier(0.25, 0.8, 0.25, 1);display:none}[dir=rtl] .mat-form-field-label{transform-origin:100% 0;left:auto;right:0}.mat-form-field-empty.mat-form-field-label,.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label{display:block}.mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:block;transition:none}.mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-form-field-can-float .mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:block}.mat-form-field-label:not(.mat-form-field-empty){transition:none}.mat-form-field-underline{position:absolute;width:100%;pointer-events:none;transform:scale3d(1, 1.0001, 1)}.mat-form-field-ripple{position:absolute;left:0;width:100%;transform-origin:50%;transform:scaleX(0.5);opacity:0;transition:background-color 300ms cubic-bezier(0.55, 0, 0.55, 0.2)}.mat-form-field.mat-focused .mat-form-field-ripple,.mat-form-field.mat-form-field-invalid .mat-form-field-ripple{opacity:1;transform:none;transition:transform 300ms cubic-bezier(0.25, 0.8, 0.25, 1),opacity 100ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 300ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-subscript-wrapper{position:absolute;box-sizing:border-box;width:100%;overflow:hidden}.mat-form-field-subscript-wrapper .mat-icon,.mat-form-field-label-wrapper .mat-icon{width:1em;height:1em;font-size:inherit;vertical-align:baseline}.mat-form-field-hint-wrapper{display:flex}.mat-form-field-hint-spacer{flex:1 0 1em}.mat-error{display:block}.mat-form-field-control-wrapper{position:relative}.mat-form-field-hint-end{order:1}.mat-form-field._mat-animation-noopable .mat-form-field-label,.mat-form-field._mat-animation-noopable .mat-form-field-ripple{transition:none}\n", '.mat-form-field-appearance-fill .mat-form-field-flex{border-radius:4px 4px 0 0;padding:.75em .75em 0 .75em}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-form-field-flex{outline:solid 1px}.mat-form-field-appearance-fill .mat-form-field-underline::before{content:"";display:block;position:absolute;bottom:0;height:1px;width:100%}.mat-form-field-appearance-fill .mat-form-field-ripple{bottom:0;height:2px}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-fill:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-fill._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}.mat-form-field-appearance-fill .mat-form-field-subscript-wrapper{padding:0 1em}\n', '.mat-input-element{font:inherit;background:transparent;color:currentColor;border:none;outline:none;padding:0;margin:0;width:100%;max-width:100%;vertical-align:bottom;text-align:inherit;box-sizing:content-box}.mat-input-element:-moz-ui-invalid{box-shadow:none}.mat-input-element::-ms-clear,.mat-input-element::-ms-reveal{display:none}.mat-input-element,.mat-input-element::-webkit-search-cancel-button,.mat-input-element::-webkit-search-decoration,.mat-input-element::-webkit-search-results-button,.mat-input-element::-webkit-search-results-decoration{-webkit-appearance:none}.mat-input-element::-webkit-contacts-auto-fill-button,.mat-input-element::-webkit-caps-lock-indicator,.mat-input-element::-webkit-credentials-auto-fill-button{visibility:hidden}.mat-input-element[type=date],.mat-input-element[type=datetime],.mat-input-element[type=datetime-local],.mat-input-element[type=month],.mat-input-element[type=week],.mat-input-element[type=time]{line-height:1}.mat-input-element[type=date]::after,.mat-input-element[type=datetime]::after,.mat-input-element[type=datetime-local]::after,.mat-input-element[type=month]::after,.mat-input-element[type=week]::after,.mat-input-element[type=time]::after{content:" ";white-space:pre;width:1px}.mat-input-element::-webkit-inner-spin-button,.mat-input-element::-webkit-calendar-picker-indicator,.mat-input-element::-webkit-clear-button{font-size:.75em}.mat-input-element::placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element::-moz-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::-moz-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element::-webkit-input-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::-webkit-input-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element:-ms-input-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element:-ms-input-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-form-field-hide-placeholder .mat-input-element::placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.mat-form-field-hide-placeholder .mat-input-element::-moz-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.mat-form-field-hide-placeholder .mat-input-element::-webkit-input-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.mat-form-field-hide-placeholder .mat-input-element:-ms-input-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}textarea.mat-input-element{resize:vertical;overflow:auto}textarea.mat-input-element.cdk-textarea-autosize{resize:none}textarea.mat-input-element{padding:2px 0;margin:-2px 0}select.mat-input-element{-moz-appearance:none;-webkit-appearance:none;position:relative;background-color:transparent;display:inline-flex;box-sizing:border-box;padding-top:1em;top:-1em;margin-bottom:-1em}select.mat-input-element::-ms-expand{display:none}select.mat-input-element::-moz-focus-inner{border:0}select.mat-input-element:not(:disabled){cursor:pointer}select.mat-input-element::-ms-value{color:inherit;background:none}.mat-focused .cdk-high-contrast-active select.mat-input-element::-ms-value{color:inherit}.mat-form-field-type-mat-native-select .mat-form-field-infix::after{content:"";width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;position:absolute;top:50%;right:0;margin-top:-2.5px;pointer-events:none}[dir=rtl] .mat-form-field-type-mat-native-select .mat-form-field-infix::after{right:auto;left:0}.mat-form-field-type-mat-native-select .mat-input-element{padding-right:15px}[dir=rtl] .mat-form-field-type-mat-native-select .mat-input-element{padding-right:0;padding-left:15px}.mat-form-field-type-mat-native-select .mat-form-field-label-wrapper{max-width:calc(100% - 10px)}.mat-form-field-type-mat-native-select.mat-form-field-appearance-outline .mat-form-field-infix::after{margin-top:-5px}.mat-form-field-type-mat-native-select.mat-form-field-appearance-fill .mat-form-field-infix::after{margin-top:-10px}\n', ".mat-form-field-appearance-legacy .mat-form-field-label{transform:perspective(100px);-ms-transform:none}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon{width:1em}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button{font:inherit;vertical-align:baseline}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button .mat-icon{font-size:inherit}.mat-form-field-appearance-legacy .mat-form-field-underline{height:1px}.cdk-high-contrast-active .mat-form-field-appearance-legacy .mat-form-field-underline{height:0;border-top:solid 1px}.mat-form-field-appearance-legacy .mat-form-field-ripple{top:0;height:2px;overflow:hidden}.cdk-high-contrast-active .mat-form-field-appearance-legacy .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}.cdk-high-contrast-active .mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}.mat-form-field-appearance-legacy.mat-form-field-invalid:not(.mat-focused) .mat-form-field-ripple{height:1px}\n", ".mat-form-field-appearance-outline .mat-form-field-wrapper{margin:.25em 0}.mat-form-field-appearance-outline .mat-form-field-flex{padding:0 .75em 0 .75em;margin-top:-0.25em;position:relative}.mat-form-field-appearance-outline .mat-form-field-prefix,.mat-form-field-appearance-outline .mat-form-field-suffix{top:.25em}.mat-form-field-appearance-outline .mat-form-field-outline{display:flex;position:absolute;top:.25em;left:0;right:0;bottom:0;pointer-events:none}.mat-form-field-appearance-outline .mat-form-field-outline-start,.mat-form-field-appearance-outline .mat-form-field-outline-end{border:1px solid currentColor;min-width:5px}.mat-form-field-appearance-outline .mat-form-field-outline-start{border-radius:5px 0 0 5px;border-right-style:none}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-start{border-right-style:solid;border-left-style:none;border-radius:0 5px 5px 0}.mat-form-field-appearance-outline .mat-form-field-outline-end{border-radius:0 5px 5px 0;border-left-style:none;flex-grow:1}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-end{border-left-style:solid;border-right-style:none;border-radius:5px 0 0 5px}.mat-form-field-appearance-outline .mat-form-field-outline-gap{border-radius:.000001px;border:1px solid currentColor;border-left-style:none;border-right-style:none}.mat-form-field-appearance-outline.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-outline-gap{border-top-color:transparent}.mat-form-field-appearance-outline .mat-form-field-outline-thick{opacity:0}.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-start,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-end,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-gap{border-width:2px}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline{opacity:0;transition:opacity 100ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline-thick{opacity:1}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline{opacity:0;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline-thick{opacity:1}.mat-form-field-appearance-outline .mat-form-field-subscript-wrapper{padding:0 1em}.mat-form-field-appearance-outline._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-start,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-end,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-gap{transition:none}\n", ".mat-form-field-appearance-standard .mat-form-field-flex{padding-top:.75em}.mat-form-field-appearance-standard .mat-form-field-underline{height:1px}.cdk-high-contrast-active .mat-form-field-appearance-standard .mat-form-field-underline{height:0;border-top:solid 1px}.mat-form-field-appearance-standard .mat-form-field-ripple{bottom:0;height:2px}.cdk-high-contrast-active .mat-form-field-appearance-standard .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}.cdk-high-contrast-active .mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}.mat-form-field-appearance-standard:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-standard._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}\n"], encapsulation: 2, data: { animation: [aS.transitionMessages] }, changeDetection: 0 }), t })(), wS = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ imports: [[Ah, lv, Wg], lv] }), t })(); const CS = Om({ passive: !0 }); let kS = (() => { class t { constructor(t, e) { this._platform = t, this._ngZone = e, this._monitoredElements = new Map } monitor(t) { if (!this._platform.isBrowser) return xu; const e = pm(t), n = this._monitoredElements.get(e); if (n) return n.subject; const i = new k, s = "cdk-text-field-autofilled", r = t => { "cdk-text-field-autofill-start" !== t.animationName || e.classList.contains(s) ? "cdk-text-field-autofill-end" === t.animationName && e.classList.contains(s) && (e.classList.remove(s), this._ngZone.run(() => i.next({ target: t.target, isAutofilled: !1 }))) : (e.classList.add(s), this._ngZone.run(() => i.next({ target: t.target, isAutofilled: !0 }))) }; return this._ngZone.runOutsideAngular(() => { e.addEventListener("animationstart", r, CS), e.classList.add("cdk-text-field-autofill-monitored") }), this._monitoredElements.set(e, { subject: i, unlisten: () => { e.removeEventListener("animationstart", r, CS) } }), i } stopMonitoring(t) { const e = pm(t), n = this._monitoredElements.get(e); n && (n.unlisten(), n.subject.complete(), e.classList.remove("cdk-text-field-autofill-monitored"), e.classList.remove("cdk-text-field-autofilled"), this._monitoredElements.delete(e)) } ngOnDestroy() { this._monitoredElements.forEach((t, e) => this.stopMonitoring(e)) } } return t.\u0275fac = function (e) { return new (e || t)(li(km), li(vc)) }, t.\u0275prov = dt({ factory: function () { return new t(li(km), li(vc)) }, token: t, providedIn: "root" }), t })(), xS = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ imports: [[xm]] }), t })(); const SS = new $n("MAT_INPUT_VALUE_ACCESSOR"), ES = ["button", "checkbox", "file", "hidden", "image", "radio", "range", "reset", "submit"]; let TS = 0; class RS { constructor(t, e, n, i) { this._defaultErrorStateMatcher = t, this._parentForm = e, this._parentFormGroup = n, this.ngControl = i } } const AS = pv(RS); let OS = (() => { class t extends AS { constructor(t, e, n, i, s, r, o, a, l, c) { super(r, i, s, n), this._elementRef = t, this._platform = e, this.ngControl = n, this._autofillMonitor = a, this._formField = c, this._uid = "mat-input-" + TS++, this.focused = !1, this.stateChanges = new k, this.controlType = "mat-input", this.autofilled = !1, this._disabled = !1, this._required = !1, this._type = "text", this._readonly = !1, this._neverEmptyInputTypes = ["date", "datetime", "datetime-local", "month", "time", "week"].filter(t => Em().has(t)); const h = this._elementRef.nativeElement, u = h.nodeName.toLowerCase(); this._inputValueAccessor = o || h, this._previousNativeValue = this.value, this.id = this.id, e.IOS && l.runOutsideAngular(() => { t.nativeElement.addEventListener("keyup", t => { const e = t.target; e.value || 0 !== e.selectionStart || 0 !== e.selectionEnd || (e.setSelectionRange(1, 1), e.setSelectionRange(0, 0)) }) }), this._isServer = !this._platform.isBrowser, this._isNativeSelect = "select" === u, this._isTextarea = "textarea" === u, this._isNativeSelect && (this.controlType = h.multiple ? "mat-native-select-multiple" : "mat-native-select") } get disabled() { return this.ngControl && null !== this.ngControl.disabled ? this.ngControl.disabled : this._disabled } set disabled(t) { this._disabled = lm(t), this.focused && (this.focused = !1, this.stateChanges.next()) } get id() { return this._id } set id(t) { this._id = t || this._uid } get required() { return this._required } set required(t) { this._required = lm(t) } get type() { return this._type } set type(t) { this._type = t || "text", this._validateType(), !this._isTextarea && Em().has(this._type) && (this._elementRef.nativeElement.type = this._type) } get value() { return this._inputValueAccessor.value } set value(t) { t !== this.value && (this._inputValueAccessor.value = t, this.stateChanges.next()) } get readonly() { return this._readonly } set readonly(t) { this._readonly = lm(t) } ngAfterViewInit() { this._platform.isBrowser && this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(t => { this.autofilled = t.isAutofilled, this.stateChanges.next() }) } ngOnChanges() { this.stateChanges.next() } ngOnDestroy() { this.stateChanges.complete(), this._platform.isBrowser && this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement) } ngDoCheck() { this.ngControl && this.updateErrorState(), this._dirtyCheckNativeValue(), this._dirtyCheckPlaceholder() } focus(t) { this._elementRef.nativeElement.focus(t) } _focusChanged(t) { t === this.focused || this.readonly && t || (this.focused = t, this.stateChanges.next()) } _onInput() { } _dirtyCheckPlaceholder() { var t, e; const n = (null === (e = null === (t = this._formField) || void 0 === t ? void 0 : t._hideControlPlaceholder) || void 0 === e ? void 0 : e.call(t)) ? null : this.placeholder; if (n !== this._previousPlaceholder) { const t = this._elementRef.nativeElement; this._previousPlaceholder = n, n ? t.setAttribute("placeholder", n) : t.removeAttribute("placeholder") } } _dirtyCheckNativeValue() { const t = this._elementRef.nativeElement.value; this._previousNativeValue !== t && (this._previousNativeValue = t, this.stateChanges.next()) } _validateType() { ES.indexOf(this._type) } _isNeverEmpty() { return this._neverEmptyInputTypes.indexOf(this._type) > -1 } _isBadInput() { let t = this._elementRef.nativeElement.validity; return t && t.badInput } get empty() { return !(this._isNeverEmpty() || this._elementRef.nativeElement.value || this._isBadInput() || this.autofilled) } get shouldLabelFloat() { if (this._isNativeSelect) { const t = this._elementRef.nativeElement, e = t.options[0]; return this.focused || t.multiple || !this.empty || !!(t.selectedIndex > -1 && e && e.label) } return this.focused || !this.empty } setDescribedByIds(t) { t.length ? this._elementRef.nativeElement.setAttribute("aria-describedby", t.join(" ")) : this._elementRef.nativeElement.removeAttribute("aria-describedby") } onContainerClick() { this.focused || this.focus() } } return t.\u0275fac = function (e) { return new (e || t)(bo(Ma), bo(km), bo(Jk, 10), bo(Tx, 8), bo(Nx, 8), bo(Tv), bo(SS, 10), bo(kS), bo(vc), bo(bS, 8)) }, t.\u0275dir = Zt({ type: t, selectors: [["input", "matInput", ""], ["textarea", "matInput", ""], ["select", "matNativeControl", ""], ["input", "matNativeControl", ""], ["textarea", "matNativeControl", ""]], hostAttrs: [1, "mat-input-element", "mat-form-field-autofill-control"], hostVars: 9, hostBindings: function (t, e) { 1 & t && Io("focus", function () { return e._focusChanged(!0) })("blur", function () { return e._focusChanged(!1) })("input", function () { return e._onInput() }), 2 & t && (ha("disabled", e.disabled)("required", e.required), mo("id", e.id)("data-placeholder", e.placeholder)("readonly", e.readonly && !e._isNativeSelect || null)("aria-invalid", e.empty && e.required ? null : e.errorState)("aria-required", e.required), Ko("mat-input-server", e._isServer)) }, inputs: { id: "id", disabled: "disabled", required: "required", type: "type", value: "value", readonly: "readonly", placeholder: "placeholder", errorStateMatcher: "errorStateMatcher", userAriaDescribedBy: ["aria-describedby", "userAriaDescribedBy"] }, exportAs: ["matInput"], features: [Ta([{ provide: lS, useExisting: t }]), so, le] }), t })(), IS = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ providers: [Tv], imports: [[xS, wS, lv], xS, wS] }), t })(); const DS = ["trigger"], PS = ["panel"]; function MS(t, e) { if (1 & t && (Co(0, "span", 8), ra(1), ko()), 2 & t) { const t = Fo(); qs(1), oa(t.placeholder) } } function NS(t, e) { if (1 & t && (Co(0, "span", 12), ra(1), ko()), 2 & t) { const t = Fo(2); qs(1), oa(t.triggerValue) } } function FS(t, e) { 1 & t && jo(0, 0, ["*ngSwitchCase", "true"]) } function LS(t, e) { 1 & t && (Co(0, "span", 9), _o(1, NS, 2, 1, "span", 10), _o(2, FS, 1, 0, "ng-content", 11), ko()), 2 & t && (vo("ngSwitch", !!Fo().customTrigger), qs(2), vo("ngSwitchCase", !0)) } function VS(t, e) { if (1 & t) { const t = Ro(); Co(0, "div", 13), Co(1, "div", 14, 15), Io("@transformPanel.done", function (e) { return Ie(t), Fo()._panelDoneAnimatingStream.next(e.toState) })("keydown", function (e) { return Ie(t), Fo()._handleKeydown(e) }), jo(3, 1), ko(), ko() } if (2 & t) { const t = Fo(); vo("@transformPanelWrap", void 0), qs(1), la("mat-select-panel ", t._getPanelTheme(), ""), Wo("transform-origin", t._transformOrigin)("font-size", t._triggerFontSize, "px"), vo("ngClass", t.panelClass)("@transformPanel", t.multiple ? "showing-multiple" : "showing"), mo("id", t.id + "-panel")("aria-multiselectable", t.multiple)("aria-label", t.ariaLabel || null)("aria-labelledby", t._getPanelAriaLabelledby()) } } const jS = [[["mat-select-trigger"]], "*"], BS = ["mat-select-trigger", "*"], HS = { transformPanelWrap: g_("transformPanelWrap", [w_("* => void", k_("@transformPanel", [C_()], { optional: !0 }))]), transformPanel: g_("transformPanel", [v_("void", b_({ transform: "scaleY(0.8)", minWidth: "100%", opacity: 0 })), v_("showing", b_({ opacity: 1, minWidth: "calc(100% + 32px)", transform: "scaleY(1)" })), v_("showing-multiple", b_({ opacity: 1, minWidth: "calc(100% + 64px)", transform: "scaleY(1)" })), w_("void => *", __("120ms cubic-bezier(0, 0, 0.2, 1)")), w_("* => void", __("100ms 25ms linear", b_({ opacity: 0 })))]) }; let US = 0; const zS = 256, $S = new $n("mat-select-scroll-strategy"), qS = new $n("MAT_SELECT_CONFIG"), WS = { provide: $S, deps: [OC], useFactory: function (t) { return () => t.scrollStrategies.reposition() } }; class KS { constructor(t, e) { this.source = t, this.value = e } } class YS { constructor(t, e, n, i, s) { this._elementRef = t, this._defaultErrorStateMatcher = e, this._parentForm = n, this._parentFormGroup = i, this.ngControl = s } } const ZS = uv(dv(cv(pv(YS)))), GS = new $n("MatSelectTrigger"); let QS = (() => { class t extends ZS { constructor(t, e, n, i, s, r, o, a, l, c, h, u, d, p) { var f, m, g; super(s, i, o, a, c), this._viewportRuler = t, this._changeDetectorRef = e, this._ngZone = n, this._dir = r, this._parentFormField = l, this.ngControl = c, this._liveAnnouncer = d, this._defaultOptions = p, this._panelOpen = !1, this._compareWith = (t, e) => t === e, this._uid = "mat-select-" + US++, this._triggerAriaLabelledBy = null, this._destroy = new k, this._onChange = () => { }, this._onTouched = () => { }, this._valueId = "mat-select-value-" + US++, this._panelDoneAnimatingStream = new k, this._overlayPanelClass = (null === (f = this._defaultOptions) || void 0 === f ? void 0 : f.overlayPanelClass) || "", this._focused = !1, this.controlType = "mat-select", this._required = !1, this._multiple = !1, this._disableOptionCentering = null !== (g = null === (m = this._defaultOptions) || void 0 === m ? void 0 : m.disableOptionCentering) && void 0 !== g && g, this.ariaLabel = "", this.optionSelectionChanges = Eu(() => { const t = this.options; return t ? t.changes.pipe(Mu(t), Tu(() => q(...t.map(t => t.onSelectionChange)))) : this._ngZone.onStable.pipe(Iu(1), Tu(() => this.optionSelectionChanges)) }), this.openedChange = new Ml, this._openedStream = this.openedChange.pipe(Vu(t => t), E(() => { })), this._closedStream = this.openedChange.pipe(Vu(t => !t), E(() => { })), this.selectionChange = new Ml, this.valueChange = new Ml, this.ngControl && (this.ngControl.valueAccessor = this), null != (null == p ? void 0 : p.typeaheadDebounceInterval) && (this._typeaheadDebounceInterval = p.typeaheadDebounceInterval), this._scrollStrategyFactory = u, this._scrollStrategy = this._scrollStrategyFactory(), this.tabIndex = parseInt(h) || 0, this.id = this.id } get focused() { return this._focused || this._panelOpen } get placeholder() { return this._placeholder } set placeholder(t) { this._placeholder = t, this.stateChanges.next() } get required() { return this._required } set required(t) { this._required = lm(t), this.stateChanges.next() } get multiple() { return this._multiple } set multiple(t) { this._multiple = lm(t) } get disableOptionCentering() { return this._disableOptionCentering } set disableOptionCentering(t) { this._disableOptionCentering = lm(t) } get compareWith() { return this._compareWith } set compareWith(t) { this._compareWith = t, this._selectionModel && this._initializeSelection() } get value() { return this._value } set value(t) { (t !== this._value || this._multiple && Array.isArray(t)) && (this.options && this._setSelectionByValue(t), this._value = t) } get typeaheadDebounceInterval() { return this._typeaheadDebounceInterval } set typeaheadDebounceInterval(t) { this._typeaheadDebounceInterval = cm(t) } get id() { return this._id } set id(t) { this._id = t || this._uid, this.stateChanges.next() } ngOnInit() { this._selectionModel = new gm(this.multiple), this.stateChanges.next(), this._panelDoneAnimatingStream.pipe(t => t.lift(new jm(void 0, void 0)), Km(this._destroy)).subscribe(() => this._panelDoneAnimating(this.panelOpen)) } ngAfterContentInit() { this._initKeyManager(), this._selectionModel.changed.pipe(Km(this._destroy)).subscribe(t => { t.added.forEach(t => t.select()), t.removed.forEach(t => t.deselect()) }), this.options.changes.pipe(Mu(null), Km(this._destroy)).subscribe(() => { this._resetOptions(), this._initializeSelection() }) } ngDoCheck() { const t = this._getTriggerAriaLabelledby(); if (t !== this._triggerAriaLabelledBy) { const e = this._elementRef.nativeElement; this._triggerAriaLabelledBy = t, t ? e.setAttribute("aria-labelledby", t) : e.removeAttribute("aria-labelledby") } this.ngControl && this.updateErrorState() } ngOnChanges(t) { t.disabled && this.stateChanges.next(), t.typeaheadDebounceInterval && this._keyManager && this._keyManager.withTypeAhead(this._typeaheadDebounceInterval) } ngOnDestroy() { this._destroy.next(), this._destroy.complete(), this.stateChanges.complete() } toggle() { this.panelOpen ? this.close() : this.open() } open() { this._canOpen() && (this._panelOpen = !0, this._keyManager.withHorizontalOrientation(null), this._highlightCorrectOption(), this._changeDetectorRef.markForCheck()) } close() { this._panelOpen && (this._panelOpen = !1, this._keyManager.withHorizontalOrientation(this._isRtl() ? "rtl" : "ltr"), this._changeDetectorRef.markForCheck(), this._onTouched()) } writeValue(t) { this.value = t } registerOnChange(t) { this._onChange = t } registerOnTouched(t) { this._onTouched = t } setDisabledState(t) { this.disabled = t, this._changeDetectorRef.markForCheck(), this.stateChanges.next() } get panelOpen() { return this._panelOpen } get selected() { return this.multiple ? this._selectionModel.selected : this._selectionModel.selected[0] } get triggerValue() { if (this.empty) return ""; if (this._multiple) { const t = this._selectionModel.selected.map(t => t.viewValue); return this._isRtl() && t.reverse(), t.join(", ") } return this._selectionModel.selected[0].viewValue } _isRtl() { return !!this._dir && "rtl" === this._dir.value } _handleKeydown(t) { this.disabled || (this.panelOpen ? this._handleOpenKeydown(t) : this._handleClosedKeydown(t)) } _handleClosedKeydown(t) { const e = t.keyCode, n = 40 === e || 38 === e || 37 === e || 39 === e, i = 13 === e || 32 === e, s = this._keyManager; if (!s.isTyping() && i && !Vg(t) || (this.multiple || t.altKey) && n) t.preventDefault(), this.open(); else if (!this.multiple) { const e = this.selected; s.onKeydown(t); const n = this.selected; n && e !== n && this._liveAnnouncer.announce(n.viewValue, 1e4) } } _handleOpenKeydown(t) { const e = this._keyManager, n = t.keyCode, i = 40 === n || 38 === n, s = e.isTyping(); if (i && t.altKey) t.preventDefault(), this.close(); else if (s || 13 !== n && 32 !== n || !e.activeItem || Vg(t)) if (!s && this._multiple && 65 === n && t.ctrlKey) { t.preventDefault(); const e = this.options.some(t => !t.disabled && !t.selected); this.options.forEach(t => { t.disabled || (e ? t.select() : t.deselect()) }) } else { const n = e.activeItemIndex; e.onKeydown(t), this._multiple && i && t.shiftKey && e.activeItem && e.activeItemIndex !== n && e.activeItem._selectViaInteraction() } else t.preventDefault(), e.activeItem._selectViaInteraction() } _onFocus() { this.disabled || (this._focused = !0, this.stateChanges.next()) } _onBlur() { this._focused = !1, this.disabled || this.panelOpen || (this._onTouched(), this._changeDetectorRef.markForCheck(), this.stateChanges.next()) } _onAttached() { this._overlayDir.positionChange.pipe(Iu(1)).subscribe(() => { this._changeDetectorRef.detectChanges(), this._positioningSettled() }) } _getPanelTheme() { return this._parentFormField ? `mat-${this._parentFormField.color}` : "" } get empty() { return !this._selectionModel || this._selectionModel.isEmpty() } _initializeSelection() { Promise.resolve().then(() => { this._setSelectionByValue(this.ngControl ? this.ngControl.value : this._value), this.stateChanges.next() }) } _setSelectionByValue(t) { if (this._selectionModel.selected.forEach(t => t.setInactiveStyles()), this._selectionModel.clear(), this.multiple && t) Array.isArray(t), t.forEach(t => this._selectValue(t)), this._sortValues(); else { const e = this._selectValue(t); e ? this._keyManager.updateActiveItem(e) : this.panelOpen || this._keyManager.updateActiveItem(-1) } this._changeDetectorRef.markForCheck() } _selectValue(t) { const e = this.options.find(e => { if (this._selectionModel.isSelected(e)) return !1; try { return null != e.value && this._compareWith(e.value, t) } catch (n) { return !1 } }); return e && this._selectionModel.select(e), e } _initKeyManager() { this._keyManager = new Kg(this.options).withTypeAhead(this._typeaheadDebounceInterval).withVerticalOrientation().withHorizontalOrientation(this._isRtl() ? "rtl" : "ltr").withHomeAndEnd().withAllowedModifierKeys(["shiftKey"]), this._keyManager.tabOut.pipe(Km(this._destroy)).subscribe(() => { this.panelOpen && (!this.multiple && this._keyManager.activeItem && this._keyManager.activeItem._selectViaInteraction(), this.focus(), this.close()) }), this._keyManager.change.pipe(Km(this._destroy)).subscribe(() => { this._panelOpen && this.panel ? this._scrollOptionIntoView(this._keyManager.activeItemIndex || 0) : this._panelOpen || this.multiple || !this._keyManager.activeItem || this._keyManager.activeItem._selectViaInteraction() }) } _resetOptions() { const t = q(this.options.changes, this._destroy); this.optionSelectionChanges.pipe(Km(t)).subscribe(t => { this._onSelect(t.source, t.isUserInput), t.isUserInput && !this.multiple && this._panelOpen && (this.close(), this.focus()) }), q(...this.options.map(t => t._stateChanges)).pipe(Km(t)).subscribe(() => { this._changeDetectorRef.markForCheck(), this.stateChanges.next() }) } _onSelect(t, e) { const n = this._selectionModel.isSelected(t); null != t.value || this._multiple ? (n !== t.selected && (t.selected ? this._selectionModel.select(t) : this._selectionModel.deselect(t)), e && this._keyManager.setActiveItem(t), this.multiple && (this._sortValues(), e && this.focus())) : (t.deselect(), this._selectionModel.clear(), null != this.value && this._propagateChanges(t.value)), n !== this._selectionModel.isSelected(t) && this._propagateChanges(), this.stateChanges.next() } _sortValues() { if (this.multiple) { const t = this.options.toArray(); this._selectionModel.sort((e, n) => this.sortComparator ? this.sortComparator(e, n, t) : t.indexOf(e) - t.indexOf(n)), this.stateChanges.next() } } _propagateChanges(t) { let e = null; e = this.multiple ? this.selected.map(t => t.value) : this.selected ? this.selected.value : t, this._value = e, this.valueChange.emit(e), this._onChange(e), this.selectionChange.emit(this._getChangeEvent(e)), this._changeDetectorRef.markForCheck() } _highlightCorrectOption() { this._keyManager && (this.empty ? this._keyManager.setFirstItemActive() : this._keyManager.setActiveItem(this._selectionModel.selected[0])) } _canOpen() { var t; return !this._panelOpen && !this.disabled && (null === (t = this.options) || void 0 === t ? void 0 : t.length) > 0 } focus(t) { this._elementRef.nativeElement.focus(t) } _getPanelAriaLabelledby() { var t; if (this.ariaLabel) return null; const e = null === (t = this._parentFormField) || void 0 === t ? void 0 : t.getLabelId(); return this.ariaLabelledby ? (e ? e + " " : "") + this.ariaLabelledby : e } _getAriaActiveDescendant() { return this.panelOpen && this._keyManager && this._keyManager.activeItem ? this._keyManager.activeItem.id : null } _getTriggerAriaLabelledby() { var t; if (this.ariaLabel) return null; const e = null === (t = this._parentFormField) || void 0 === t ? void 0 : t.getLabelId(); let n = (e ? e + " " : "") + this._valueId; return this.ariaLabelledby && (n += " " + this.ariaLabelledby), n } _panelDoneAnimating(t) { this.openedChange.emit(t) } setDescribedByIds(t) { this._ariaDescribedby = t.join(" ") } onContainerClick() { this.focus(), this.open() } get shouldLabelFloat() { return this._panelOpen || !this.empty || this._focused && !!this._placeholder } } return t.\u0275fac = function (e) { return new (e || t)(bo(Qm), bo(ol), bo(vc), bo(Tv), bo(Ma), bo(vm, 8), bo(Tx, 8), bo(Nx, 8), bo(bS, 8), bo(Jk, 10), Hn("tabindex"), bo($S), bo(e_), bo(qS, 8)) }, t.\u0275dir = Zt({ type: t, viewQuery: function (t, e) { if (1 & t && (Kl(DS, 5), Kl(PS, 5), Kl(MC, 5)), 2 & t) { let t; Wl(t = Zl()) && (e.trigger = t.first), Wl(t = Zl()) && (e.panel = t.first), Wl(t = Zl()) && (e._overlayDir = t.first) } }, inputs: { ariaLabel: ["aria-label", "ariaLabel"], id: "id", placeholder: "placeholder", required: "required", multiple: "multiple", disableOptionCentering: "disableOptionCentering", compareWith: "compareWith", value: "value", typeaheadDebounceInterval: "typeaheadDebounceInterval", panelClass: "panelClass", ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], errorStateMatcher: "errorStateMatcher", sortComparator: "sortComparator" }, outputs: { openedChange: "openedChange", _openedStream: "opened", _closedStream: "closed", selectionChange: "selectionChange", valueChange: "valueChange" }, features: [so, le] }), t })(), XS = (() => { class t extends QS { constructor() { super(...arguments), this._scrollTop = 0, this._triggerFontSize = 0, this._transformOrigin = "top", this._offsetY = 0, this._positions = [{ originX: "start", originY: "top", overlayX: "start", overlayY: "top" }, { originX: "start", originY: "bottom", overlayX: "start", overlayY: "bottom" }] } _calculateOverlayScroll(t, e, n) { const i = this._getItemHeight(); return Math.min(Math.max(0, i * t - e + i / 2), n) } ngOnInit() { super.ngOnInit(), this._viewportRuler.change().pipe(Km(this._destroy)).subscribe(() => { this.panelOpen && (this._triggerRect = this.trigger.nativeElement.getBoundingClientRect(), this._changeDetectorRef.markForCheck()) }) } open() { super._canOpen() && (super.open(), this._triggerRect = this.trigger.nativeElement.getBoundingClientRect(), this._triggerFontSize = parseInt(getComputedStyle(this.trigger.nativeElement).fontSize || "0"), this._calculateOverlayPosition(), this._ngZone.onStable.pipe(Iu(1)).subscribe(() => { this._triggerFontSize && this._overlayDir.overlayRef && this._overlayDir.overlayRef.overlayElement && (this._overlayDir.overlayRef.overlayElement.style.fontSize = `${this._triggerFontSize}px`) })) } _scrollOptionIntoView(t) { const e = Zv(t, this.options, this.optionGroups), n = this._getItemHeight(); var i, s, r; this.panel.nativeElement.scrollTop = (s = n, (i = (t + e) * n) < (r = this.panel.nativeElement.scrollTop) ? i : i + s > r + 256 ? Math.max(0, i - 256 + s) : r) } _positioningSettled() { this._calculateOverlayOffsetX(), this.panel.nativeElement.scrollTop = this._scrollTop } _panelDoneAnimating(t) { this.panelOpen ? this._scrollTop = 0 : (this._overlayDir.offsetX = 0, this._changeDetectorRef.markForCheck()), super._panelDoneAnimating(t) } _getChangeEvent(t) { return new KS(this, t) } _calculateOverlayOffsetX() { const t = this._overlayDir.overlayRef.overlayElement.getBoundingClientRect(), e = this._viewportRuler.getViewportSize(), n = this._isRtl(), i = this.multiple ? 56 : 32; let s; if (this.multiple) s = 40; else if (this.disableOptionCentering) s = 16; else { let t = this._selectionModel.selected[0] || this.options.first; s = t && t.group ? 32 : 16 } n || (s *= -1); const r = 0 - (t.left + s - (n ? i : 0)), o = t.right + s - e.width + (n ? 0 : i); r > 0 ? s += r + 8 : o > 0 && (s -= o + 8), this._overlayDir.offsetX = Math.round(s), this._overlayDir.overlayRef.updatePosition() } _calculateOverlayOffsetY(t, e, n) { const i = this._getItemHeight(), s = (i - this._triggerRect.height) / 2, r = Math.floor(zS / i); let o; return this.disableOptionCentering ? 0 : (o = 0 === this._scrollTop ? t * i : this._scrollTop === n ? (t - (this._getItemCount() - r)) * i + (i - (this._getItemCount() * i - zS) % i) : e - i / 2, Math.round(-1 * o - s)) } _checkOverlayWithinViewport(t) { const e = this._getItemHeight(), n = this._viewportRuler.getViewportSize(), i = this._triggerRect.top - 8, s = n.height - this._triggerRect.bottom - 8, r = Math.abs(this._offsetY), o = Math.min(this._getItemCount() * e, zS) - r - this._triggerRect.height; o > s ? this._adjustPanelUp(o, s) : r > i ? this._adjustPanelDown(r, i, t) : this._transformOrigin = this._getOriginBasedOnOption() } _adjustPanelUp(t, e) { const n = Math.round(t - e); this._scrollTop -= n, this._offsetY -= n, this._transformOrigin = this._getOriginBasedOnOption(), this._scrollTop <= 0 && (this._scrollTop = 0, this._offsetY = 0, this._transformOrigin = "50% bottom 0px") } _adjustPanelDown(t, e, n) { const i = Math.round(t - e); if (this._scrollTop += i, this._offsetY += i, this._transformOrigin = this._getOriginBasedOnOption(), this._scrollTop >= n) return this._scrollTop = n, this._offsetY = 0, void (this._transformOrigin = "50% top 0px") } _calculateOverlayPosition() { const t = this._getItemHeight(), e = this._getItemCount(), n = Math.min(e * t, zS), i = e * t - n; let s; s = this.empty ? 0 : Math.max(this.options.toArray().indexOf(this._selectionModel.selected[0]), 0), s += Zv(s, this.options, this.optionGroups); const r = n / 2; this._scrollTop = this._calculateOverlayScroll(s, r, i), this._offsetY = this._calculateOverlayOffsetY(s, r, i), this._checkOverlayWithinViewport(i) } _getOriginBasedOnOption() { const t = this._getItemHeight(), e = (t - this._triggerRect.height) / 2; return `50% ${Math.abs(this._offsetY) - e + t / 2}px 0px` } _getItemHeight() { return 3 * this._triggerFontSize } _getItemCount() { return this.options.length + this.optionGroups.length } } return t.\u0275fac = function () { let e; return function (n) { return (e || (e = jn(t)))(n || t) } }(), t.\u0275cmp = zt({ type: t, selectors: [["mat-select"]], contentQueries: function (t, e, n) { if (1 & t && (Yl(n, GS, 5), Yl(n, Yv, 5), Yl(n, $v, 5)), 2 & t) { let t; Wl(t = Zl()) && (e.customTrigger = t.first), Wl(t = Zl()) && (e.options = t), Wl(t = Zl()) && (e.optionGroups = t) } }, hostAttrs: ["role", "combobox", "aria-autocomplete", "none", "aria-haspopup", "true", 1, "mat-select"], hostVars: 20, hostBindings: function (t, e) { 1 & t && Io("keydown", function (t) { return e._handleKeydown(t) })("focus", function () { return e._onFocus() })("blur", function () { return e._onBlur() }), 2 & t && (mo("id", e.id)("tabindex", e.tabIndex)("aria-controls", e.panelOpen ? e.id + "-panel" : null)("aria-expanded", e.panelOpen)("aria-label", e.ariaLabel || null)("aria-required", e.required.toString())("aria-disabled", e.disabled.toString())("aria-invalid", e.errorState)("aria-describedby", e._ariaDescribedby || null)("aria-activedescendant", e._getAriaActiveDescendant()), Ko("mat-select-disabled", e.disabled)("mat-select-invalid", e.errorState)("mat-select-required", e.required)("mat-select-empty", e.empty)("mat-select-multiple", e.multiple)) }, inputs: { disabled: "disabled", disableRipple: "disableRipple", tabIndex: "tabIndex" }, exportAs: ["matSelect"], features: [Ta([{ provide: lS, useExisting: t }, { provide: jv, useExisting: t }]), so], ngContentSelectors: BS, decls: 9, vars: 12, consts: [["cdk-overlay-origin", "", 1, "mat-select-trigger", 3, "click"], ["origin", "cdkOverlayOrigin", "trigger", ""], [1, "mat-select-value", 3, "ngSwitch"], ["class", "mat-select-placeholder mat-select-min-line", 4, "ngSwitchCase"], ["class", "mat-select-value-text", 3, "ngSwitch", 4, "ngSwitchCase"], [1, "mat-select-arrow-wrapper"], [1, "mat-select-arrow"], ["cdk-connected-overlay", "", "cdkConnectedOverlayLockPosition", "", "cdkConnectedOverlayHasBackdrop", "", "cdkConnectedOverlayBackdropClass", "cdk-overlay-transparent-backdrop", 3, "cdkConnectedOverlayPanelClass", "cdkConnectedOverlayScrollStrategy", "cdkConnectedOverlayOrigin", "cdkConnectedOverlayOpen", "cdkConnectedOverlayPositions", "cdkConnectedOverlayMinWidth", "cdkConnectedOverlayOffsetY", "backdropClick", "attach", "detach"], [1, "mat-select-placeholder", "mat-select-min-line"], [1, "mat-select-value-text", 3, "ngSwitch"], ["class", "mat-select-min-line", 4, "ngSwitchDefault"], [4, "ngSwitchCase"], [1, "mat-select-min-line"], [1, "mat-select-panel-wrap"], ["role", "listbox", "tabindex", "-1", 3, "ngClass", "keydown"], ["panel", ""]], template: function (t, e) { if (1 & t && (Vo(jS), Co(0, "div", 0, 1), Io("click", function () { return e.toggle() }), Co(3, "div", 2), _o(4, MS, 2, 1, "span", 3), _o(5, LS, 3, 2, "span", 4), ko(), Co(6, "div", 5), xo(7, "div", 6), ko(), ko(), _o(8, VS, 4, 14, "ng-template", 7), Io("backdropClick", function () { return e.close() })("attach", function () { return e._onAttached() })("detach", function () { return e.close() })), 2 & t) { const t = yo(1); mo("aria-owns", e.panelOpen ? e.id + "-panel" : null), qs(3), vo("ngSwitch", e.empty), mo("id", e._valueId), qs(1), vo("ngSwitchCase", !0), qs(1), vo("ngSwitchCase", !1), qs(3), vo("cdkConnectedOverlayPanelClass", e._overlayPanelClass)("cdkConnectedOverlayScrollStrategy", e._scrollStrategy)("cdkConnectedOverlayOrigin", t)("cdkConnectedOverlayOpen", e.panelOpen)("cdkConnectedOverlayPositions", e._positions)("cdkConnectedOverlayMinWidth", null == e._triggerRect ? null : e._triggerRect.width)("cdkConnectedOverlayOffsetY", e._offsetY) } }, directives: [PC, Eh, Th, MC, Rh, wh], styles: ['.mat-select{display:inline-block;width:100%;outline:none}.mat-select-trigger{display:inline-table;cursor:pointer;position:relative;box-sizing:border-box}.mat-select-disabled .mat-select-trigger{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-select-value{display:table-cell;max-width:0;width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.mat-select-value-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-select-arrow-wrapper{display:table-cell;vertical-align:middle}.mat-form-field-appearance-fill .mat-select-arrow-wrapper{transform:translateY(-50%)}.mat-form-field-appearance-outline .mat-select-arrow-wrapper{transform:translateY(-25%)}.mat-form-field-appearance-standard.mat-form-field-has-label .mat-select:not(.mat-select-empty) .mat-select-arrow-wrapper{transform:translateY(-50%)}.mat-form-field-appearance-standard .mat-select.mat-select-empty .mat-select-arrow-wrapper{transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}._mat-animation-noopable.mat-form-field-appearance-standard .mat-select.mat-select-empty .mat-select-arrow-wrapper{transition:none}.mat-select-arrow{width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;margin:0 4px}.mat-select-panel-wrap{flex-basis:100%}.mat-select-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;padding-top:0;padding-bottom:0;max-height:256px;min-width:100%;border-radius:4px;outline:0}.cdk-high-contrast-active .mat-select-panel{outline:solid 1px}.mat-select-panel .mat-optgroup-label,.mat-select-panel .mat-option{font-size:inherit;line-height:3em;height:3em}.mat-form-field-type-mat-select:not(.mat-form-field-disabled) .mat-form-field-flex{cursor:pointer}.mat-form-field-type-mat-select .mat-form-field-label{width:calc(100% - 18px)}.mat-select-placeholder{transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}._mat-animation-noopable .mat-select-placeholder{transition:none}.mat-form-field-hide-placeholder .mat-select-placeholder{color:transparent;-webkit-text-fill-color:transparent;transition:none;display:block}.mat-select-min-line:empty::before{content:" ";white-space:pre;width:1px}\n'], encapsulation: 2, data: { animation: [HS.transformPanelWrap, HS.transformPanel] }, changeDetection: 0 }), t })(), JS = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ providers: [WS], imports: [[Ah, FC, Gv, lv], Xm, wS, Gv, lv] }), t })(); function tE(t, e) { 1 & t && (Co(0, "mat-error"), ra(1, " title is "), Co(2, "strong"), ra(3, "required"), ko(), ko()) } let eE = (() => { class t { constructor(t, e, n) { this.service = t, this.dialogRef = e, this.snackBar = n, this.formValues = { title: "", description: "", start: "", tag: "", due: "" } } ngOnInit() { } onClickAdd() { this.service.addTodo(this.formValues).subscribe(t => { console.log(t), this.snackBar.open("Todo Added Successfully.", "close", { verticalPosition: "top", duration: 2e3 }), this.dialogRef.close() }, t => { console.log(t) }) } } return t.\u0275fac = function (e) { return new (e || t)(bo(qw), bo(zC), bo(Ok)) }, t.\u0275cmp = zt({ type: t, selectors: [["app-add-todo"]], decls: 48, vars: 8, consts: [["mat-dialog-title", "", 1, "fw-bold", "text-dark", "font-bold", "has-text-primary"], [1, "mat-typography"], ["novalidate", "", 1, "example-form"], ["form", "ngForm"], [1, "example-full-width"], [1, "fw-bold", "text-dark", "font-bold"], ["matInput", "", "placeholder", "title", "name", "title", "required", "", 1, "fw-normal", "text-dark", "font-bold", 3, "ngModel", "ngModelChange"], ["title", "ngModel"], [4, "ngIf"], ["matInput", "", "placeholder", "description", "name", "description", 1, "fw-normal", "text-dark", "font-bold", 3, "ngModel", "ngModelChange"], ["description", "ngModel"], [1, "example-form"], ["type", "date", "matInput", "", "placeholder", "start date", "name", "start", 1, "fw-normal", "text-dark", "font-bold", 3, "ngModel", "ngModelChange"], ["start", "ngModel"], ["type", "date", "matInput", "", "placeholder", "due date", "name", "due", 1, "fw-normal", "text-dark", "font-bold", 3, "ngModel", "ngModelChange"], ["due", "ngModel"], [1, "mb-3"], ["matInput", "", "placeholder", "tag", "name", "tag", 1, "fw-normal", "text-dark", "font-bold", 3, "ngModel", "ngModelChange"], ["tag", "ngModel"], ["value", "Urgent"], ["value", "Important"], ["value", "Today"], ["value", "Urgent & Important"], ["value", "Nothing"], ["align", "end"], ["mat-button", "", "mat-dialog-close", "", 1, "button", "btn", "px-2", "text-dark", "is-success", "font-bold", "btn-sm"], ["mat-button", "", "cdkFocusInitial", "", 1, "button", "btn", "text-dark", "px-2", "is-success", "font-bold", "btn-sm", 3, "mat-dialog-close", "disabled", "click"]], template: function (t, e) { if (1 & t && (Co(0, "h2", 0), ra(1, "Add Todo"), ko(), Co(2, "mat-dialog-content", 1), Co(3, "form", 2, 3), Co(5, "mat-form-field", 4), Co(6, "mat-label", 5), ra(7, "Title"), ko(), Co(8, "input", 6, 7), Io("ngModelChange", function (t) { return e.formValues.title = t }), ko(), _o(10, tE, 4, 0, "mat-error", 8), ko(), Co(11, "mat-form-field", 4), Co(12, "mat-label", 5), ra(13, "Description"), ko(), Co(14, "textarea", 9, 10), Io("ngModelChange", function (t) { return e.formValues.description = t }), ko(), ko(), Co(16, "mat-form-field", 11), Co(17, "mat-label", 5), ra(18, "Start Date"), ko(), Co(19, "input", 12, 13), Io("ngModelChange", function (t) { return e.formValues.start = t }), ko(), ko(), xo(21, "br"), Co(22, "mat-form-field", 11), Co(23, "mat-label", 5), ra(24, "Due Date"), ko(), Co(25, "input", 14, 15), Io("ngModelChange", function (t) { return e.formValues.due = t }), ko(), ko(), Co(27, "div", 16), Co(28, "mat-form-field"), Co(29, "mat-label", 5), ra(30, "Select a tag"), ko(), Co(31, "mat-select", 17, 18), Io("ngModelChange", function (t) { return e.formValues.tag = t }), Co(33, "mat-option", 19), ra(34, "Urgent \ud83d\udfe3"), ko(), Co(35, "mat-option", 20), ra(36, "Important \ud83d\udfe2 "), ko(), Co(37, "mat-option", 21), ra(38, "Today \ud83d\udd35"), ko(), Co(39, "mat-option", 22), ra(40, "Urgent & Important \ud83d\udd34"), ko(), Co(41, "mat-option", 23), ra(42, "Nothing \ud83d\udfe1"), ko(), ko(), ko(), ko(), ko(), ko(), Co(43, "mat-dialog-actions", 24), Co(44, "button", 25), ra(45, "Cancel"), ko(), Co(46, "button", 26), Io("click", function () { return e.onClickAdd() }), ra(47, "Add Todo"), ko(), ko()), 2 & t) { const t = yo(4), n = yo(9); qs(8), vo("ngModel", e.formValues.title), qs(2), vo("ngIf", n.invalid && (n.dirty || n.touched)), qs(4), vo("ngModel", e.formValues.description), qs(5), vo("ngModel", e.formValues.start), qs(6), vo("ngModel", e.formValues.due), qs(6), vo("ngModel", e.formValues.tag), qs(15), vo("mat-dialog-close", !0)("disabled", !t.form.valid) } }, directives: [JC, tk, Ix, nx, Tx, vS, hS, OS, Vk, Lx, ex, Ox, Ch, XS, Yv, ek, ck, XC, oS], styles: [".example-full-width[_ngcontent-%COMP%]{width:100%}"] }), t })(), nE = (() => { class t { constructor(t, e, n, i) { this.data = t, this.service = e, this.snackBar = n, this.dialogRef = i, this.todoId = t.todoId } ngOnInit() { } onClickDelete() { this.service.deleteTodo(this.todoId).subscribe(t => { console.log(t), this.snackBar.open("Todo Deleted Successfully", "close", { verticalPosition: "top", duration: 2e3 }), this.dialogRef.close() }, t => { console.log(t) }) } } return t.\u0275fac = function (e) { return new (e || t)(bo(qC), bo(qw), bo(Ok), bo(zC)) }, t.\u0275cmp = zt({ type: t, selectors: [["app-delete-todo"]], decls: 9, vars: 0, consts: [["mat-dialog-title", "", 1, "fw-bold", "text-dark", "font-bold", "has-text-primary"], [1, "mat-typography", "fw-bold", "font-bold", "text-dark"], ["align", "end"], ["mat-button", "", "mat-dialog-close", "", 1, "button", "btn", "px-2", "text-black", "is-success", "font-bold", "btn-sm"], ["mat-button", "", 1, "button", "btn", "text-black", "px-2", "is-success", "font-bold", "btn-sm", 3, "click"]], template: function (t, e) { 1 & t && (Co(0, "h2", 0), ra(1, "Delete Todo"), ko(), Co(2, "mat-dialog-content", 1), ra(3, " Are you sure you want to delete this todo ?\n"), ko(), Co(4, "mat-dialog-actions", 2), Co(5, "button", 3), ra(6, "Cancel"), ko(), Co(7, "button", 4), Io("click", function () { return e.onClickDelete() }), ra(8, "Yes"), ko(), ko()) }, directives: [JC, tk, ek, ck, XC], styles: [""] }), t })(); const iE = ["input"], sE = function (t) { return { enterDuration: t } }, rE = ["*"], oE = new $n("mat-checkbox-default-options", { providedIn: "root", factory: aE }); function aE() { return { color: "accent", clickAction: "check-indeterminate" } } let lE = 0; const cE = aE(), hE = { provide: Nk, useExisting: rt(() => fE), multi: !0 }; class uE { } class dE { constructor(t) { this._elementRef = t } } const pE = dv(hv(uv(cv(dE)))); let fE = (() => { class t extends pE { constructor(t, e, n, i, s, r, o) { super(t), this._changeDetectorRef = e, this._focusMonitor = n, this._ngZone = i, this._animationMode = r, this._options = o, this.ariaLabel = "", this.ariaLabelledby = null, this._uniqueId = "mat-checkbox-" + ++lE, this.id = this._uniqueId, this.labelPosition = "after", this.name = null, this.change = new Ml, this.indeterminateChange = new Ml, this._onTouched = () => { }, this._currentAnimationClass = "", this._currentCheckState = 0, this._controlValueAccessorChangeFn = () => { }, this._checked = !1, this._disabled = !1, this._indeterminate = !1, this._options = this._options || cE, this.color = this.defaultColor = this._options.color || cE.color, this.tabIndex = parseInt(s) || 0 } get inputId() { return `${this.id || this._uniqueId}-input` } get required() { return this._required } set required(t) { this._required = lm(t) } ngAfterViewInit() { this._focusMonitor.monitor(this._elementRef, !0).subscribe(t => { t || Promise.resolve().then(() => { this._onTouched(), this._changeDetectorRef.markForCheck() }) }), this._syncIndeterminate(this._indeterminate) } ngAfterViewChecked() { } ngOnDestroy() { this._focusMonitor.stopMonitoring(this._elementRef) } get checked() { return this._checked } set checked(t) { t != this.checked && (this._checked = t, this._changeDetectorRef.markForCheck()) } get disabled() { return this._disabled } set disabled(t) { const e = lm(t); e !== this.disabled && (this._disabled = e, this._changeDetectorRef.markForCheck()) } get indeterminate() { return this._indeterminate } set indeterminate(t) { const e = t != this._indeterminate; this._indeterminate = lm(t), e && (this._transitionCheckState(this._indeterminate ? 3 : this.checked ? 1 : 2), this.indeterminateChange.emit(this._indeterminate)), this._syncIndeterminate(this._indeterminate) } _isRippleDisabled() { return this.disableRipple || this.disabled } _onLabelTextChange() { this._changeDetectorRef.detectChanges() } writeValue(t) { this.checked = !!t } registerOnChange(t) { this._controlValueAccessorChangeFn = t } registerOnTouched(t) { this._onTouched = t } setDisabledState(t) { this.disabled = t } _getAriaChecked() { return this.checked ? "true" : this.indeterminate ? "mixed" : "false" } _transitionCheckState(t) { let e = this._currentCheckState, n = this._elementRef.nativeElement; if (e !== t && (this._currentAnimationClass.length > 0 && n.classList.remove(this._currentAnimationClass), this._currentAnimationClass = this._getAnimationClassForCheckStateTransition(e, t), this._currentCheckState = t, this._currentAnimationClass.length > 0)) { n.classList.add(this._currentAnimationClass); const t = this._currentAnimationClass; this._ngZone.runOutsideAngular(() => { setTimeout(() => { n.classList.remove(t) }, 1e3) }) } } _emitChangeEvent() { const t = new uE; t.source = this, t.checked = this.checked, this._controlValueAccessorChangeFn(this.checked), this.change.emit(t), this._inputElement && (this._inputElement.nativeElement.checked = this.checked) } toggle() { this.checked = !this.checked } _onInputClick(t) { var e; const n = null === (e = this._options) || void 0 === e ? void 0 : e.clickAction; t.stopPropagation(), this.disabled || "noop" === n ? this.disabled || "noop" !== n || (this._inputElement.nativeElement.checked = this.checked, this._inputElement.nativeElement.indeterminate = this.indeterminate) : (this.indeterminate && "check" !== n && Promise.resolve().then(() => { this._indeterminate = !1, this.indeterminateChange.emit(this._indeterminate) }), this.toggle(), this._transitionCheckState(this._checked ? 1 : 2), this._emitChangeEvent()) } focus(t, e) { t ? this._focusMonitor.focusVia(this._inputElement, t, e) : this._inputElement.nativeElement.focus(e) } _onInteractionEvent(t) { t.stopPropagation() } _getAnimationClassForCheckStateTransition(t, e) { if ("NoopAnimations" === this._animationMode) return ""; let n = ""; switch (t) { case 0: if (1 === e) n = "unchecked-checked"; else { if (3 != e) return ""; n = "unchecked-indeterminate" } break; case 2: n = 1 === e ? "unchecked-checked" : "unchecked-indeterminate"; break; case 1: n = 2 === e ? "checked-unchecked" : "checked-indeterminate"; break; case 3: n = 1 === e ? "indeterminate-checked" : "indeterminate-unchecked" }return `mat-checkbox-anim-${n}` } _syncIndeterminate(t) { const e = this._inputElement; e && (e.nativeElement.indeterminate = t) } } return t.\u0275fac = function (e) { return new (e || t)(bo(Ma), bo(ol), bo(o_), bo(vc), Hn("tabindex"), bo(Xb, 8), bo(oE, 8)) }, t.\u0275cmp = zt({ type: t, selectors: [["mat-checkbox"]], viewQuery: function (t, e) { if (1 & t && (Kl(iE, 5), Kl(Nv, 5)), 2 & t) { let t; Wl(t = Zl()) && (e._inputElement = t.first), Wl(t = Zl()) && (e.ripple = t.first) } }, hostAttrs: [1, "mat-checkbox"], hostVars: 12, hostBindings: function (t, e) { 2 & t && (ha("id", e.id), mo("tabindex", null), Ko("mat-checkbox-indeterminate", e.indeterminate)("mat-checkbox-checked", e.checked)("mat-checkbox-disabled", e.disabled)("mat-checkbox-label-before", "before" == e.labelPosition)("_mat-animation-noopable", "NoopAnimations" === e._animationMode)) }, inputs: { disableRipple: "disableRipple", color: "color", tabIndex: "tabIndex", ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], id: "id", labelPosition: "labelPosition", name: "name", required: "required", checked: "checked", disabled: "disabled", indeterminate: "indeterminate", ariaDescribedby: ["aria-describedby", "ariaDescribedby"], value: "value" }, outputs: { change: "change", indeterminateChange: "indeterminateChange" }, exportAs: ["matCheckbox"], features: [Ta([hE]), so], ngContentSelectors: rE, decls: 17, vars: 21, consts: [[1, "mat-checkbox-layout"], ["label", ""], [1, "mat-checkbox-inner-container"], ["type", "checkbox", 1, "mat-checkbox-input", "cdk-visually-hidden", 3, "id", "required", "checked", "disabled", "tabIndex", "change", "click"], ["input", ""], ["matRipple", "", 1, "mat-checkbox-ripple", "mat-focus-indicator", 3, "matRippleTrigger", "matRippleDisabled", "matRippleRadius", "matRippleCentered", "matRippleAnimation"], [1, "mat-ripple-element", "mat-checkbox-persistent-ripple"], [1, "mat-checkbox-frame"], [1, "mat-checkbox-background"], ["version", "1.1", "focusable", "false", "viewBox", "0 0 24 24", 0, "xml", "space", "preserve", 1, "mat-checkbox-checkmark"], ["fill", "none", "stroke", "white", "d", "M4.1,12.7 9,17.6 20.3,6.3", 1, "mat-checkbox-checkmark-path"], [1, "mat-checkbox-mixedmark"], [1, "mat-checkbox-label", 3, "cdkObserveContent"], ["checkboxLabel", ""], [2, "display", "none"]], template: function (t, e) { if (1 & t && (Vo(), Co(0, "label", 0, 1), Co(2, "span", 2), Co(3, "input", 3, 4), Io("change", function (t) { return e._onInteractionEvent(t) })("click", function (t) { return e._onInputClick(t) }), ko(), Co(5, "span", 5), xo(6, "span", 6), ko(), xo(7, "span", 7), Co(8, "span", 8), Te.lFrame.currentNamespace = pe, Co(9, "svg", 9), xo(10, "path", 10), ko(), Te.lFrame.currentNamespace = null, xo(11, "span", 11), ko(), ko(), Co(12, "span", 12, 13), Io("cdkObserveContent", function () { return e._onLabelTextChange() }), Co(14, "span", 14), ra(15, "\xa0"), ko(), jo(16), ko(), ko()), 2 & t) { const t = yo(1), o = yo(13); mo("for", e.inputId), qs(2), Ko("mat-checkbox-inner-container-no-side-margin", !o.textContent || !o.textContent.trim()), qs(1), vo("id", e.inputId)("required", e.required)("checked", e.checked)("disabled", e.disabled)("tabIndex", e.tabIndex), mo("value", e.value)("name", e.name)("aria-label", e.ariaLabel || null)("aria-labelledby", e.ariaLabelledby)("aria-checked", e._getAriaChecked())("aria-describedby", e.ariaDescribedby), qs(2), vo("matRippleTrigger", t)("matRippleDisabled", e._isRippleDisabled())("matRippleRadius", 20)("matRippleCentered", !0)("matRippleAnimation", (n = 19, i = sE, s = "NoopAnimations" === e._animationMode ? 0 : 150, function (t, e, n, i, s, r) { const o = e + n; return fo(t, o, s) ? function (t, e, n) { return t[e] = n }(t, o + 1, r ? i.call(r, s) : i(s)) : function (t, e) { const n = t[e]; return n === $s ? void 0 : n }(t, o + 1) }(Ae(), function () { const t = Te.lFrame; let e = t.bindingRootIndex; return -1 === e && (e = t.bindingRootIndex = t.tView.bindingStartIndex), e }(), n, i, s, r))) } var n, i, s, r }, directives: [Nv, qg], styles: ["@keyframes mat-checkbox-fade-in-background{0%{opacity:0}50%{opacity:1}}@keyframes mat-checkbox-fade-out-background{0%,50%{opacity:1}100%{opacity:0}}@keyframes mat-checkbox-unchecked-checked-checkmark-path{0%,50%{stroke-dashoffset:22.910259}50%{animation-timing-function:cubic-bezier(0, 0, 0.2, 0.1)}100%{stroke-dashoffset:0}}@keyframes mat-checkbox-unchecked-indeterminate-mixedmark{0%,68.2%{transform:scaleX(0)}68.2%{animation-timing-function:cubic-bezier(0, 0, 0, 1)}100%{transform:scaleX(1)}}@keyframes mat-checkbox-checked-unchecked-checkmark-path{from{animation-timing-function:cubic-bezier(0.4, 0, 1, 1);stroke-dashoffset:0}to{stroke-dashoffset:-22.910259}}@keyframes mat-checkbox-checked-indeterminate-checkmark{from{animation-timing-function:cubic-bezier(0, 0, 0.2, 0.1);opacity:1;transform:rotate(0deg)}to{opacity:0;transform:rotate(45deg)}}@keyframes mat-checkbox-indeterminate-checked-checkmark{from{animation-timing-function:cubic-bezier(0.14, 0, 0, 1);opacity:0;transform:rotate(45deg)}to{opacity:1;transform:rotate(360deg)}}@keyframes mat-checkbox-checked-indeterminate-mixedmark{from{animation-timing-function:cubic-bezier(0, 0, 0.2, 0.1);opacity:0;transform:rotate(-45deg)}to{opacity:1;transform:rotate(0deg)}}@keyframes mat-checkbox-indeterminate-checked-mixedmark{from{animation-timing-function:cubic-bezier(0.14, 0, 0, 1);opacity:1;transform:rotate(0deg)}to{opacity:0;transform:rotate(315deg)}}@keyframes mat-checkbox-indeterminate-unchecked-mixedmark{0%{animation-timing-function:linear;opacity:1;transform:scaleX(1)}32.8%,100%{opacity:0;transform:scaleX(0)}}.mat-checkbox-background,.mat-checkbox-frame{top:0;left:0;right:0;bottom:0;position:absolute;border-radius:2px;box-sizing:border-box;pointer-events:none}.mat-checkbox{display:inline-block;transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);cursor:pointer;-webkit-tap-highlight-color:transparent}._mat-animation-noopable.mat-checkbox{transition:none;animation:none}.mat-checkbox .mat-ripple-element:not(.mat-checkbox-persistent-ripple){opacity:.16}.mat-checkbox .mat-checkbox-ripple{position:absolute;left:calc(50% - 20px);top:calc(50% - 20px);height:40px;width:40px;z-index:1;pointer-events:none}.cdk-high-contrast-active .mat-checkbox.cdk-keyboard-focused .mat-checkbox-ripple{outline:solid 3px}.mat-checkbox-layout{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:inherit;align-items:baseline;vertical-align:middle;display:inline-flex;white-space:nowrap}.mat-checkbox-label{-webkit-user-select:auto;-moz-user-select:auto;-ms-user-select:auto;user-select:auto}.mat-checkbox-inner-container{display:inline-block;height:16px;line-height:0;margin:auto;margin-right:8px;order:0;position:relative;vertical-align:middle;white-space:nowrap;width:16px;flex-shrink:0}[dir=rtl] .mat-checkbox-inner-container{margin-left:8px;margin-right:auto}.mat-checkbox-inner-container-no-side-margin{margin-left:0;margin-right:0}.mat-checkbox-frame{background-color:transparent;transition:border-color 90ms cubic-bezier(0, 0, 0.2, 0.1);border-width:2px;border-style:solid}._mat-animation-noopable .mat-checkbox-frame{transition:none}.mat-checkbox-background{align-items:center;display:inline-flex;justify-content:center;transition:background-color 90ms cubic-bezier(0, 0, 0.2, 0.1),opacity 90ms cubic-bezier(0, 0, 0.2, 0.1);-webkit-print-color-adjust:exact;color-adjust:exact}._mat-animation-noopable .mat-checkbox-background{transition:none}.cdk-high-contrast-active .mat-checkbox .mat-checkbox-background{background:none}.mat-checkbox-persistent-ripple{display:block;width:100%;height:100%;transform:none}.mat-checkbox-inner-container:hover .mat-checkbox-persistent-ripple{opacity:.04}.mat-checkbox.cdk-keyboard-focused .mat-checkbox-persistent-ripple{opacity:.12}.mat-checkbox-persistent-ripple,.mat-checkbox.mat-checkbox-disabled .mat-checkbox-inner-container:hover .mat-checkbox-persistent-ripple{opacity:0}@media(hover: none){.mat-checkbox-inner-container:hover .mat-checkbox-persistent-ripple{display:none}}.mat-checkbox-checkmark{top:0;left:0;right:0;bottom:0;position:absolute;width:100%}.mat-checkbox-checkmark-path{stroke-dashoffset:22.910259;stroke-dasharray:22.910259;stroke-width:2.1333333333px}.cdk-high-contrast-black-on-white .mat-checkbox-checkmark-path{stroke:#000 !important}.mat-checkbox-mixedmark{width:calc(100% - 6px);height:2px;opacity:0;transform:scaleX(0) rotate(0deg);border-radius:2px}.cdk-high-contrast-active .mat-checkbox-mixedmark{height:0;border-top:solid 2px;margin-top:2px}.mat-checkbox-label-before .mat-checkbox-inner-container{order:1;margin-left:8px;margin-right:auto}[dir=rtl] .mat-checkbox-label-before .mat-checkbox-inner-container{margin-left:auto;margin-right:8px}.mat-checkbox-checked .mat-checkbox-checkmark{opacity:1}.mat-checkbox-checked .mat-checkbox-checkmark-path{stroke-dashoffset:0}.mat-checkbox-checked .mat-checkbox-mixedmark{transform:scaleX(1) rotate(-45deg)}.mat-checkbox-indeterminate .mat-checkbox-checkmark{opacity:0;transform:rotate(45deg)}.mat-checkbox-indeterminate .mat-checkbox-checkmark-path{stroke-dashoffset:0}.mat-checkbox-indeterminate .mat-checkbox-mixedmark{opacity:1;transform:scaleX(1) rotate(0deg)}.mat-checkbox-unchecked .mat-checkbox-background{background-color:transparent}.mat-checkbox-disabled{cursor:default}.cdk-high-contrast-active .mat-checkbox-disabled{opacity:.5}.mat-checkbox-anim-unchecked-checked .mat-checkbox-background{animation:180ms linear 0ms mat-checkbox-fade-in-background}.mat-checkbox-anim-unchecked-checked .mat-checkbox-checkmark-path{animation:180ms linear 0ms mat-checkbox-unchecked-checked-checkmark-path}.mat-checkbox-anim-unchecked-indeterminate .mat-checkbox-background{animation:180ms linear 0ms mat-checkbox-fade-in-background}.mat-checkbox-anim-unchecked-indeterminate .mat-checkbox-mixedmark{animation:90ms linear 0ms mat-checkbox-unchecked-indeterminate-mixedmark}.mat-checkbox-anim-checked-unchecked .mat-checkbox-background{animation:180ms linear 0ms mat-checkbox-fade-out-background}.mat-checkbox-anim-checked-unchecked .mat-checkbox-checkmark-path{animation:90ms linear 0ms mat-checkbox-checked-unchecked-checkmark-path}.mat-checkbox-anim-checked-indeterminate .mat-checkbox-checkmark{animation:90ms linear 0ms mat-checkbox-checked-indeterminate-checkmark}.mat-checkbox-anim-checked-indeterminate .mat-checkbox-mixedmark{animation:90ms linear 0ms mat-checkbox-checked-indeterminate-mixedmark}.mat-checkbox-anim-indeterminate-checked .mat-checkbox-checkmark{animation:500ms linear 0ms mat-checkbox-indeterminate-checked-checkmark}.mat-checkbox-anim-indeterminate-checked .mat-checkbox-mixedmark{animation:500ms linear 0ms mat-checkbox-indeterminate-checked-mixedmark}.mat-checkbox-anim-indeterminate-unchecked .mat-checkbox-background{animation:180ms linear 0ms mat-checkbox-fade-out-background}.mat-checkbox-anim-indeterminate-unchecked .mat-checkbox-mixedmark{animation:300ms linear 0ms mat-checkbox-indeterminate-unchecked-mixedmark}.mat-checkbox-input{bottom:0;left:50%}\n"], encapsulation: 2, changeDetection: 0 }), t })(), mE = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({}), t })(), gE = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ imports: [[Fv, lv, Wg, mE], lv, mE] }), t })(); function _E(t, e) { 1 & t && (Co(0, "mat-error"), ra(1, " title is "), Co(2, "strong"), ra(3, "required"), ko(), ko()) } let yE = (() => { class t { constructor(t, e, n, i) { this.data = t, this.service = e, this.snackBar = n, this.dialogRef = i, this.todo = t.todo } ngOnInit() { } check1(t) { t.isCompleted && (t.isCompleted = !t.isCompleted) } check2(t) { t.progress && (t.progress = !t.progress) } onClickUpdate() { this.service.updateTodo(this.todo).subscribe(t => { console.log(t), this.snackBar.open("Todo Updated Successfully.", "close", { verticalPosition: "top", duration: 2e3 }), this.dialogRef.close() }, t => { console.log(t) }) } } return t.\u0275fac = function (e) { return new (e || t)(bo(qC), bo(qw), bo(Ok), bo(zC)) }, t.\u0275cmp = zt({ type: t, selectors: [["app-update-todo"]], decls: 52, vars: 9, consts: [["mat-dialog-title", "", 1, "fw-bold", "text-dark", "font-bold", "has-text-primary"], [1, "mat-typography"], ["novalidate", "", 1, "example-form"], ["form", "ngForm"], [1, "example-full-width"], [1, "fw-bold", "text-dark", "font-bold"], ["matInput", "", "placeholder", "title", "name", "title", "required", "", 1, "fw-normal", "text-dark", "font-bold", 3, "ngModel", "ngModelChange"], ["title", "ngModel"], [4, "ngIf"], ["matInput", "", "placeholder", "description", "name", "description", 1, "fw-normal", "text-dark", "font-bold", 3, "ngModel", "ngModelChange"], ["description", "ngModel"], [1, "example-form"], ["type", "date", "matInput", "", "placeholder", "start date", "name", "start", 1, "fw-normal", "text-dark", "font-bold", "input-group-append", 3, "ngModel", "ngModelChange"], ["start", "ngModel"], ["type", "date", "matInput", "", "placeholder", "due date", "name", "due", 1, "fw-normal", "text-dark", "font-bold", "input-group-append", 3, "ngModel", "ngModelChange"], ["due", "ngModel"], [1, "mb-3"], ["type", "text", "matInput", "", "placeholder", "tag", "name", "tag", 1, "fw-normal", "text-dark", "font-bold", 3, "ngModel", "ngModelChange"], ["tag", "ngModel"], ["value", "Urgent"], ["value", "Important"], ["value", "Today"], ["value", "Urgent & Important"], ["value", "Nothing"], ["color", "primary", "name", "isCompleted", 1, "fw-bold", "text-dark", "d-flex", "flex-row", "font-bold", 3, "ngModel", "ngModelChange", "click"], ["color", "primary", "name", "Progress", 1, "fw-bold", "mt-3", "text-dark", "font-bold", 3, "ngModel", "ngModelChange", "click"], ["align", "end"], ["mat-button", "", "mat-dialog-close", "", 1, "button", "btn", "px-2", "text-dark", "is-success", "font-bold", "btn-sm"], ["mat-button", "", 1, "button", "btn", "text-dark", "px-2", "is-success", "font-bold", "btn-sm", 3, "disabled", "click"]], template: function (t, e) { if (1 & t && (Co(0, "h2", 0), ra(1, "Add Todo"), ko(), Co(2, "mat-dialog-content", 1), Co(3, "form", 2, 3), Co(5, "mat-form-field", 4), Co(6, "mat-label", 5), ra(7, "Title"), ko(), Co(8, "input", 6, 7), Io("ngModelChange", function (t) { return e.todo.title = t }), ko(), _o(10, _E, 4, 0, "mat-error", 8), ko(), Co(11, "mat-form-field", 4), Co(12, "mat-label", 5), ra(13, "Description"), ko(), Co(14, "textarea", 9, 10), Io("ngModelChange", function (t) { return e.todo.description = t }), ko(), ko(), Co(16, "mat-form-field", 11), Co(17, "mat-label", 5), ra(18, "Start Date"), ko(), Co(19, "input", 12, 13), Io("ngModelChange", function (t) { return e.todo.start = t }), ko(), ko(), xo(21, "br"), Co(22, "mat-form-field", 11), Co(23, "mat-label", 5), ra(24, "Due Date"), ko(), Co(25, "input", 14, 15), Io("ngModelChange", function (t) { return e.todo.due = t }), ko(), ko(), Co(27, "div", 16), Co(28, "mat-form-field"), Co(29, "mat-label", 5), ra(30, "Select a tag"), ko(), Co(31, "mat-select", 17, 18), Io("ngModelChange", function (t) { return e.todo.tag = t }), Co(33, "mat-option", 19), ra(34, "Urgent \ud83d\udfe3"), ko(), Co(35, "mat-option", 20), ra(36, "Important \ud83d\udfe2 "), ko(), Co(37, "mat-option", 21), ra(38, "Today \ud83d\udd35"), ko(), Co(39, "mat-option", 22), ra(40, "Urgent & Important \ud83d\udd34"), ko(), Co(41, "mat-option", 23), ra(42, "Nothing \ud83d\udfe1"), ko(), ko(), ko(), ko(), Co(43, "mat-checkbox", 24), Io("ngModelChange", function (t) { return e.todo.isCompleted = t })("click", function () { return e.check2(e.todo) }), ra(44, "Task Completed"), ko(), Co(45, "mat-checkbox", 25), Io("ngModelChange", function (t) { return e.todo.progress = t })("click", function () { return e.check1(e.todo) }), ra(46, "Task In Progress"), ko(), ko(), ko(), Co(47, "mat-dialog-actions", 26), Co(48, "button", 27), ra(49, "Cancel"), ko(), Co(50, "button", 28), Io("click", function () { return e.onClickUpdate() }), ra(51, "Update Todo"), ko(), ko()), 2 & t) { const t = yo(4), n = yo(9); qs(8), vo("ngModel", e.todo.title), qs(2), vo("ngIf", n.invalid && (n.dirty || n.touched)), qs(4), vo("ngModel", e.todo.description), qs(5), vo("ngModel", e.todo.start), qs(6), vo("ngModel", e.todo.due), qs(6), vo("ngModel", e.todo.tag), qs(12), vo("ngModel", e.todo.isCompleted), qs(2), vo("ngModel", e.todo.progress), qs(5), vo("disabled", !t.form.valid) } }, directives: [JC, tk, Ix, nx, Tx, vS, hS, OS, Vk, Lx, ex, Ox, Ch, XS, Yv, fE, ek, ck, XC, oS], styles: [".example-full-width[_ngcontent-%COMP%]{width:100%}"] }), t })(), bE = (() => { class t { constructor(t, e) { this.data = t, this.snackBar = e, this.color = "has-background-primary", this.desc = t.todo_desc } ngOnInit() { this.onDescription() } onDescription() { this.snackBar.open("Todo Description", "close", { verticalPosition: "top", duration: 2e3 }) } } return t.\u0275fac = function (e) { return new (e || t)(bo(qC), bo(Ok)) }, t.\u0275cmp = zt({ type: t, selectors: [["app-showmore"]], decls: 7, vars: 1, consts: [["mat-dialog-title", "", 1, "example-form", "fw-bold", "text-dark", "font-bold", "has-text-primary"], [1, "mat-typography", "fs-6", "fw-bold", "has-text-grey", "font-bold"], ["align", "end"], ["mat-button", "", "mat-dialog-close", "", 1, "button", "btn", "px-2", "text-black", "is-success", "font-bold", "btn-sm"]], template: function (t, e) { 1 & t && (Co(0, "h2", 0), ra(1, "Todo Description"), ko(), Co(2, "mat-dialog-content", 1), ra(3), ko(), Co(4, "mat-dialog-actions", 2), Co(5, "button", 3), ra(6, "Cancel"), ko(), ko()), 2 & t && (qs(3), aa(" ", e.desc, "\n")) }, directives: [JC, tk, ek, ck, XC], styles: [""] }), t })(); const vE = ["*"]; function wE(t) { return Error(`Unable to find icon with the name "${t}"`) } function CE(t) { return Error(`The URL provided to MatIconRegistry was not trusted as a resource URL via Angular's DomSanitizer. Attempted URL was "${t}".`) } function kE(t) { return Error(`The literal provided to MatIconRegistry was not trusted as safe HTML by Angular's DomSanitizer. Attempted literal was "${t}".`) } class xE { constructor(t, e, n) { this.url = t, this.svgText = e, this.options = n } } let SE = (() => { class t { constructor(t, e, n, i) { this._httpClient = t, this._sanitizer = e, this._errorHandler = i, this._svgIconConfigs = new Map, this._iconSetConfigs = new Map, this._cachedIconsByUrl = new Map, this._inProgressUrlFetches = new Map, this._fontCssClassesByAlias = new Map, this._resolvers = [], this._defaultFontSetClass = "material-icons", this._document = n } addSvgIcon(t, e, n) { return this.addSvgIconInNamespace("", t, e, n) } addSvgIconLiteral(t, e, n) { return this.addSvgIconLiteralInNamespace("", t, e, n) } addSvgIconInNamespace(t, e, n, i) { return this._addSvgIconConfig(t, e, new xE(n, null, i)) } addSvgIconResolver(t) { return this._resolvers.push(t), this } addSvgIconLiteralInNamespace(t, e, n, i) { const s = this._sanitizer.sanitize(Yi.HTML, n); if (!s) throw kE(n); return this._addSvgIconConfig(t, e, new xE("", s, i)) } addSvgIconSet(t, e) { return this.addSvgIconSetInNamespace("", t, e) } addSvgIconSetLiteral(t, e) { return this.addSvgIconSetLiteralInNamespace("", t, e) } addSvgIconSetInNamespace(t, e, n) { return this._addSvgIconSetConfig(t, new xE(e, null, n)) } addSvgIconSetLiteralInNamespace(t, e, n) { const i = this._sanitizer.sanitize(Yi.HTML, e); if (!i) throw kE(e); return this._addSvgIconSetConfig(t, new xE("", i, n)) } registerFontClassAlias(t, e = t) { return this._fontCssClassesByAlias.set(t, e), this } classNameForFontAlias(t) { return this._fontCssClassesByAlias.get(t) || t } setDefaultFontSetClass(t) { return this._defaultFontSetClass = t, this } getDefaultFontSetClass() { return this._defaultFontSetClass } getSvgIconFromUrl(t) { const e = this._sanitizer.sanitize(Yi.RESOURCE_URL, t); if (!e) throw CE(t); const n = this._cachedIconsByUrl.get(e); return n ? pu(EE(n)) : this._loadSvgIconFromConfig(new xE(t, null)).pipe(id(t => this._cachedIconsByUrl.set(e, t)), E(t => EE(t))) } getNamedSvgIcon(t, e = "") { const n = TE(e, t); let i = this._svgIconConfigs.get(n); if (i) return this._getSvgFromConfig(i); if (i = this._getIconConfigFromResolvers(e, t), i) return this._svgIconConfigs.set(n, i), this._getSvgFromConfig(i); const s = this._iconSetConfigs.get(e); return s ? this._getSvgFromIconSetConfigs(t, s) : (r = wE(n), new y(t => t.error(r))); var r } ngOnDestroy() { this._resolvers = [], this._svgIconConfigs.clear(), this._iconSetConfigs.clear(), this._cachedIconsByUrl.clear() } _getSvgFromConfig(t) { return t.svgText ? pu(EE(this._svgElementFromConfig(t))) : this._loadSvgIconFromConfig(t).pipe(E(t => EE(t))) } _getSvgFromIconSetConfigs(t, e) { const n = this._extractIconWithNameFromAnySet(t, e); return n ? pu(n) : Ik(e.filter(t => !t.svgText).map(t => this._loadSvgIconSetFromConfig(t).pipe(Hu(e => { const n = this._sanitizer.sanitize(Yi.RESOURCE_URL, t.url); return this._errorHandler.handleError(new Error(`Loading icon set URL: ${n} failed: ${e.message}`)), pu(null) })))).pipe(E(() => { const n = this._extractIconWithNameFromAnySet(t, e); if (!n) throw wE(t); return n })) } _extractIconWithNameFromAnySet(t, e) { for (let n = e.length - 1; n >= 0; n--) { const i = e[n]; if (i.svgText && i.svgText.indexOf(t) > -1) { const e = this._svgElementFromConfig(i), n = this._extractSvgIconFromSet(e, t, i.options); if (n) return n } } return null } _loadSvgIconFromConfig(t) { return this._fetchIcon(t).pipe(id(e => t.svgText = e), E(() => this._svgElementFromConfig(t))) } _loadSvgIconSetFromConfig(t) { return t.svgText ? pu(null) : this._fetchIcon(t).pipe(id(e => t.svgText = e)) } _extractSvgIconFromSet(t, e, n) { const i = t.querySelector(`[id="${e}"]`); if (!i) return null; const s = i.cloneNode(!0); if (s.removeAttribute("id"), "svg" === s.nodeName.toLowerCase()) return this._setSvgAttributes(s, n); if ("symbol" === s.nodeName.toLowerCase()) return this._setSvgAttributes(this._toSvgElement(s), n); const r = this._svgElementFromString("<svg></svg>"); return r.appendChild(s), this._setSvgAttributes(r, n) } _svgElementFromString(t) { const e = this._document.createElement("DIV"); e.innerHTML = t; const n = e.querySelector("svg"); if (!n) throw Error("<svg> tag not found"); return n } _toSvgElement(t) { const e = this._svgElementFromString("<svg></svg>"), n = t.attributes; for (let i = 0; i < n.length; i++) { const { name: t, value: s } = n[i]; "id" !== t && e.setAttribute(t, s) } for (let i = 0; i < t.childNodes.length; i++)t.childNodes[i].nodeType === this._document.ELEMENT_NODE && e.appendChild(t.childNodes[i].cloneNode(!0)); return e } _setSvgAttributes(t, e) { return t.setAttribute("fit", ""), t.setAttribute("height", "100%"), t.setAttribute("width", "100%"), t.setAttribute("preserveAspectRatio", "xMidYMid meet"), t.setAttribute("focusable", "false"), e && e.viewBox && t.setAttribute("viewBox", e.viewBox), t } _fetchIcon(t) { var e; const { url: n, options: i } = t, s = null !== (e = null == i ? void 0 : i.withCredentials) && void 0 !== e && e; if (!this._httpClient) throw Error("Could not find HttpClient provider for use with Angular Material icons. Please include the HttpClientModule from @angular/common/http in your app imports."); if (null == n) throw Error(`Cannot fetch icon from URL "${n}".`); const r = this._sanitizer.sanitize(Yi.RESOURCE_URL, n); if (!r) throw CE(n); const o = this._inProgressUrlFetches.get(r); if (o) return o; const a = this._httpClient.get(r, { responseType: "text", withCredentials: s }).pipe(od(() => this._inProgressUrlFetches.delete(r)), J()); return this._inProgressUrlFetches.set(r, a), a } _addSvgIconConfig(t, e, n) { return this._svgIconConfigs.set(TE(t, e), n), this } _addSvgIconSetConfig(t, e) { const n = this._iconSetConfigs.get(t); return n ? n.push(e) : this._iconSetConfigs.set(t, [e]), this } _svgElementFromConfig(t) { if (!t.svgElement) { const e = this._svgElementFromString(t.svgText); this._setSvgAttributes(e, t.options), t.svgElement = e } return t.svgElement } _getIconConfigFromResolvers(t, e) { for (let i = 0; i < this._resolvers.length; i++) { const s = this._resolvers[i](e, t); if (s) return (n = s).url && n.options ? new xE(s.url, null, s.options) : new xE(s, null) } var n } } return t.\u0275fac = function (e) { return new (e || t)(li(Iw, 8), li(au), li(Jc, 8), li(es)) }, t.\u0275prov = dt({ factory: function () { return new t(li(Iw, 8), li(au), li(Jc, 8), li(es)) }, token: t, providedIn: "root" }), t })(); function EE(t) { return t.cloneNode(!0) } function TE(t, e) { return t + ":" + e } class RE { constructor(t) { this._elementRef = t } } const AE = hv(RE), OE = new $n("mat-icon-location", { providedIn: "root", factory: function () { const t = ci(Jc), e = t ? t.location : null; return { getPathname: () => e ? e.pathname + e.search : "" } } }), IE = ["clip-path", "color-profile", "src", "cursor", "fill", "filter", "marker", "marker-start", "marker-mid", "marker-end", "mask", "stroke"], DE = IE.map(t => `[${t}]`).join(", "), PE = /^url\(['"]?#(.*?)['"]?\)$/; let ME = (() => { class t extends AE { constructor(t, e, n, i, s) { super(t), this._iconRegistry = e, this._location = i, this._errorHandler = s, this._inline = !1, this._currentIconFetch = u.EMPTY, n || t.nativeElement.setAttribute("aria-hidden", "true") } get inline() { return this._inline } set inline(t) { this._inline = lm(t) } get svgIcon() { return this._svgIcon } set svgIcon(t) { t !== this._svgIcon && (t ? this._updateSvgIcon(t) : this._svgIcon && this._clearSvgElement(), this._svgIcon = t) } get fontSet() { return this._fontSet } set fontSet(t) { const e = this._cleanupFontValue(t); e !== this._fontSet && (this._fontSet = e, this._updateFontIconClasses()) } get fontIcon() { return this._fontIcon } set fontIcon(t) { const e = this._cleanupFontValue(t); e !== this._fontIcon && (this._fontIcon = e, this._updateFontIconClasses()) } _splitIconName(t) { if (!t) return ["", ""]; const e = t.split(":"); switch (e.length) { case 1: return ["", e[0]]; case 2: return e; default: throw Error(`Invalid icon name: "${t}"`) } } ngOnInit() { this._updateFontIconClasses() } ngAfterViewChecked() { const t = this._elementsWithExternalReferences; if (t && t.size) { const t = this._location.getPathname(); t !== this._previousPath && (this._previousPath = t, this._prependPathToReferences(t)) } } ngOnDestroy() { this._currentIconFetch.unsubscribe(), this._elementsWithExternalReferences && this._elementsWithExternalReferences.clear() } _usingFontIcon() { return !this.svgIcon } _setSvgElement(t) { this._clearSvgElement(); const e = t.querySelectorAll("style"); for (let i = 0; i < e.length; i++)e[i].textContent += " "; const n = this._location.getPathname(); this._previousPath = n, this._cacheChildrenWithExternalReferences(t), this._prependPathToReferences(n), this._elementRef.nativeElement.appendChild(t) } _clearSvgElement() { const t = this._elementRef.nativeElement; let e = t.childNodes.length; for (this._elementsWithExternalReferences && this._elementsWithExternalReferences.clear(); e--;) { const n = t.childNodes[e]; 1 === n.nodeType && "svg" !== n.nodeName.toLowerCase() || t.removeChild(n) } } _updateFontIconClasses() { if (!this._usingFontIcon()) return; const t = this._elementRef.nativeElement, e = this.fontSet ? this._iconRegistry.classNameForFontAlias(this.fontSet) : this._iconRegistry.getDefaultFontSetClass(); e != this._previousFontSetClass && (this._previousFontSetClass && t.classList.remove(this._previousFontSetClass), e && t.classList.add(e), this._previousFontSetClass = e), this.fontIcon != this._previousFontIconClass && (this._previousFontIconClass && t.classList.remove(this._previousFontIconClass), this.fontIcon && t.classList.add(this.fontIcon), this._previousFontIconClass = this.fontIcon) } _cleanupFontValue(t) { return "string" == typeof t ? t.trim().split(" ")[0] : t } _prependPathToReferences(t) { const e = this._elementsWithExternalReferences; e && e.forEach((e, n) => { e.forEach(e => { n.setAttribute(e.name, `url('${t}#${e.value}')`) }) }) } _cacheChildrenWithExternalReferences(t) { const e = t.querySelectorAll(DE), n = this._elementsWithExternalReferences = this._elementsWithExternalReferences || new Map; for (let i = 0; i < e.length; i++)IE.forEach(t => { const s = e[i], r = s.getAttribute(t), o = r ? r.match(PE) : null; if (o) { let e = n.get(s); e || (e = [], n.set(s, e)), e.push({ name: t, value: o[1] }) } }) } _updateSvgIcon(t) { if (this._svgNamespace = null, this._svgName = null, this._currentIconFetch.unsubscribe(), t) { const [e, n] = this._splitIconName(t); e && (this._svgNamespace = e), n && (this._svgName = n), this._currentIconFetch = this._iconRegistry.getNamedSvgIcon(n, e).pipe(Iu(1)).subscribe(t => this._setSvgElement(t), t => { this._errorHandler.handleError(new Error(`Error retrieving icon ${e}:${n}! ${t.message}`)) }) } } } return t.\u0275fac = function (e) { return new (e || t)(bo(Ma), bo(SE), Hn("aria-hidden"), bo(OE), bo(es)) }, t.\u0275cmp = zt({ type: t, selectors: [["mat-icon"]], hostAttrs: ["role", "img", 1, "mat-icon", "notranslate"], hostVars: 7, hostBindings: function (t, e) { 2 & t && (mo("data-mat-icon-type", e._usingFontIcon() ? "font" : "svg")("data-mat-icon-name", e._svgName || e.fontIcon)("data-mat-icon-namespace", e._svgNamespace || e.fontSet), Ko("mat-icon-inline", e.inline)("mat-icon-no-color", "primary" !== e.color && "accent" !== e.color && "warn" !== e.color)) }, inputs: { color: "color", inline: "inline", svgIcon: "svgIcon", fontSet: "fontSet", fontIcon: "fontIcon" }, exportAs: ["matIcon"], features: [so], ngContentSelectors: vE, decls: 1, vars: 0, template: function (t, e) { 1 & t && (Vo(), jo(0)) }, styles: [".mat-icon{background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}\n"], encapsulation: 2, changeDetection: 0 }), t })(), NE = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ imports: [[lv], lv] }), t })(); function FE(t, e) { 1 & t && (Co(0, "th", 46), ra(1, " Title"), ko()) } function LE(t, e) { if (1 & t && (Co(0, "td", 47), ra(1), ko()), 2 & t) { const t = e.$implicit; la(" ", Fo(2).color1, " fw-bold text-dark  pt-4 font-bold"), qs(1), aa("", t.title, " ") } } function VE(t, e) { 1 & t && (Co(0, "th", 48), ra(1, " Description"), ko()) } function jE(t, e) { if (1 & t && (Co(0, "span"), ra(1), ko()), 2 & t) { const t = Fo().$implicit; qs(1), aa(" ", t.description, " ") } } function BE(t, e) { if (1 & t) { const t = Ro(); Co(0, "span", 51), ra(1), Co(2, "img", 52), Io("click", function () { Ie(t); const e = Fo().$implicit; return Fo(2).openMsg(e.description) }), ko(), ko() } if (2 & t) { const t = Fo().$implicit, e = Fo(2); qs(1), aa(" ", t.description.substring(0, e.msg), "... ") } } function HE(t, e) { if (1 & t && (Co(0, "td", 47), _o(1, jE, 2, 1, "span", 49), _o(2, BE, 3, 1, "span", 50), ko()), 2 & t) { const t = e.$implicit, n = Fo(2); la("", n.color1, " fw-bold text-dark  pt-4 font-bold"), qs(1), vo("ngIf", t.description.length <= n.msg), qs(1), vo("ngIf", t.description.length > n.msg) } } function UE(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Start Date "), ko()) } function zE(t, e) { if (1 & t && (Co(0, "td", 47), ra(1), ko()), 2 & t) { const t = e.$implicit; la("", Fo(2).color1, " fw-bold text-dark  pt-4 font-bold"), qs(1), aa("", t.start, " ") } } function $E(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Task Status "), ko()) } function qE(t, e) { if (1 & t && (Co(0, "td", 47), Co(1, "span", 53), ra(2), ko(), ko()), 2 & t) { const t = e.$implicit, n = Fo(2); ca("", n.color1, " fw-bold ", n.Task(t), "  pt-4 font-bold"), qs(1), la("", n.col, " font-bold"), qs(1), aa(" ", n.task_status, "") } } function WE(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Due Date "), ko()) } function KE(t, e) { if (1 & t && (Co(0, "td", 47), ra(1), ko()), 2 & t) { const t = e.$implicit, n = Fo(2); ca("fw-bold ", n.color1, " text-dark ", n.onTag(t), "  pt-4 font-bold"), qs(1), aa("", t.due, " ") } } function YE(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Tag"), ko()) } function ZE(t, e) { if (1 & t && (Co(0, "td", 47), ra(1), ko()), 2 & t) { const t = e.$implicit, n = Fo(2); ca("fw-bold  ", n.color1, " ", n.tagcolor, "   pt-4 font-bold"), qs(1), aa(" ", t.tag, " ") } } function GE(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Status"), ko()) } function QE(t, e) { 1 & t && xo(0, "img", 57) } function XE(t, e) { 1 & t && (Co(0, "mat-icon", 58), ra(1, " check_circle "), ko()) } function JE(t, e) { 1 & t && (Co(0, "span", 59), xo(1, "i", 60), ko()) } function tT(t, e) { if (1 & t && (Co(0, "td", 47), _o(1, QE, 1, 0, "img", 54), _o(2, XE, 2, 0, "mat-icon", 55), _o(3, JE, 2, 0, "span", 56), ko()), 2 & t) { const t = e.$implicit; la("fw-bold ", Fo(2).color1, " text-success fs-4 pt-4  font-bold"), qs(1), vo("ngIf", !t.isCompleted && !t.progress), qs(1), vo("ngIf", t.isCompleted && !t.progress), qs(1), vo("ngIf", t.progress && !t.isCompleted) } } function eT(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Mark"), ko()) } function nT(t, e) { if (1 & t) { const t = Ro(); Co(0, "td", 47), Co(1, "mat-checkbox", 61), Io("ngModelChange", function (t) { return e.$implicit.isCompleted = t })("click", function () { const e = Ie(t).$implicit, n = Fo(2); return e.isCompleted = !e.isCompleted && n.check(e) }), ko(), ko() } if (2 & t) { const t = e.$implicit; la("fw-bold ", Fo(2).color1, " text-success fs-6 pt-4  font-bold"), qs(1), vo("ngModel", t.isCompleted) } } function iT(t, e) { if (1 & t) { const t = Ro(); Co(0, "mat-header-cell"), Co(1, "button", 62), Io("click", function () { return Ie(t), Fo(2).openAddDialog() }), Co(2, "mat-icon"), ra(3, "add"), ko(), ko(), ko() } 2 & t && (qs(1), vo("color", "primary")) } function sT(t, e) { if (1 & t) { const t = Ro(); Co(0, "mat-cell"), Co(1, "button", 62), Io("click", function () { const e = Ie(t).$implicit; return Fo(2).openUpdateDialog(e, !1) }), Co(2, "mat-icon"), ra(3, "edit"), ko(), ko(), Co(4, "button", 62), Io("click", function () { const e = Ie(t).$implicit; return Fo(2).openDeleteDialog(e) }), Co(5, "mat-icon", 58), ra(6, "delete"), ko(), ko(), ko() } 2 & t && (qs(1), vo("color", "dark"), qs(3), vo("color", "warn")) } function rT(t, e) { 1 & t && xo(0, "tr", 63) } function oT(t, e) { 1 & t && xo(0, "tr", 64) } function aT(t, e) { if (1 & t && (Co(0, "td", 66), ra(1), ko()), 2 & t) { Fo(3); const t = yo(30); qs(1), aa(" No results found for this text - ", t.value, " ") } } function lT(t, e) { if (1 & t && (Co(0, "tr"), _o(1, aT, 2, 1, "td", 65), ko()), 2 & t) { const t = Fo(2); qs(1), vo("ngIf", t.noncomp) } } function cT(t, e) { 1 & t && (Co(0, "div", 67), Co(1, "h3", 68), ra(2, " Todo List - Empty"), ko(), ko()) } function hT(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Title"), ko()) } function uT(t, e) { if (1 & t && (Co(0, "td", 47), ra(1), ko()), 2 & t) { const t = e.$implicit; la("fw-bold ", Fo(3).color2, " text-dark pt-4  font-bold"), qs(1), aa("", t.title, " ") } } function dT(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Description "), ko()) } function pT(t, e) { if (1 & t && (Co(0, "span"), ra(1), ko()), 2 & t) { const t = Fo().$implicit; qs(1), aa(" ", t.description, " ") } } function fT(t, e) { if (1 & t) { const t = Ro(); Co(0, "span", 51), ra(1), Co(2, "img", 52), Io("click", function () { Ie(t); const e = Fo().$implicit; return Fo(3).openMsg(e.description) }), ko(), ko() } if (2 & t) { const t = Fo().$implicit, e = Fo(3); qs(1), aa(" ", t.description.substring(0, e.msg), "... ") } } function mT(t, e) { if (1 & t && (Co(0, "td", 47), _o(1, pT, 2, 1, "span", 49), _o(2, fT, 3, 1, "span", 50), ko()), 2 & t) { const t = e.$implicit, n = Fo(3); la("fw-bold ", n.color2, " text-dark  pt-4 font-bold"), qs(1), vo("ngIf", t.description.length <= n.msg), qs(1), vo("ngIf", t.description.length > n.msg) } } function gT(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Start Date "), ko()) } function _T(t, e) { if (1 & t && (Co(0, "td", 47), ra(1), ko()), 2 & t) { const t = e.$implicit; la("fw-bold ", Fo(3).color2, " text-dark  pt-4 font-bold"), qs(1), aa("", t.start, " ") } } function yT(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Task Status "), ko()) } function bT(t, e) { if (1 & t && (Co(0, "td", 47), Co(1, "span", 53), ra(2), ko(), ko()), 2 & t) { const t = e.$implicit, n = Fo(3); ca("fw-bold text-dark ", n.color2, " ", n.Task(t), " pt-4 font-bold"), qs(1), la("", n.col, " font-bold"), qs(1), aa(" ", n.task_status, "") } } function vT(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Due Date "), ko()) } function wT(t, e) { if (1 & t && (Co(0, "td", 47), ra(1), ko()), 2 & t) { const t = e.$implicit, n = Fo(3); ca("fw-bold text-dark  ", n.color2, " ", n.onTag(t), " pt-4 font-bold"), qs(1), aa(" ", t.due, " ") } } function CT(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Tag"), ko()) } function kT(t, e) { if (1 & t && (Co(0, "td", 47), ra(1), ko()), 2 & t) { const t = e.$implicit, n = Fo(3); ca("fw-bold ", n.color2, " ", n.tagcolor, "  pt-4  font-bold"), qs(1), aa(" ", t.tag, " ") } } function xT(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Status"), ko()) } function ST(t, e) { 1 & t && xo(0, "img", 57) } function ET(t, e) { 1 & t && (Co(0, "mat-icon", 58), ra(1, " check_circle "), ko()) } function TT(t, e) { 1 & t && (Co(0, "span", 59), xo(1, "i", 60), ko()) } function RT(t, e) { if (1 & t && (Co(0, "td", 47), _o(1, ST, 1, 0, "img", 54), _o(2, ET, 2, 0, "mat-icon", 55), _o(3, TT, 2, 0, "span", 72), ko()), 2 & t) { const t = e.$implicit; la("fw-bold text-success ", Fo(3).color2, " fs-4 pt-4 font-bold"), qs(1), vo("ngIf", !t.isCompleted && !t.progress), qs(1), vo("ngIf", t.isCompleted && !t.progress), qs(1), vo("ngIf", t.progress && !t.isCompleted) } } function AT(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Unmark"), ko()) } function OT(t, e) { if (1 & t) { const t = Ro(); Co(0, "td", 47), Co(1, "mat-checkbox", 73), Io("ngModelChange", function (t) { return e.$implicit.isCompleted = t })("click", function () { const t = e.$implicit; return t.isCompleted == !t.isCompleted })("click", function () { const e = Ie(t).$implicit; return Fo(3).check(e) }), ko(), ko() } if (2 & t) { const t = e.$implicit; la("fw-bold ", Fo(3).color2, " text-success fs-6 pt-4  font-bold"), qs(1), vo("ngModel", t.isCompleted) } } function IT(t, e) { if (1 & t) { const t = Ro(); Co(0, "mat-header-cell"), Co(1, "button", 62), Io("click", function () { return Ie(t), Fo(3).openAddDialog() }), Co(2, "mat-icon"), ra(3, "add"), ko(), ko(), ko() } 2 & t && (qs(1), vo("color", "primary")) } function DT(t, e) { if (1 & t) { const t = Ro(); Co(0, "mat-cell"), Co(1, "button", 62), Io("click", function () { const e = Ie(t).$implicit; return Fo(3).openUpdateDialog(e, !0) }), Co(2, "mat-icon"), ra(3, "edit"), ko(), ko(), Co(4, "button", 62), Io("click", function () { const e = Ie(t).$implicit; return Fo(3).openDeleteDialog(e) }), Co(5, "mat-icon", 58), ra(6, "delete"), ko(), ko(), ko() } 2 & t && (qs(1), vo("color", "dark"), qs(3), vo("color", "warn")) } function PT(t, e) { 1 & t && xo(0, "tr", 63) } function MT(t, e) { 1 & t && xo(0, "tr", 64) } function NT(t, e) { if (1 & t && (Co(0, "td", 66), ra(1), ko()), 2 & t) { Fo(4); const t = yo(30); qs(1), aa(" No results found for this text - ", t.value, " ") } } function FT(t, e) { if (1 & t && (Co(0, "tr"), _o(1, NT, 2, 1, "td", 65), ko()), 2 & t) { const t = Fo(3); qs(1), vo("ngIf", t.comp) } } function LT(t, e) { 1 & t && (Co(0, "div", 67), Co(1, "h3", 68), ra(2, " No Completed Todos"), ko(), ko()) } function VT(t, e) { if (1 & t && (Co(0, "div", 69), Co(1, "h3", 70), ra(2, "Completed Todos "), Co(3, "span", 22), xo(4, "i", 71), ko(), ko(), Co(5, "table", 24), So(6, 25), _o(7, hT, 2, 0, "th", 32), _o(8, uT, 2, 4, "td", 27), Eo(), So(9, 28), _o(10, dT, 2, 0, "th", 32), _o(11, mT, 3, 5, "td", 27), Eo(), So(12, 30), _o(13, gT, 2, 0, "th", 32), _o(14, _T, 2, 4, "td", 27), Eo(), So(15, 31), _o(16, yT, 2, 0, "th", 32), _o(17, bT, 3, 8, "td", 27), Eo(), So(18, 33), _o(19, vT, 2, 0, "th", 29), _o(20, wT, 2, 5, "td", 27), Eo(), So(21, 34), _o(22, CT, 2, 0, "th", 29), _o(23, kT, 2, 5, "td", 27), Eo(), So(24, 35), _o(25, xT, 2, 0, "th", 29), _o(26, RT, 4, 6, "td", 27), Eo(), So(27, 37), _o(28, AT, 2, 0, "th", 36), _o(29, OT, 2, 4, "td", 27), Eo(), So(30, 38), _o(31, IT, 4, 1, "mat-header-cell", 39), _o(32, DT, 7, 2, "mat-cell", 40), Eo(), _o(33, PT, 1, 0, "tr", 41), _o(34, MT, 1, 0, "tr", 42), _o(35, FT, 2, 1, "tr", 43), ko(), _o(36, LT, 3, 0, "div", 44), ko()), 2 & t) { const t = Fo(2); qs(5), la("  mat-elevation-z8 ", t.action, " demo-table"), vo("dataSource", t.dataSource1), qs(28), vo("matHeaderRowDef", t.displayedColumns), qs(1), vo("matRowDefColumns", t.displayedColumns), qs(2), vo("ngIf", 0 == t.comp) } } function jT(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Title"), ko()) } function BT(t, e) { if (1 & t && (Co(0, "td", 47), ra(1), ko()), 2 & t) { const t = e.$implicit; la("fw-bold ", Fo(3).color3, " text-dark pt-4  font-bold"), qs(1), aa("", t.title, " ") } } function HT(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Description "), ko()) } function UT(t, e) { if (1 & t && (Co(0, "span"), ra(1), ko()), 2 & t) { const t = Fo().$implicit; qs(1), aa(" ", t.description, " ") } } function zT(t, e) { if (1 & t) { const t = Ro(); Co(0, "span", 51), ra(1), Co(2, "img", 52), Io("click", function () { Ie(t); const e = Fo().$implicit; return Fo(3).openMsg(e.description) }), ko(), ko() } if (2 & t) { const t = Fo().$implicit, e = Fo(3); qs(1), aa(" ", t.description.substring(0, e.msg), "... ") } } function $T(t, e) { if (1 & t && (Co(0, "td", 47), _o(1, UT, 2, 1, "span", 49), _o(2, zT, 3, 1, "span", 50), ko()), 2 & t) { const t = e.$implicit, n = Fo(3); la("fw-bold ", n.color3, " text-dark  pt-4 font-bold"), qs(1), vo("ngIf", t.description.length <= n.msg), qs(1), vo("ngIf", t.description.length > n.msg) } } function qT(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Start Date "), ko()) } function WT(t, e) { if (1 & t && (Co(0, "td", 47), ra(1), ko()), 2 & t) { const t = e.$implicit; la("fw-bold ", Fo(3).color3, " text-dark  pt-4 font-bold"), qs(1), aa("", t.start, " ") } } function KT(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Task Status "), ko()) } function YT(t, e) { if (1 & t && (Co(0, "td", 47), Co(1, "span", 53), ra(2), ko(), ko()), 2 & t) { const t = e.$implicit, n = Fo(3); ca("fw-bold text-dark ", n.color3, " ", n.Task(t), " pt-4 font-bold"), qs(1), la("", n.col, " font-bold"), qs(1), aa(" ", n.task_status, "") } } function ZT(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Due Date "), ko()) } function GT(t, e) { if (1 & t && (Co(0, "td", 47), ra(1), ko()), 2 & t) { const t = e.$implicit, n = Fo(3); ca("fw-bold text-dark  ", n.color3, " ", n.onTag(t), "  pt-4 font-bold"), qs(1), aa(" ", t.due, " ") } } function QT(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Tag"), ko()) } function XT(t, e) { if (1 & t && (Co(0, "td", 47), ra(1), ko()), 2 & t) { const t = e.$implicit, n = Fo(3); ca("fw-bold ", n.color3, " ", n.tagcolor, " pt-4 font-bold"), qs(1), aa("", t.tag, " ") } } function JT(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Status"), ko()) } function tR(t, e) { 1 & t && xo(0, "img", 57) } function eR(t, e) { 1 & t && (Co(0, "mat-icon", 58), ra(1, " check_circle "), ko()) } function nR(t, e) { 1 & t && (Co(0, "span", 78), xo(1, "i", 60), ko()) } function iR(t, e) { if (1 & t && (Co(0, "td", 47), _o(1, tR, 1, 0, "img", 54), _o(2, eR, 2, 0, "mat-icon", 55), _o(3, nR, 2, 0, "span", 77), ko()), 2 & t) { const t = e.$implicit; la("fw-bold text-success ", Fo(3).color3, " fs-4 pt-4 font-bold"), qs(1), vo("ngIf", !t.isCompleted && !t.progress), qs(1), vo("ngIf", t.isCompleted && !t.progress), qs(1), vo("ngIf", t.progress && !t.isCompleted) } } function sR(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Unmark"), ko()) } function rR(t, e) { if (1 & t) { const t = Ro(); Co(0, "td", 47), Co(1, "mat-checkbox", 73), Io("ngModelChange", function (t) { return e.$implicit.isCompleted = t })("click", function () { const t = e.$implicit; return t.isCompleted == !t.isCompleted })("click", function () { const e = Ie(t).$implicit; return Fo(3).check(e) }), ko(), ko() } if (2 & t) { const t = e.$implicit; la("fw-bold ", Fo(3).color3, " text-success fs-6 pt-4  font-bold"), qs(1), vo("ngModel", t.isCompleted) } } function oR(t, e) { if (1 & t) { const t = Ro(); Co(0, "mat-header-cell"), Co(1, "button", 62), Io("click", function () { return Ie(t), Fo(3).openAddDialog() }), Co(2, "mat-icon"), ra(3, "add"), ko(), ko(), ko() } 2 & t && (qs(1), vo("color", "primary")) } function aR(t, e) { if (1 & t) { const t = Ro(); Co(0, "mat-cell"), Co(1, "button", 62), Io("click", function () { const e = Ie(t).$implicit; return Fo(3).openUpdateDialog(e, !0) }), Co(2, "mat-icon"), ra(3, "edit"), ko(), ko(), Co(4, "button", 62), Io("click", function () { const e = Ie(t).$implicit; return Fo(3).openDeleteDialog(e) }), Co(5, "mat-icon", 58), ra(6, "delete"), ko(), ko(), ko() } 2 & t && (qs(1), vo("color", "dark"), qs(3), vo("color", "warn")) } function lR(t, e) { 1 & t && xo(0, "tr", 63) } function cR(t, e) { 1 & t && xo(0, "tr", 64) } function hR(t, e) { if (1 & t && (Co(0, "td", 66), ra(1), ko()), 2 & t) { Fo(4); const t = yo(30); qs(1), aa(" No results found for this text - ", t.value, " ") } } function uR(t, e) { if (1 & t && (Co(0, "tr"), _o(1, hR, 2, 1, "td", 65), ko()), 2 & t) { const t = Fo(3); qs(1), vo("ngIf", t.prog) } } function dR(t, e) { 1 & t && (Co(0, "div", 67), Co(1, "h3", 68), ra(2, " No Progress Todos"), ko(), ko()) } function pR(t, e) { if (1 & t && (Co(0, "div", 74), Co(1, "h3", 75), ra(2, "In Progress Todos "), Co(3, "span", 76), xo(4, "i", 60), ko(), ko(), Co(5, "table", 24), So(6, 25), _o(7, jT, 2, 0, "th", 32), _o(8, BT, 2, 4, "td", 27), Eo(), So(9, 28), _o(10, HT, 2, 0, "th", 32), _o(11, $T, 3, 5, "td", 27), Eo(), So(12, 30), _o(13, qT, 2, 0, "th", 32), _o(14, WT, 2, 4, "td", 27), Eo(), So(15, 31), _o(16, KT, 2, 0, "th", 32), _o(17, YT, 3, 8, "td", 27), Eo(), So(18, 33), _o(19, ZT, 2, 0, "th", 29), _o(20, GT, 2, 5, "td", 27), Eo(), So(21, 34), _o(22, QT, 2, 0, "th", 29), _o(23, XT, 2, 5, "td", 27), Eo(), So(24, 35), _o(25, JT, 2, 0, "th", 29), _o(26, iR, 4, 6, "td", 27), Eo(), So(27, 37), _o(28, sR, 2, 0, "th", 36), _o(29, rR, 2, 4, "td", 27), Eo(), So(30, 38), _o(31, oR, 4, 1, "mat-header-cell", 39), _o(32, aR, 7, 2, "mat-cell", 40), Eo(), _o(33, lR, 1, 0, "tr", 41), _o(34, cR, 1, 0, "tr", 42), _o(35, uR, 2, 1, "tr", 43), ko(), _o(36, dR, 3, 0, "div", 44), ko()), 2 & t) { const t = Fo(2); qs(5), la("  mat-elevation-z8 ", t.action, " demo-table"), vo("dataSource", t.dataSource4), qs(28), vo("matHeaderRowDef", t.displayedColumns), qs(1), vo("matRowDefColumns", t.displayedColumns), qs(2), vo("ngIf", 0 == t.prog) } } function fR(t, e) { if (1 & t && (Co(0, "div", 19), Co(1, "div", 20), Co(2, "h3", 21), ra(3, " Non-completed Todos "), Co(4, "span", 22), xo(5, "img", 23), ko(), ko(), Co(6, "table", 24), So(7, 25), _o(8, FE, 2, 0, "th", 26), _o(9, LE, 2, 4, "td", 27), Eo(), So(10, 28), _o(11, VE, 2, 0, "th", 29), _o(12, HE, 3, 5, "td", 27), Eo(), So(13, 30), _o(14, UE, 2, 0, "th", 29), _o(15, zE, 2, 4, "td", 27), Eo(), So(16, 31), _o(17, $E, 2, 0, "th", 32), _o(18, qE, 3, 8, "td", 27), Eo(), So(19, 33), _o(20, WE, 2, 0, "th", 29), _o(21, KE, 2, 5, "td", 27), Eo(), So(22, 34), _o(23, YE, 2, 0, "th", 29), _o(24, ZE, 2, 5, "td", 27), Eo(), So(25, 35), _o(26, GE, 2, 0, "th", 36), _o(27, tT, 4, 6, "td", 27), Eo(), So(28, 37), _o(29, eT, 2, 0, "th", 36), _o(30, nT, 2, 4, "td", 27), Eo(), So(31, 38), _o(32, iT, 4, 1, "mat-header-cell", 39), _o(33, sT, 7, 2, "mat-cell", 40), Eo(), _o(34, rT, 1, 0, "tr", 41), _o(35, oT, 1, 0, "tr", 42), _o(36, lT, 2, 1, "tr", 43), ko(), _o(37, cT, 3, 0, "div", 44), ko(), _o(38, VT, 37, 7, "div", 45), _o(39, pR, 37, 7, "div", 18), ko()), 2 & t) { const t = Fo(); qs(6), la("mat-elevation-z8 ", t.action, " demo-table"), vo("dataSource", t.dataSource2), qs(28), vo("matHeaderRowDef", t.displayedColumns), qs(1), vo("matRowDefColumns", t.displayedColumns), qs(2), vo("ngIf", 0 == t.noncomp), qs(1), vo("ngIf", -1 == t.code), qs(1), vo("ngIf", -1 == t.code) } } function mR(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Title"), ko()) } function gR(t, e) { if (1 & t && (Co(0, "td", 47), ra(1), ko()), 2 & t) { const t = e.$implicit; la("", Fo(2).bag, "  fw-bold text-dark  pt-4 font-bold"), qs(1), oa(t.title) } } function _R(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Description "), ko()) } function yR(t, e) { if (1 & t && (Co(0, "span"), ra(1), ko()), 2 & t) { const t = Fo().$implicit; qs(1), aa(" ", t.description, " ") } } function bR(t, e) { if (1 & t) { const t = Ro(); Co(0, "span", 51), ra(1), Co(2, "img", 52), Io("click", function () { Ie(t); const e = Fo().$implicit; return Fo(2).openMsg(e.description) }), ko(), ko() } if (2 & t) { const t = Fo().$implicit, e = Fo(2); qs(1), aa(" ", t.description.substring(0, e.msg), "... ") } } function vR(t, e) { if (1 & t && (Co(0, "td", 47), _o(1, yR, 2, 1, "span", 49), _o(2, bR, 3, 1, "span", 50), ko()), 2 & t) { const t = e.$implicit, n = Fo(2); la("fw-bold ", n.bag, " text-dark  pt-4 font-bold"), qs(1), vo("ngIf", t.description.length <= n.msg), qs(1), vo("ngIf", t.description.length > n.msg) } } function wR(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Start Date "), ko()) } function CR(t, e) { if (1 & t && (Co(0, "td", 47), ra(1), ko()), 2 & t) { const t = e.$implicit; la("fw-bold ", Fo(2).bag, " text-dark  pt-4 font-bold"), qs(1), oa(t.start) } } function kR(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Task Status "), ko()) } function xR(t, e) { if (1 & t && (Co(0, "td", 47), Co(1, "span", 53), ra(2), ko(), ko()), 2 & t) { const t = e.$implicit, n = Fo(2); ca("fw-bold ", n.bag, " text-dark ", n.Task(t), " pt-4 font-bold"), qs(1), la("", n.col, " font-bold"), qs(1), aa(" ", n.task_status, "") } } function SR(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Due Date "), ko()) } function ER(t, e) { if (1 & t && (Co(0, "td", 47), ra(1), ko()), 2 & t) { const t = e.$implicit; la("fw-bold ", Fo(2).bag, " text-dark  pt-4 font-bold"), qs(1), oa(t.due) } } function TR(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Tag"), ko()) } function RR(t, e) { if (1 & t && (Co(0, "span", 53), ra(1), ko()), 2 & t) { const t = Fo().$implicit; la("font-bold ", Fo(2).tagc, ""), qs(1), aa(" ", t.tag, " ") } } function AR(t, e) { if (1 & t && (Co(0, "span", 53), ra(1), ko()), 2 & t) { const t = Fo().$implicit; la("font-bold ", Fo(2).tagcolor, ""), qs(1), aa(" ", t.tag, " ") } } function OR(t, e) { if (1 & t && (Co(0, "td", 47), _o(1, RR, 2, 4, "span", 79), _o(2, AR, 2, 4, "span", 79), ko()), 2 & t) { const t = e.$implicit, n = Fo(2); ca("fw-bold ", n.bag, " pt-4 font-bold ", n.onTag(t), " "), qs(1), vo("ngIf", n.code), qs(1), vo("ngIf", !n.code) } } function IR(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Status"), ko()) } function DR(t, e) { 1 & t && xo(0, "img", 57) } function PR(t, e) { 1 & t && (Co(0, "mat-icon", 58), ra(1, " check_circle "), ko()) } function MR(t, e) { 1 & t && (Co(0, "span", 78), xo(1, "i", 60), ko()) } function NR(t, e) { if (1 & t && (Co(0, "td", 47), _o(1, DR, 1, 0, "img", 54), _o(2, PR, 2, 0, "mat-icon", 55), _o(3, MR, 2, 0, "span", 77), ko()), 2 & t) { const t = e.$implicit; la("fw-bold ", Fo(2).bag, " text-success fs-4 pt-4 font-bold"), qs(1), vo("ngIf", !t.isCompleted && !t.progress), qs(1), vo("ngIf", t.isCompleted && !t.progress), qs(1), vo("ngIf", t.progress && !t.isCompleted) } } function FR(t, e) { 1 & t && (Co(0, "th", 48), ra(1, "Mark"), ko()) } function LR(t, e) { if (1 & t) { const t = Ro(); Co(0, "td", 47), Co(1, "mat-checkbox", 73), Io("ngModelChange", function (t) { return e.$implicit.isCompleted = t })("click", function () { const t = e.$implicit; return t.isCompleted == !t.isCompleted })("click", function () { const e = Ie(t).$implicit; return Fo(2).check(e) }), ko(), ko() } if (2 & t) { const t = e.$implicit; la("fw-bold ", Fo(2).bag, " text-success fs-6 pt-4  font-bold"), qs(1), vo("ngModel", t.isCompleted) } } function VR(t, e) { if (1 & t) { const t = Ro(); Co(0, "mat-header-cell"), Co(1, "button", 62), Io("click", function () { return Ie(t), Fo(2).openAddDialog() }), Co(2, "mat-icon"), ra(3, "add"), ko(), ko(), ko() } 2 & t && (qs(1), vo("color", "primary")) } function jR(t, e) { if (1 & t) { const t = Ro(); Co(0, "mat-cell"), Co(1, "button", 62), Io("click", function () { const e = Ie(t).$implicit; return Fo(2).openUpdateDialog(e, !0) }), Co(2, "mat-icon"), ra(3, "edit"), ko(), ko(), Co(4, "button", 62), Io("click", function () { const e = Ie(t).$implicit; return Fo(2).openDeleteDialog(e) }), Co(5, "mat-icon", 58), ra(6, "delete"), ko(), ko(), ko() } 2 & t && (qs(1), vo("color", "dark"), qs(3), vo("color", "warn")) } function BR(t, e) { 1 & t && xo(0, "tr", 63) } function HR(t, e) { 1 & t && xo(0, "tr", 64) } function UR(t, e) { if (1 & t && (Co(0, "td", 66), ra(1), ko()), 2 & t) { Fo(3); const t = yo(30); qs(1), aa(" No results found for this text - ", t.value, " ") } } function zR(t, e) { if (1 & t && (Co(0, "tr"), _o(1, UR, 2, 1, "td", 65), ko()), 2 & t) { const t = Fo(2); qs(1), vo("ngIf", t.len) } } function $R(t, e) { 1 & t && (Co(0, "div", 67), Co(1, "h3", 68), ra(2, " Todo List - Empty"), ko(), ko()) } function qR(t, e) { if (1 & t && (Co(0, "div", 74), Co(1, "h3"), ra(2), ko(), Co(3, "table", 24), So(4, 25), _o(5, mR, 2, 0, "th", 32), _o(6, gR, 2, 4, "td", 27), Eo(), So(7, 28), _o(8, _R, 2, 0, "th", 32), _o(9, vR, 3, 5, "td", 27), Eo(), So(10, 30), _o(11, wR, 2, 0, "th", 32), _o(12, CR, 2, 4, "td", 27), Eo(), So(13, 31), _o(14, kR, 2, 0, "th", 32), _o(15, xR, 3, 8, "td", 27), Eo(), So(16, 33), _o(17, SR, 2, 0, "th", 29), _o(18, ER, 2, 4, "td", 27), Eo(), So(19, 34), _o(20, TR, 2, 0, "th", 29), _o(21, OR, 3, 6, "td", 27), Eo(), So(22, 35), _o(23, IR, 2, 0, "th", 29), _o(24, NR, 4, 6, "td", 27), Eo(), So(25, 37), _o(26, FR, 2, 0, "th", 36), _o(27, LR, 2, 4, "td", 27), Eo(), So(28, 38), _o(29, VR, 4, 1, "mat-header-cell", 39), _o(30, jR, 7, 2, "mat-cell", 40), Eo(), _o(31, BR, 1, 0, "tr", 41), _o(32, HR, 1, 0, "tr", 42), _o(33, zR, 2, 1, "tr", 43), ko(), _o(34, $R, 3, 0, "div", 44), ko()), 2 & t) { const t = Fo(); qs(1), ca(" button ", t.logo, " ", t.text, " fw-bold text-dark font-bold"), qs(1), aa(" ", t.tag, " "), qs(1), la("mat-elevation-z8 ", t.action, " demo-table"), vo("dataSource", t.dataSource3), qs(28), vo("matHeaderRowDef", t.displayedColumns), qs(1), vo("matRowDefColumns", t.displayedColumns), qs(2), vo("ngIf", 0 == t.len) } } let WR = (() => { class t { constructor(t, e, n) { this._service = t, this.dialog = e, this.snackBar = n, this.displayedColumns = ["title", "description", "isCompleted", "start", "due", "tag", "status", "mark", "actions"], this.columnsToDisplay = this.displayedColumns.slice(), this.completedTodos = [], this.notCompletedTodos = [], this.ProgressTodos = [], this.Urgent = [], this.Important = [], this.UrgentImp = [], this.Today = [], this.Nothing = [], this.All = [], this.bug = 1, this.action = "has-background-primary", this.all = !1, this.dataSource1 = new uw(this.completedTodos), this.dataSource2 = new uw(this.notCompletedTodos), this.dataSource4 = new uw(this.ProgressTodos), this.dataSource3 = new uw(this.All), this.dataSource = new uw(this.All), this.msg = 25, this.bug = 0 } ngOnInit() { this.getAllTodos(), this.code = -1, this.color1 = "has-background-danger-light", this.color2 = "has-background-primary-light", this.color3 = "has-background-warning-light", this.Error(this.noncomp) } Search(t) { const e = t.target.value; -1 == this.code && (this.dataSource2.filter = e.trim().toLowerCase(), this.dataSource1.filter = e.trim().toLowerCase(), this.dataSource4.filter = e.trim().toLowerCase()), this.dataSource3.filter = e.trim().toLowerCase() } getAllTodos() { this._service.getTodos().subscribe(t => { console.log(t), this.dataSource1.data = t.completed, this.dataSource2.data = t.notCompleted, this.dataSource4.data = t.Progress, this.prog = t.Progress.length, this.noncomp = t.notCompleted.length, this.comp = t.completed.length, this.Error2(this.comp), this.Error3(this.prog) }, t => { console.log(t) }) } Home() { this.ngOnInit(), this.searchText = "", this.code = -1, this.select = "", this.bug = 1 } Error(t) { !t && this.bug && this.snackBar.open("No Todos - To Display !", "close", { verticalPosition: "top", duration: 2e3 }) } Error2(t) { t || this.snackBar.open("No Completed Todos !", "close", { verticalPosition: "bottom", duration: 2e3 }) } Error3(t) { t || this.snackBar.open("No Progress Todos !", "close", { verticalPosition: "bottom", duration: 2e3 }) } check(t) { t.isCompleted = !t.isCompleted, t.isCompleted && (t.progress = !1), this._service.updateTodo(t).subscribe(e => { console.log(e), -1 == this.code ? this.getAllTodos() : this.filter(), this.snackBar.open(t.isCompleted ? "Todo Completed Successfully." : "Todo Unmarked.", "close", { verticalPosition: "top", duration: 2e3 }) }, t => { console.log(t) }) } openMsg(t) { this.dialog.open(bE, { data: { todo_desc: t } }).afterClosed().subscribe(() => { }) } onTag(t) { "Important" == t.tag && (this.tagcolor = "text-success"), "Urgent" == t.tag && (this.tagcolor = "text-primary"), "Today" == t.tag && (this.tagcolor = "has-text-info-dark"), "Nothing" == t.tag && (this.tagcolor = "has-text-warning-dark"), "Urgent & Important" == t.tag && (this.tagcolor = "has-text-danger-dark") } Task(t) { t.isCompleted && (this.task_status = "Completed", this.col = "text-success"), t.progress && (this.task_status = "In Progress", this.col = "has-text-warning-dark"), t.isCompleted || t.progress || (this.task_status = "New", this.col = "has-text-info-dark") } filter() { this.searchText = "", this._service.getTodos().subscribe(t => { console.log(t), 0 == this.code && (this.dataSource3 = new uw(this.All), this.dataSource3.data = t.All, this.len = t.All.length), 1 == this.code && (this.dataSource3 = new uw(this.Urgent), this.dataSource3.data = t.Urgent, this.len = t.Urgent.length), 2 == this.code && (this.dataSource3 = new uw(this.Important), this.dataSource3.data = t.Important, this.len = t.Important.length), 3 == this.code && (this.dataSource3 = new uw(this.Today), this.dataSource3.data = t.Today, this.len = t.Today.length), 4 == this.code && (this.dataSource3 = new uw(this.UrgentImp), this.dataSource3.data = t.UrgentImp, this.len = t.UrgentImp.length), 5 == this.code && (this.dataSource3 = new uw(this.Nothing), this.dataSource3.data = t.Nothing, this.len = t.Nothing.length), this.len || this.snackBar.open("No Todos - To Display !", "close", { verticalPosition: "top", duration: 2e3 }) }, t => { console.log(t) }) } filterChanged(t) { const e = t.value; "ALL" == e && (this.code = 0, this.tag = "All Todos", this.logo = "is-dark", this.bag = "has-background-grey-lighter", this.text = "has-text-primary"), "URGENT" == e && (this.code = 1, this.tag = "Urgent Todos", this.logo = "is-link", this.bag = "has-background-link-light", this.text = "text-dark", this.tagc = "text-primary"), "IMP" == e && (this.code = 2, this.tag = "Important Todos", this.logo = "is-primary", this.bag = "has-background-primary-light", this.text = "text-dark", this.tagc = "text-success"), "TODAY" == e && (this.code = 3, this.tag = "Today Todos", this.logo = "is-info", this.bag = "has-background-info-light", this.text = "text-dark", this.tagc = "has-text-info-dark"), "UI" == e && (this.code = 4, this.tag = "Urgent & Important Todos", this.logo = "is-danger", this.bag = "has-background-danger-light", this.text = "text-dark", this.tagc = "has-text-danger-dark"), "NIL" == e && (this.code = 5, this.tag = "Nothing Todos", this.logo = "is-warning", this.bag = "has-background-warning-light", this.text = "text-warning", this.tagc = "has-text-warning-dark"), this.filter() } openAddDialog() { this.dialog.open(eE).afterClosed().subscribe(() => { this.getAllTodos(), this.code > 0 && this.filter() }) } openUpdateDialog(t, e) { this.dialog.open(yE, { data: { todo: t } }).afterClosed().subscribe(() => { this.getAllTodos(), this.code > 0 && this.filter() }) } openDeleteDialog(t) { this.dialog.open(nE, { data: { todoId: t._id } }).afterClosed().subscribe(() => { this.getAllTodos(), this.code > 0 && this.filter() }) } } return t.\u0275fac = function (e) { return new (e || t)(bo(qw), bo(GC), bo(Ok)) }, t.\u0275cmp = zt({ type: t, selectors: [["app-home"]], decls: 33, vars: 4, consts: [[1, "container", "mt-5"], [1, "fw-bold", "fs-4", "py-4", "text-dark", "text-center", "has-background-info-light", "text-black", "font-bold"], ["src", "./assets/favicon.ico", "alt", "Logo", "width", "35", "height", "30", 1, "fas", "fa-spin"], [1, "d-flex", "align-items-start"], ["type", "button", "aria-label", "Example icon-button with share icon", 1, "navbar-brand", "mx-3", "text-dark", "fw-bold", "d-inline-block", "align-text-top", 3, "click"], ["src", "./assets/home.png", "alt", "Logo", "width", "40", "height", "40"], [1, "col-6", "px-4"], [1, "fw-bold", "text-dark", "font-bold"], [1, "fw-bold", "text-dark", "font-bold", 3, "ngModel", "ngModelChange", "selectionChange"], ["value", "ALL", 1, "fw-bold", "has-background-dark", "text-light", "font-bold"], ["value", "URGENT", 1, "fw-bold", "has-background-link", "text-dark", "font-bold"], ["value", "IMP", 1, "fw-bold", "has-background-primary", "text-dark", "font-bold"], ["value", "TODAY", 1, "fw-bold", "has-background-info", "text-dark", "font-bold"], ["value", "UI", 1, "fw-bold", "has-background-danger", "text-dark", "font-bold"], ["value", "NIL", 1, "fw-bold", "has-background-warning", "text-dark", "font-bold"], ["matInput", "", "placeholder", "", "search", "", 3, "ngModel", "ngModelChange", "keyup"], ["input", ""], ["class", "row mt-5", 4, "ngIf"], ["class", "container col-12 mt-5", 4, "ngIf"], [1, "row", "mt-5"], [1, "col-12"], [1, "button", "fw-bold", "text-dark", "font-bold", "is-info", "bg-info", "bg-gradient"], [1, "icon", "mx-1", "fs-5", "text-dark", "is-small"], ["src", "./assets/error.png", "alt", "Logo", "width", "20", "height", "20", 1, "fas", "fa-spin", 2, "--fa-animation-duration", "20s"], ["mat-table", "", 3, "dataSource"], ["matColumnDef", "title"], ["class", "has-background-dark pt-4 fw-bold font-bold has-text-success ", "mat-header-cell", "", 4, "matHeaderCellDef"], ["mat-cell", "", 3, "class", 4, "matCellDef"], ["matColumnDef", "description"], ["class", "fw-bold has-background-dark pt-4 text-dark font-bold  has-text-success", "mat-header-cell", "", 4, "matHeaderCellDef"], ["matColumnDef", "start"], ["matColumnDef", "isCompleted"], ["class", "fw-bold has-background-dark pt-4 text-dark font-bold has-text-success", "mat-header-cell", "", 4, "matHeaderCellDef"], ["matColumnDef", "due"], ["matColumnDef", "tag"], ["matColumnDef", "status"], ["class", "fw-bold has-background-dark pt-4  text-dark font-bold  has-text-success", "mat-header-cell", "", 4, "matHeaderCellDef"], ["matColumnDef", "mark"], ["matColumnDef", "actions"], [4, "matHeaderCellDef"], [4, "matCellDef"], ["mat-header-row", "", 4, "matHeaderRowDef"], ["mat-row", "", 4, "matRowDef", "matRowDefColumns"], [4, "matNoDataRow"], ["class", "mt-6 text-center has-background-grey-lighter", 4, "ngIf"], ["class", " col-12 mt-5", 4, "ngIf"], ["mat-header-cell", "", 1, "has-background-dark", "pt-4", "fw-bold", "font-bold", "has-text-success"], ["mat-cell", ""], ["mat-header-cell", "", 1, "fw-bold", "has-background-dark", "pt-4", "text-dark", "font-bold", "has-text-success"], [4, "ngIf"], ["class", "d-flex flex-row ", 4, "ngIf"], [1, "d-flex", "flex-row"], ["src", "./assets/msg.png", "alt", "Logo", "width", "22", "height", "20", 1, "mat-checkbox", "pb-4", "has-text-dark", "fs-2", "fw-bold", "font-bold", 3, "click"], ["mat-button", "", "mat-dialog-close", ""], ["src", "./assets/error.png", "alt", "Logo", "width", "20", "height", "20", 4, "ngIf"], ["class", "mr-4", 4, "ngIf"], ["class", "icon has-text-link-dark mr-4 is-small", 4, "ngIf"], ["src", "./assets/error.png", "alt", "Logo", "width", "20", "height", "20"], [1, "mr-4"], [1, "icon", "has-text-link-dark", "mr-4", "is-small"], [1, "fas", "fa-cog", "fa-spin"], ["color", "primary", "name", "Mark", 1, "fw-bold", "text-dark", "font-bold", 3, "ngModel", "ngModelChange", "click"], ["mat-button", "", 3, "color", "click"], ["mat-header-row", ""], ["mat-row", ""], ["class", "mat-cell mt-6 fw-normal fs-6 py-2 text-center has-background-grey-lighter", "colspan", "10", 4, "ngIf"], ["colspan", "10", 1, "mat-cell", "mt-6", "fw-normal", "fs-6", "py-2", "text-center", "has-background-grey-lighter"], [1, "mt-6", "text-center", "has-background-grey-lighter"], [1, "fw-bold", "py-2", "text-danger", "fs-4", "font-bold"], [1, "col-12", "mt-5"], [1, "button", "fw-bold", "text-dark", "is-success", "has-background-success", "bg-gradient", "font-bold"], [1, "fas", "fa-check-circle", "fa-spin", 2, "--fa-animation-duration", "20s"], ["class", "icon has-text-link-dark mr-4  is-small", 4, "ngIf"], ["color", "primary", "name", "Mark", 1, "fw-bold", "text-dark", "mr-4", "font-bold", 3, "ngModel", "ngModelChange", "click"], [1, "container", "col-12", "mt-5"], [1, "button", "btn", "fw-bold", "text-dark", "is-warning", "bg-warning", "bg-gradient", "font-bold"], [1, "icon", "mx-1", "fs-5", "has-text-link-dark", "is-small"], ["class", "icon mr-4 has-text-link-dark is-small", 4, "ngIf"], [1, "icon", "mr-4", "has-text-link-dark", "is-small"], ["mat-button", "", "mat-dialog-close", "", 3, "class", 4, "ngIf"]], template: function (t, e) { 1 & t && (Co(0, "div", 0), Co(1, "h2", 1), xo(2, "img", 2), ra(3, " Task Manager "), xo(4, "img", 2), ko(), Co(5, "div", 3), Co(6, "a", 4), Io("click", function () { return e.Home() }), xo(7, "img", 5), ko(), Co(8, "div", 6), Co(9, "mat-form-field"), Co(10, "mat-label", 7), ra(11, "Select a status"), ko(), Co(12, "mat-select", 8), Io("ngModelChange", function (t) { return e.select = t })("selectionChange", function (t) { return e.filterChanged(t) }), Co(13, "mat-option", 9), ra(14, "All"), ko(), Co(15, "mat-option", 10), ra(16, "Urgent"), ko(), Co(17, "mat-option", 11), ra(18, "Important"), ko(), Co(19, "mat-option", 12), ra(20, "Today"), ko(), Co(21, "mat-option", 13), ra(22, "Urgent & Important"), ko(), Co(23, "mat-option", 14), ra(24, "Nothing"), ko(), ko(), ko(), ko(), Co(25, "div"), Co(26, "mat-form-field"), Co(27, "mat-label", 7), ra(28, "Search "), ko(), Co(29, "input", 15, 16), Io("ngModelChange", function (t) { return e.searchText = t })("keyup", function (t) { return e.Search(t) }), ko(), ko(), ko(), ko(), _o(31, fR, 40, 9, "div", 17), _o(32, qR, 35, 12, "div", 18), ko()), 2 & t && (qs(12), vo("ngModel", e.select), qs(17), vo("ngModel", e.searchText), qs(2), vo("ngIf", -1 == e.code), qs(1), vo("ngIf", -1 != e.code)) }, directives: [vS, hS, XS, ex, Ox, Yv, OS, Vk, Ch, Jv, nw, ew, tw, rw, ow, cw, iw, sw, XC, ME, fE, ck, aw, lw], styles: ["table[_ngcontent-%COMP%]{width:100%}.container[_ngcontent-%COMP%]{min-height:100vh;margin:40px auto}"] }), t })(), KR = (() => { class t { constructor(t) { this._http = t, this.url = dw + "/users" } register(t) { return this._http.post(`${this.url}/register`, Object.assign({}, t)) } login(t) { return this._http.post(`${this.url}/login`, Object.assign({}, t)) } forget(t) { return this._http.post(`${this.url}/forget`, Object.assign({}, t)) } logout() { sessionStorage.removeItem("token"), sessionStorage.removeItem("username"), sessionStorage.removeItem("userId") } } return t.\u0275fac = function (e) { return new (e || t)(li(Iw)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); function YR(t, e) { 1 & t && (Co(0, "mat-error", 22), ra(1, " Email is "), Co(2, "strong"), ra(3, "required"), ko(), ko()) } function ZR(t, e) { 1 & t && (Co(0, "mat-error", 22), ra(1, " Password is "), Co(2, "strong"), ra(3, "required"), ko(), ko()) } function GR(t, e) { if (1 & t && (Co(0, "mat-error", 23), ra(1), ko()), 2 & t) { const t = Fo(); qs(1), aa(" ", t.errorMessage, " ") } } let QR = (() => { class t { constructor(t, e, n) { this._service = t, this._router = e, this.snackbar = n, this.hide = !0, this.color = "has-background-light", this.btn = "has-text-grey-lighter", this.formValues = { email: "", password: "" } } ngOnInit() { } changecolor() { this.btn = 1 == this.hide ? "has-text-dark" : "has-text-grey-lighter" } onClickLogin() { console.log(this.formValues), this._service.login(this.formValues).subscribe(t => { console.log(t), sessionStorage.setItem("token", t.token), sessionStorage.setItem("userId", t.user._id), sessionStorage.setItem("username", t.user.username), this.snackbar.open("Login Successfull. Welcome To Todo App.", "close", { verticalPosition: "top", duration: 2e3 }), this._router.navigate(["/home"]) }, t => { console.log(t), this.errorMessage = t.error.error }) } } return t.\u0275fac = function (e) { return new (e || t)(bo(KR), bo(jf), bo(Ok)) }, t.\u0275cmp = zt({ type: t, selectors: [["app-login"]], decls: 34, vars: 13, consts: [[1, "form", "centered-content"], [1, "white-box"], [1, "title", "fw-bold", "font-bold", "has-text-success"], [1, "field"], [1, "control", "has-icons-left", "has-icons-right"], ["type", "email", "placeholder", "Email", "required", "", 1, "input", "fw-bold", "font-bold", "has-background-light", 3, "ngModel", "ngModelChange"], ["email", "ngModel"], ["class", "has-text-danger-dark fw-normal font-normal", 4, "ngIf"], [1, "icon", "is-small", "is-left"], [1, "fas", "fa-user"], [1, "d-flex", "has-background-ligh", "flex-row"], ["type", "password", "placeholder", "Password", "required", "", 1, "input", "fw-bold", "font-bold", "has-background-light", 3, "type", "ngModel", "ngModelChange"], ["password", "ngModel"], ["mat-icon-button", "", "matSuffix", "", 3, "click"], [1, "fas", "fa-lock"], ["class", "has-text-danger-dark fw-bold", 4, "ngIf"], ["routerLink", "/forget", 1, "fw-bold"], [1, "field", 2, "display", "flex", "justify-content", "flex-end"], [1, "control"], [1, "button", "is-success", "fw-bold", "font-bold", "has-text-dark", 3, "click"], [1, "fw-bold", "has-text-grey", "font-bold"], ["routerLink", "/register"], [1, "has-text-danger-dark", "fw-normal", "font-normal"], [1, "has-text-danger-dark", "fw-bold"]], template: function (t, e) { if (1 & t && (Co(0, "div", 0), Co(1, "div", 1), Co(2, "h1", 2), ra(3, "Login"), ko(), Co(4, "div", 3), Co(5, "p", 4), Co(6, "input", 5, 6), Io("ngModelChange", function (t) { return e.formValues.email = t }), ko(), _o(8, YR, 4, 0, "mat-error", 7), Co(9, "span", 8), xo(10, "i", 9), ko(), ko(), ko(), Co(11, "div", 3), Co(12, "p", 4), Co(13, "a", 10), Co(14, "input", 11, 12), Io("ngModelChange", function (t) { return e.formValues.password = t }), ko(), Co(16, "button", 13), Io("click", function () { return e.changecolor() })("click", function () { return e.hide = !e.hide }), Co(17, "mat-icon"), ra(18), ko(), ko(), Co(19, "span", 8), xo(20, "i", 14), ko(), ko(), _o(21, ZR, 4, 0, "mat-error", 7), ko(), _o(22, GR, 2, 1, "mat-error", 15), ko(), Co(23, "a", 16), ra(24, "Forget Password?"), ko(), Co(25, "div", 17), Co(26, "p", 18), Co(27, "button", 19), Io("click", function () { return e.onClickLogin() }), ra(28, " Login "), ko(), ko(), ko(), Co(29, "p", 20), ra(30, "Not got an account? "), Co(31, "a", 21), ra(32, "Sign up"), ko(), ra(33, " now!"), ko(), ko(), ko()), 2 & t) { const t = yo(7), n = yo(15); qs(6), vo("ngModel", e.formValues.email), qs(2), vo("ngIf", t.invalid && (t.dirty || t.touched)), qs(6), vo("type", e.hide ? "password" : "text")("ngModel", e.formValues.password), qs(2), ca("button is-small ", e.btn, " ", e.color, ""), mo("aria-label", "Hide password")("aria-pressed", e.hide), qs(2), oa(e.hide ? "visibility_off" : "visibility"), qs(3), vo("ngIf", n.invalid && (n.dirty || n.touched)), qs(1), vo("ngIf", e.errorMessage) } }, directives: [Vk, Lx, ex, Ox, Ch, ck, fS, ME, Hf, oS], styles: [".form[_ngcontent-%COMP%]{background:linear-gradient(to right top,#44ddd0,#27d7a1)}"] }), t })(); function XR(t, e) { 1 & t && (Co(0, "mat-error", 30), ra(1, " Email is "), Co(2, "strong"), ra(3, "required"), ko(), ko()) } function JR(t, e) { 1 & t && (Co(0, "mat-error", 30), ra(1, " Name is "), Co(2, "strong"), ra(3, "required"), ko(), ko()) } function tA(t, e) { 1 & t && (Co(0, "mat-error", 30), ra(1, " Pet name is "), Co(2, "strong"), ra(3, "required"), ko(), ko()) } function eA(t, e) { 1 & t && (Co(0, "mat-error", 30), ra(1, " Password is "), Co(2, "strong"), ra(3, "required"), ko(), ko()) } function nA(t, e) { 1 & t && (Co(0, "mat-error", 30), ra(1, " Confirm Password is "), Co(2, "strong"), ra(3, "required"), ko(), ko()) } function iA(t, e) { if (1 & t && (Co(0, "mat-error", 31), ra(1), ko()), 2 & t) { const t = Fo(); qs(1), aa(" ", t.errorMessage, " ") } } let sA = (() => { class t { constructor(t, e, n) { this._service = t, this._router = e, this._snackBar = n, this.formValues = { email: "", password: "", confirmPassword: "", name: "", pet: "" }, this.hide1 = !0, this.hide2 = !0, this.color1 = "has-background-light", this.color2 = "has-background-light", this.btn1 = "has-text-grey-lighter", this.btn2 = "has-text-grey-lighter" } ngOnInit() { } changecolor1() { this.btn1 = 1 == this.hide1 ? "has-text-dark" : "has-text-grey-lighter" } changecolor2() { this.btn2 = 1 == this.hide2 ? "has-text-dark" : "has-text-grey-lighter" } onClickRegister() { console.log(this.formValues), this._service.register(this.formValues).subscribe(t => { console.log(t), this._router.navigate(["/login"]), this._snackBar.open("Registration Successfull. Please, login to continue.", "close", { verticalPosition: "top", duration: 2e3 }) }, t => { console.log(t), this.errorMessage = t.error.error }) } } return t.\u0275fac = function (e) { return new (e || t)(bo(KR), bo(jf), bo(Ok)) }, t.\u0275cmp = zt({ type: t, selectors: [["app-register"]], decls: 56, vars: 27, consts: [[1, "form", "centered-content"], [1, "white-box"], [1, "title", "fw-bold", "font-bold", "has-text-primary"], [1, "field"], [1, "control", "has-icons-left", "has-icons-right"], ["type", "email", "placeholder", "Email", "required", "", 1, "input", "fw-bold", "font-bold", "has-background-light", 3, "ngModel", "ngModelChange"], ["email", "ngModel"], ["class", "has-text-danger-dark fw-normal font-normal", 4, "ngIf"], [1, "icon", "is-small", "is-left"], [1, "fas", "fa-user"], ["type", "text", "placeholder", "Name", "required", "", 1, "input", "fw-bold", "font-bold", "has-background-light", 3, "ngModel", "ngModelChange"], ["name", "ngModel"], [1, "fas", "fa-user-circle"], ["type", "text", "placeholder", "Enter your pet name", "required", "", 1, "input", "fw-bold", "font-bold", "has-background-light", 3, "ngModel", "ngModelChange"], ["pet", "ngModel"], [1, "fas", "fa-dog"], [1, "d-flex", "has-background-ligh", "flex-row"], ["type", "password", "placeholder", "Password", "required", "", 1, "input", "fw-bold", "font-bold", "has-background-light", 3, "type", "ngModel", "ngModelChange"], ["password", "ngModel"], ["mat-icon-button", "", "matSuffix", "", 3, "click"], [1, "fas", "fa-lock"], [1, "control", "has-icons-left"], ["type", "password", "placeholder", "Confirm Password", "required", "", 1, "input", "fw-bold", "font-bold", "has-background-light", 3, "type", "ngModel", "ngModelChange"], ["confirmPassword", "ngModel"], ["class", "has-text-danger-dark fw-bold", 4, "ngIf"], [1, "field", 2, "display", "flex", "justify-content", "flex-end"], [1, "control"], [1, "button", "is-success", "fw-bold", "font-bold", "has-text-dark", 3, "click"], [1, "fw-bold", "has-text-grey", "font-bold"], ["routerLink", "/login"], [1, "has-text-danger-dark", "fw-normal", "font-normal"], [1, "has-text-danger-dark", "fw-bold"]], template: function (t, e) { if (1 & t && (Co(0, "div", 0), Co(1, "div", 1), Co(2, "h1", 2), ra(3, "Sign up"), ko(), Co(4, "div", 3), Co(5, "p", 4), Co(6, "input", 5, 6), Io("ngModelChange", function (t) { return e.formValues.email = t }), ko(), _o(8, XR, 4, 0, "mat-error", 7), Co(9, "span", 8), xo(10, "i", 9), ko(), ko(), ko(), Co(11, "div", 3), Co(12, "p", 4), Co(13, "input", 10, 11), Io("ngModelChange", function (t) { return e.formValues.name = t }), ko(), _o(15, JR, 4, 0, "mat-error", 7), Co(16, "span", 8), xo(17, "i", 12), ko(), ko(), ko(), Co(18, "div", 3), Co(19, "p", 4), Co(20, "input", 13, 14), Io("ngModelChange", function (t) { return e.formValues.pet = t }), ko(), _o(22, tA, 4, 0, "mat-error", 7), Co(23, "span", 8), xo(24, "i", 15), ko(), ko(), ko(), Co(25, "div", 3), Co(26, "p", 4), Co(27, "a", 16), Co(28, "input", 17, 18), Io("ngModelChange", function (t) { return e.formValues.password = t }), ko(), Co(30, "button", 19), Io("click", function () { return e.changecolor1() })("click", function () { return e.hide1 = !e.hide1 }), Co(31, "mat-icon"), ra(32), ko(), ko(), Co(33, "span", 8), xo(34, "i", 20), ko(), ko(), _o(35, eA, 4, 0, "mat-error", 7), ko(), Co(36, "p", 21), Co(37, "a", 16), Co(38, "input", 22, 23), Io("ngModelChange", function (t) { return e.formValues.confirmPassword = t }), ko(), Co(40, "button", 19), Io("click", function () { return e.changecolor2() })("click", function () { return e.hide2 = !e.hide2 }), Co(41, "mat-icon"), ra(42), ko(), ko(), Co(43, "span", 8), xo(44, "i", 20), ko(), ko(), _o(45, nA, 4, 0, "mat-error", 7), ko(), _o(46, iA, 2, 1, "mat-error", 24), ko(), Co(47, "div", 25), Co(48, "p", 26), Co(49, "button", 27), Io("click", function () { return e.onClickRegister() }), ra(50, " Sign up "), ko(), ko(), ko(), Co(51, "p", 28), ra(52, "Already got an account? "), Co(53, "a", 29), ra(54, "Login"), ko(), ra(55, " now!"), ko(), ko(), ko()), 2 & t) { const t = yo(7), n = yo(14), i = yo(21), s = yo(29), r = yo(39); qs(6), vo("ngModel", e.formValues.email), qs(2), vo("ngIf", t.invalid && (t.dirty || t.touched)), qs(5), vo("ngModel", e.formValues.name), qs(2), vo("ngIf", n.invalid && (n.dirty || n.touched)), qs(5), vo("ngModel", e.formValues.pet), qs(2), vo("ngIf", i.invalid && (i.dirty || i.touched)), qs(6), vo("type", e.hide1 ? "password" : "text")("ngModel", e.formValues.password), qs(2), ca("button is-small ", e.btn1, " ", e.color1, ""), mo("aria-label", "Hide password")("aria-pressed", e.hide1), qs(2), oa(e.hide1 ? "visibility_off" : "visibility"), qs(3), vo("ngIf", s.invalid && (s.dirty || s.touched)), qs(3), vo("type", e.hide2 ? "password" : "text")("ngModel", e.formValues.confirmPassword), qs(2), ca("button is-small ", e.btn2, " ", e.color2, ""), mo("aria-label", "Hide password")("aria-pressed", e.hide2), qs(2), oa(e.hide2 ? "visibility_off" : "visibility"), qs(3), vo("ngIf", r.invalid && (r.dirty || r.touched)), qs(1), vo("ngIf", e.errorMessage) } }, directives: [Vk, Lx, ex, Ox, Ch, ck, fS, ME, Hf, oS], styles: [".form[_ngcontent-%COMP%]{background:linear-gradient(to right top,#44ddd0,#27d7a1)}"] }), t })(), rA = (() => { class t { constructor(t, e) { this.snackBar = t, this._router = e } canActivate(t, e) { return !sessionStorage.getItem("token") || (this.snackBar.open("You are already logged in.", "", { verticalPosition: "top", duration: 2e3 }), this._router.navigate(["/home"]), !1) } } return t.\u0275fac = function (e) { return new (e || t)(li(Ok), li(jf)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(), oA = (() => { class t { constructor(t, e) { this.snackBar = t, this._router = e } canActivate(t, e) { return !!sessionStorage.getItem("token") || (this.snackBar.open("You have to login first.", "close", { verticalPosition: "top", duration: 2e3 }), this._router.navigate(["/login"]), !1) } } return t.\u0275fac = function (e) { return new (e || t)(li(Ok), li(jf)) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(); function aA(t, e) { 1 & t && (Co(0, "mat-error", 22), ra(1, " Email is "), Co(2, "strong"), ra(3, "required"), ko(), ko()) } function lA(t, e) { 1 & t && (Co(0, "mat-error", 22), ra(1, " Pet name is "), Co(2, "strong"), ra(3, "required"), ko(), ko()) } function cA(t, e) { 1 & t && (Co(0, "mat-error", 22), ra(1, " Password is "), Co(2, "strong"), ra(3, "required"), ko(), ko()) } function hA(t, e) { if (1 & t && (Co(0, "mat-error", 23), ra(1), ko()), 2 & t) { const t = Fo(); qs(1), aa(" ", t.errorMessage, " ") } } const uA = [{ path: "", redirectTo: "/home", pathMatch: "full" }, { path: "login", component: QR, canActivate: [rA] }, { path: "register", component: sA, canActivate: [rA] }, { path: "forget", component: (() => { class t { constructor(t, e, n) { this._service = t, this._router = e, this.snackbar = n, this.hide = !0, this.color = "has-background-light", this.btn = "has-text-grey-lighter", this.formValues = { email: "", password: "", pet: "" } } ngOnInit() { } changecolor() { this.btn = 1 == this.hide ? "has-text-dark" : "has-text-grey-lighter" } onClickForget() { console.log(this.formValues), this._service.forget(this.formValues).subscribe(t => { console.log(t), this._router.navigate(["/login"]), this.snackbar.open("Password Changed Successfully. Please Login to continue.", "close", { verticalPosition: "top", duration: 3e3 }) }, t => { console.log(t), this.errorMessage = t.error.error }) } } return t.\u0275fac = function (e) { return new (e || t)(bo(KR), bo(jf), bo(Ok)) }, t.\u0275cmp = zt({ type: t, selectors: [["app-forget"]], decls: 34, vars: 15, consts: [[1, "form", "centered-content"], [1, "white-box"], [1, "title", "text-center", "fw-bold", "font-bold", "has-text-dark"], [1, "field"], [1, "control", "has-icons-left", "has-icons-right"], ["type", "email", "placeholder", "Enter Your Email", "required", "", 1, "input", "fw-bold", "font-bold", "has-background-light", 3, "ngModel", "ngModelChange"], ["email", "ngModel"], ["class", "has-text-danger-dark fw-normal font-normal", 4, "ngIf"], [1, "icon", "is-small", "is-left"], [1, "fas", "fa-user"], ["type", "text", "placeholder", "What is your pet name?", "required", "", 1, "input", "fw-bold", "font-bold", "has-background-light", 3, "ngModel", "ngModelChange"], ["pet", "ngModel"], [1, "fas", "fa-dog"], [1, "d-flex", "has-background-ligh", "flex-row"], ["type", "password", "placeholder", "New Password", "required", "", 1, "input", "fw-bold", "font-bold", "has-background-light", 3, "type", "ngModel", "ngModelChange"], ["password", "ngModel"], ["mat-icon-button", "", "matSuffix", "", 3, "click"], [1, "fas", "fa-lock"], ["class", "has-text-danger-dark fw-bold", 4, "ngIf"], [1, "field", 2, "display", "flex", "justify-content", "flex-center"], [1, "control"], [1, "button", "my-3", "mx-6", "is-success", "fw-bold", "font-bold", "has-text-dark", 3, "click"], [1, "has-text-danger-dark", "fw-normal", "font-normal"], [1, "has-text-danger-dark", "fw-bold"]], template: function (t, e) { if (1 & t && (Co(0, "div", 0), Co(1, "div", 1), Co(2, "h1", 2), ra(3, "Forget Password"), ko(), Co(4, "div", 3), Co(5, "p", 4), Co(6, "input", 5, 6), Io("ngModelChange", function (t) { return e.formValues.email = t }), ko(), _o(8, aA, 4, 0, "mat-error", 7), Co(9, "span", 8), xo(10, "i", 9), ko(), ko(), ko(), Co(11, "div", 3), Co(12, "p", 4), Co(13, "input", 10, 11), Io("ngModelChange", function (t) { return e.formValues.pet = t }), ko(), _o(15, lA, 4, 0, "mat-error", 7), Co(16, "span", 8), xo(17, "i", 12), ko(), ko(), ko(), Co(18, "div", 3), Co(19, "p", 4), Co(20, "a", 13), Co(21, "input", 14, 15), Io("ngModelChange", function (t) { return e.formValues.password = t }), ko(), Co(23, "button", 16), Io("click", function () { return e.changecolor() })("click", function () { return e.hide = !e.hide }), Co(24, "mat-icon"), ra(25), ko(), ko(), Co(26, "span", 8), xo(27, "i", 17), ko(), ko(), _o(28, cA, 4, 0, "mat-error", 7), ko(), _o(29, hA, 2, 1, "mat-error", 18), ko(), Co(30, "div", 19), Co(31, "p", 20), Co(32, "button", 21), Io("click", function () { return e.onClickForget() }), ra(33, " Change Password "), ko(), ko(), ko(), ko(), ko()), 2 & t) { const t = yo(7), n = yo(14), i = yo(22); qs(6), vo("ngModel", e.formValues.email), qs(2), vo("ngIf", t.invalid && (t.dirty || t.touched)), qs(5), vo("ngModel", e.formValues.pet), qs(2), vo("ngIf", n.invalid && (n.dirty || n.touched)), qs(6), vo("type", e.hide ? "password" : "text")("ngModel", e.formValues.password), qs(2), ca("button is-small ", e.btn, " ", e.color, ""), mo("aria-label", "Hide password")("aria-pressed", e.hide), qs(2), oa(e.hide ? "visibility_off" : "visibility"), qs(3), vo("ngIf", i.invalid && (i.dirty || i.touched)), qs(1), vo("ngIf", e.errorMessage) } }, directives: [Vk, Lx, ex, Ox, Ch, ck, fS, ME, oS], styles: [".form[_ngcontent-%COMP%]{background:linear-gradient(to right top,#44ddd0,#27d7a1)}"] }), t })(), canActivate: [rA] }, { path: "home", component: WR, canActivate: [oA] }]; let dA = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ imports: [[Jf.forRoot(uA)], Jf] }), t })(); const pA = ["*", [["mat-toolbar-row"]]], fA = ["*", "mat-toolbar-row"]; class mA { constructor(t) { this._elementRef = t } } const gA = hv(mA); let _A = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275dir = Zt({ type: t, selectors: [["mat-toolbar-row"]], hostAttrs: [1, "mat-toolbar-row"], exportAs: ["matToolbarRow"] }), t })(), yA = (() => { class t extends gA { constructor(t, e, n) { super(t), this._platform = e, this._document = n } ngAfterViewInit() { this._platform.isBrowser && (this._checkToolbarMixedModes(), this._toolbarRows.changes.subscribe(() => this._checkToolbarMixedModes())) } _checkToolbarMixedModes() { } } return t.\u0275fac = function (e) { return new (e || t)(bo(Ma), bo(km), bo(Jc)) }, t.\u0275cmp = zt({ type: t, selectors: [["mat-toolbar"]], contentQueries: function (t, e, n) { if (1 & t && Yl(n, _A, 5), 2 & t) { let t; Wl(t = Zl()) && (e._toolbarRows = t) } }, hostAttrs: [1, "mat-toolbar"], hostVars: 4, hostBindings: function (t, e) { 2 & t && Ko("mat-toolbar-multiple-rows", e._toolbarRows.length > 0)("mat-toolbar-single-row", 0 === e._toolbarRows.length) }, inputs: { color: "color" }, exportAs: ["matToolbar"], features: [so], ngContentSelectors: fA, decls: 2, vars: 0, template: function (t, e) { 1 & t && (Vo(pA), jo(0), jo(1, 1)) }, styles: [".cdk-high-contrast-active .mat-toolbar{outline:solid 1px}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%}\n"], encapsulation: 2, changeDetection: 0 }), t })(), bA = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ imports: [[lv], lv] }), t })(); function vA(t, e) { 1 & t && (Co(0, "form", 9), Co(1, "button", 10), ra(2, " Login "), ko(), Co(3, "button", 11), ra(4, " Signup"), ko(), ko()) } function wA(t, e) { if (1 & t) { const t = Ro(); Co(0, "a", 12), Io("click", function () { return Ie(t), Fo().logout() }), Co(1, "button", 13), ra(2, " Logout "), ko(), ko() } } let CA = (() => { class t { constructor(t, e, n) { this.router = t, this._service = e, this.snackBar = n, t.events.subscribe(e => { this.isHome = "/register" !== t.url && "/login" !== t.url && "/forget" !== t.url, this.isLog = !this.isHome }) } ngOnInit() { } logout() { this._service.logout(), this.router.navigate(["/login"]), this.snackBar.open("Logout successfull.", "close", { verticalPosition: "top", duration: 2e3 }) } } return t.\u0275fac = function (e) { return new (e || t)(bo(jf), bo(KR), bo(Ok)) }, t.\u0275cmp = zt({ type: t, selectors: [["app-header"]], decls: 15, vars: 2, consts: [[1, "has-background-dark"], ["routerLink", "/", 1, "navbar-brand", "fw-bolder", "my-3", "d-flex", "flex-row"], [1, "mx-2"], ["src", "./assets/note.png", "alt", "Logo", "width", "40", "height", "40"], [1, "has-text-warning", "mt-1"], [1, "has-text-primary", "mt-1"], [1, "example-spacer"], ["class", "d-flex", 4, "ngIf"], ["class", "navbar-brand mx-3 text-dark fw-bold d-inline-block align-text-top", "type", "button", "aria-label", "Example icon-button with share icon", 3, "click", 4, "ngIf"], [1, "d-flex"], ["routerLink", "/login", 1, "button", "is-info", "text-white", "fw-bold", "bg-gradient", "mx-2"], ["routerLink", "/register", 1, "button", "is-info", "text-white", "fw-bold", "bg-gradient", "mx-2"], ["type", "button", "aria-label", "Example icon-button with share icon", 1, "navbar-brand", "mx-3", "text-dark", "fw-bold", "d-inline-block", "align-text-top", 3, "click"], [1, "button", "is-info", "text-white", "fw-bold", "bg-gradient", "mx-2"]], template: function (t, e) { 1 & t && (Co(0, "mat-toolbar", 0), Co(1, "p", 1), Co(2, "a", 2), xo(3, "img", 3), ko(), Co(4, "a", 4), ra(5, " T"), ko(), Co(6, "a", 5), ra(7, " ask"), ko(), Co(8, "a", 4), ra(9, "B"), ko(), Co(10, "a", 5), ra(11, " it"), ko(), ko(), xo(12, "span", 6), _o(13, vA, 5, 0, "form", 7), _o(14, wA, 3, 0, "a", 8), ko()), 2 & t && (qs(13), vo("ngIf", e.isLog), qs(1), vo("ngIf", e.isHome)) }, directives: [yA, Bf, Ch, Ix, nx, Tx], styles: [".example-spacer[_ngcontent-%COMP%]{flex:1 1 auto}"] }), t })(), kA = (() => { class t { constructor() { } ngOnInit() { } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = zt({ type: t, selectors: [["app-footer"]], decls: 5, vars: 0, consts: [[1, "footer", "bg-dark", "text-light", "py-3"], [1, "text-center", "fw-6", "fw-bolder", "font-bold", "my-2"], [1, "has-text-success"]], template: function (t, e) { 1 & t && (Co(0, "footer", 0), Co(1, "p", 1), ra(2, " copyright \xa9 "), Co(3, "a", 2), ra(4, " Encoding"), ko(), ko(), ko()) }, styles: [""] }), t })(), xA = (() => { class t { constructor() { this.title = "todo-frontend" } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275cmp = zt({ type: t, selectors: [["app-root"]], decls: 3, vars: 0, template: function (t, e) { 1 & t && (xo(0, "app-header"), xo(1, "router-outlet"), xo(2, "app-footer")) }, directives: [CA, zf, kA], styles: [""] }), t })(), SA = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ imports: [[lv], lv] }), t })(), EA = (() => { class t { constructor() { } intercept(t, e) { const n = sessionStorage.getItem("token"); console.log(n); const i = t.clone({ headers: t.headers.set("Authorization", `Bearer ${n}`) }); return e.handle(i) } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ token: t, factory: t.\u0275fac, providedIn: "root" }), t })(), TA = (() => { class t { constructor() { this.changes = new k, this.calendarLabel = "Calendar", this.openCalendarLabel = "Open calendar", this.closeCalendarLabel = "Close calendar", this.prevMonthLabel = "Previous month", this.nextMonthLabel = "Next month", this.prevYearLabel = "Previous year", this.nextYearLabel = "Next year", this.prevMultiYearLabel = "Previous 24 years", this.nextMultiYearLabel = "Next 24 years", this.switchToMonthViewLabel = "Choose date", this.switchToMultiYearViewLabel = "Choose month and year" } formatYearRange(t, e) { return `${t} \u2013 ${e}` } } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275prov = dt({ factory: function () { return new t }, token: t, providedIn: "root" }), t })(); const RA = { provide: new $n("mat-datepicker-scroll-strategy"), deps: [OC], useFactory: function (t) { return () => t.scrollStrategies.reposition() } }; let AA = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({ providers: [TA, RA], imports: [[Ah, hk, FC, d_, Jw, lv], Xm] }), t })(), OA = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t }), t.\u0275inj = pt({}), t })(), IA = (() => { class t { } return t.\u0275fac = function (e) { return new (e || t) }, t.\u0275mod = Kt({ type: t, bootstrap: [xA] }), t.\u0275inj = pt({ providers: [{ provide: Pw, useClass: EA, multi: !0 }], imports: [[du, dA, nv, bA, NE, hk, jx, SA, wS, IS, $w, Rk, hw, ik, gE, AA, Ev, JS, Bx, OA]] }), t })(); (function () { if (Pc) throw new Error("Cannot enable prod mode after platform setup."); Dc = !1 })(), hu().bootstrapModule(IA).catch(t => console.error(t)) } }, t => { "use strict"; t(t.s = 657) }]);